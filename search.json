[{"title":"网站说明！！","url":"/2023/05/27/网站说明！！/","content":"# 网站访问方式\n> 建议各位老师采取在线访问方式，本地压缩包访问，内容更新不及时，有些bug可能没有修复（如果需要最新源代码，可以去Github下载）\n\n## 在线访问地址：\n\n- [xming66.github.io](https://xming66.github.io/)（首选，正常可以访问，但有时会出现无法访问情况）\n- [blog-ming.vercel.app](https://blog-ming.vercel.app/)（国内无法正常访问，需要梯子）\n- [xMing-Blog](http://43.138.12.31:8111/)（国内正常访问）\n\n## Github仓库地址：[Github个人博客](https://github.com/xMing66/xMing66.github.io)\n\n## 代码本地运行\n\n1. 在当前项目文件夹下，运行cmd，打开cmd窗口\n    ![cmd操作](/assets/prompt/cmd.gif)\n2. 确保你已经安装了Node.js。你可以在命令行中输入以下命令来检查是否已经安装：\n    \n   ~~~bash\n   node --version\n   ~~~\n    ![检查安装](/assets/prompt/node-v.gif)\n   如果安装成功，将显示安装的Node.js版本号。如果未安装，请前往Node.js官方网站(https://nodejs.org/) 下载和安装最新版本。\n\n3. 在cmd窗口下，执行以下命令\n   \n   ~~~bash\n   http-server -p 3000\n   ~~~\n    ![运行](/assets/prompt/run.gif)\n   如果报错，说明`http-server`模块没有安装，通过以下命令安装模块\n\n   ~~~bash\n   npm install -g http-server\n   ~~~\n\n4. 安装完成后，重新运行下面命令\n\n   ~~~bash\n   http-server -p 3000\n   ~~~\n\n5. 然后在cmd窗口中，按住`Ctrl`的同时，点击链接，或者在浏览器中输入`http://127.0.0.1:3000`运行\n\n6. 如果还是运行不了，请各位老师联系我\n\n# 网站细节简单介绍\n\n> 下面介绍网站的细节部分，主要功能由各位老师亲身体验以获得更全面的了解\n\n## 移动适配\n\n本站已完成已完成电脑，平板，手机多端适配，兼容各种型号设备\n\n## 白天黑夜双模式\n\n本站已完成白天和黑夜两种模式适配，针对黑夜模式，进行了单独页面优化\n\n使用方法\n\n- 点击网页右下角齿轮，弹出两个按钮\n- 点击弹出第一个按钮，可以进行白天黑夜切换\n\n## 搜索功能\n右上角搜索，可以对本站所有文章内容进行检索\n\n## 标签卡片\n\n网站右侧的标签卡片，会因文章对应数量多少，产生不同大小\n\n> 压缩包内容最后更新于2023/5/28，要想查看最新网页内容，请访问[在线地址](https://xming66.github.io/)，或前往[Github](https://github.com/xMing66/xMing66.github.io)下载最新代码","tags":["网站说明"],"categories":["网站说明"]},{"title":"jQuery笔记-05jQuery插件","url":"/2023/05/26/jQuery笔记-05jQuery插件/","content":"# 一、jQuery插件\n\n## 1.1、说明\n\n​\t\tjQuery 功能比较有限，想要更复杂的特效效果，可以借助于 jQuery 插件完成。\n\n​\t\t注意: 这些插件也是依赖于jQuery来完成的，所以必须要先引入jQuery文件，因此也称为 jQuery 插件。\n\n​\t\t**jQuery 插件常用的网站：**\n\n- jQuery 插件库 http://www.jq22.com/ \n\n- jQuery 之家 http://www.htmleaf.com/ \n\n  **jQuery 插件使用步骤：**\n\n  1、引入相关文件。（jQuery 文件 和 插件文件） \n\n  2、复制相关html、css、js (调用插件)。\n\n## 1.2、瀑布流插件\n\n### 1.2.1、说明\n\n​\t\t我们学习的第一个插件是jQuery之家的开源插件，瀑布流。我们将重点详细讲解，从找到插件所在网页，然后点击下载代码，到插件的使用等，后面的插件使用可参考瀑布流插件的使用。\n\n​\t\t插件的使用三点：   \n\n1. 引入css.           \n\n2. 引入JS            \n\n3. 引入html。 \n\n   （有的简单插件只需引入html和js，甚至有的只需引入js）\n\n![0011](/assets/jQuery笔记/0011.png)\n\n### 1.2.2、开发步骤\n\n![0012](/assets/jQuery笔记/0012.png)\n\n#### 1.2.2.1、引入css\n\n```html\n<head>\n    <style>\n        #gallery-wrapper {\n            position: relative;\n            max-width: 75%;\n            width: 75%;\n            margin: 50px auto;\n        }\n        \n        img.thumb {\n            width: 100%;\n            max-width: 100%;\n            height: auto;\n        }\n        \n        .white-panel {\n            position: absolute;\n            background: white;\n            border-radius: 5px;\n            box-shadow: 0px 1px 2px rgba(0, 0, 0, 0.3);\n            padding: 10px;\n        }\n        \n        .white-panel h1 {\n            font-size: 1em;\n        }\n        \n        .white-panel h1 a {\n            color: #A92733;\n        }\n        \n        .white-panel:hover {\n            box-shadow: 1px 1px 10px rgba(0, 0, 0, 0.5);\n            margin-top: -5px;\n            -webkit-transition: all 0.3s ease-in-out;\n            -moz-transition: all 0.3s ease-in-out;\n            -o-transition: all 0.3s ease-in-out;\n            transition: all 0.3s ease-in-out;\n        }\n    </style>\n</head>\n```\n\n#### 1.2.2.2、引入js\n\n```html\n<head>\n    <script src=\"./js/jquery-3.6.0.min.js\"></script>\n    <script src=\"./js/pinterest_grid.js\"></script>\n</head>\n```\n\n#### 1.2.2.3、编写html\n\n```html\n<body>\n    <section id=\"gallery-wrapper\">\n        <article class=\"white-panel\">\n            <img src=\"img/1.jpg\" class=\"thumb\">\n            <h1><a href=\"#\">Title 1</a></h1>\n            <p>Description 1</p>\n        </article>\n        <article class=\"white-panel\">\n            <img src=\"img/2.jpg\" class=\"thumb\">\n            <h1><a href=\"#\">Title 2</a></h1>\n            <p>Description 2</p>\n        </article>\n        <article class=\"white-panel\">\n            <img src=\"img/3.jpg\" class=\"thumb\">\n            <h1><a href=\"#\">Title 3</a></h1>\n            <p>Description 3</p>\n        </article>\n        <article class=\"white-panel\">\n            <img src=\"img/4.jpg\" class=\"thumb\">\n            <h1><a href=\"#\">Title 4</a></h1>\n            <p>Description 4</p>\n        </article>\n        <article class=\"white-panel\">\n            <img src=\"img/5.jpg\" class=\"thumb\">\n            <h1><a href=\"#\">Title 5</a></h1>\n            <p>Description 5</p>\n        </article>\n        <article class=\"white-panel\">\n            <img src=\"img/6.jpg\" class=\"thumb\">\n            <h1><a href=\"#\">Title 6</a></h1>\n            <p>Description 6</p>\n        </article>\n        <article class=\"white-panel\">\n            <img src=\"img/7.jpg\" class=\"thumb\">\n            <h1><a href=\"#\">Title 7</a></h1>\n            <p>Description 7</p>\n        </article>\n        <article class=\"white-panel\">\n            <img src=\"img/8.jpg\" class=\"thumb\">\n            <h1><a href=\"#\">Title 8</a></h1>\n            <p>Description 8</p>\n        </article>\n        <article class=\"white-panel\">\n            <img src=\"img/9.jpg\" class=\"thumb\">\n            <h1><a href=\"#\">Title 9</a></h1>\n            <p>Description 9</p>\n        </article>\n        <article class=\"white-panel\">\n            <img src=\"img/10.jpg\" class=\"thumb\">\n            <h1><a href=\"#\">Title 10</a></h1>\n            <p>Description 10</p>\n        </article>\n        <article class=\"white-panel\">\n            <img src=\"img/11.jpg\" class=\"thumb\">\n            <h1><a href=\"#\">Title 11</a></h1>\n            <p>Description 11</p>\n        </article>\n        <article class=\"white-panel\">\n            <img src=\"img/12.jpg\" class=\"thumb\">\n            <h1><a href=\"#\">Title 12</a></h1>\n            <p>Description 12</p>\n        </article>\n        <article class=\"white-panel\">\n            <img src=\"img/13.jpg\" class=\"thumb\">\n            <h1><a href=\"#\">Title 13</a></h1>\n            <p>Description 13</p>\n        </article>\n        <article class=\"white-panel\">\n            <img src=\"img/14.jpg\" class=\"thumb\">\n            <h1><a href=\"#\">Title 14</a></h1>\n            <p>Description 14</p>\n        </article>\n        <article class=\"white-panel\">\n            <img src=\"img/15.jpg\" class=\"thumb\">\n            <h1><a href=\"#\">Title 15</a></h1>\n            <p>Description 15</p>\n        </article>\n    </section>\n</body>\n```\n\n### 1.2.3、完整的代码如下\n\n```html\n<head>\n    <script src=\"./js/jquery-3.6.0.min.js\"></script>\n    <script src=\"./js/pinterest_grid.js\"></script>\n    <style>\n        #gallery-wrapper {\n            position: relative;\n            max-width: 75%;\n            width: 75%;\n            margin: 50px auto;\n        }\n        \n        img.thumb {\n            width: 100%;\n            max-width: 100%;\n            height: auto;\n        }\n        \n        .white-panel {\n            position: absolute;\n            background: white;\n            border-radius: 5px;\n            box-shadow: 0px 1px 2px rgba(0, 0, 0, 0.3);\n            padding: 10px;\n        }\n        \n        .white-panel h1 {\n            font-size: 1em;\n        }\n        \n        .white-panel h1 a {\n            color: #A92733;\n        }\n        \n        .white-panel:hover {\n            box-shadow: 1px 1px 10px rgba(0, 0, 0, 0.5);\n            margin-top: -5px;\n            -webkit-transition: all 0.3s ease-in-out;\n            -moz-transition: all 0.3s ease-in-out;\n            -o-transition: all 0.3s ease-in-out;\n            transition: all 0.3s ease-in-out;\n        }\n    </style>\n</head>\n<body>\n    <section id=\"gallery-wrapper\">\n        <article class=\"white-panel\">\n            <img src=\"img/1.jpg\" class=\"thumb\">\n            <h1><a href=\"#\">Title 1</a></h1>\n            <p>Description 1</p>\n        </article>\n        <article class=\"white-panel\">\n            <img src=\"img/2.jpg\" class=\"thumb\">\n            <h1><a href=\"#\">Title 2</a></h1>\n            <p>Description 2</p>\n        </article>\n        <article class=\"white-panel\">\n            <img src=\"img/3.jpg\" class=\"thumb\">\n            <h1><a href=\"#\">Title 3</a></h1>\n            <p>Description 3</p>\n        </article>\n        <article class=\"white-panel\">\n            <img src=\"img/4.jpg\" class=\"thumb\">\n            <h1><a href=\"#\">Title 4</a></h1>\n            <p>Description 4</p>\n        </article>\n        <article class=\"white-panel\">\n            <img src=\"img/5.jpg\" class=\"thumb\">\n            <h1><a href=\"#\">Title 5</a></h1>\n            <p>Description 5</p>\n        </article>\n        <article class=\"white-panel\">\n            <img src=\"img/6.jpg\" class=\"thumb\">\n            <h1><a href=\"#\">Title 6</a></h1>\n            <p>Description 6</p>\n        </article>\n        <article class=\"white-panel\">\n            <img src=\"img/7.jpg\" class=\"thumb\">\n            <h1><a href=\"#\">Title 7</a></h1>\n            <p>Description 7</p>\n        </article>\n        <article class=\"white-panel\">\n            <img src=\"img/8.jpg\" class=\"thumb\">\n            <h1><a href=\"#\">Title 8</a></h1>\n            <p>Description 8</p>\n        </article>\n        <article class=\"white-panel\">\n            <img src=\"img/9.jpg\" class=\"thumb\">\n            <h1><a href=\"#\">Title 9</a></h1>\n            <p>Description 9</p>\n        </article>\n        <article class=\"white-panel\">\n            <img src=\"img/10.jpg\" class=\"thumb\">\n            <h1><a href=\"#\">Title 10</a></h1>\n            <p>Description 10</p>\n        </article>\n        <article class=\"white-panel\">\n            <img src=\"img/11.jpg\" class=\"thumb\">\n            <h1><a href=\"#\">Title 11</a></h1>\n            <p>Description 11</p>\n        </article>\n        <article class=\"white-panel\">\n            <img src=\"img/12.jpg\" class=\"thumb\">\n            <h1><a href=\"#\">Title 12</a></h1>\n            <p>Description 12</p>\n        </article>\n        <article class=\"white-panel\">\n            <img src=\"img/13.jpg\" class=\"thumb\">\n            <h1><a href=\"#\">Title 13</a></h1>\n            <p>Description 13</p>\n        </article>\n        <article class=\"white-panel\">\n            <img src=\"img/14.jpg\" class=\"thumb\">\n            <h1><a href=\"#\">Title 14</a></h1>\n            <p>Description 14</p>\n        </article>\n        <article class=\"white-panel\">\n            <img src=\"img/15.jpg\" class=\"thumb\">\n            <h1><a href=\"#\">Title 15</a></h1>\n            <p>Description 15</p>\n        </article>\n    </section>\n</body>\n```\n\n### 1.2.4、效果图\n\n![0013](/assets/jQuery笔记/0013.png)\n\n## 1.3、图片懒加载\n\n### 1.3.1、说明\n\n​\t\t图片的懒加载就是：当页面滑动到有图片的位置，图片才进行加载，用以提升页面打开的速度及用户体验。\n\n​\t\t懒加载只需引入html 和 js操作 即可，此插件不涉及css。\n\n### 1.3.2、开发步骤\n\n#### 1.3.2.1、编写html\n\n```html\n<body>\n    <img data-lazy-src=\"./img/1.jpg\">\n    <img data-lazy-src=\"./img/2.jpg\">\n    <img data-lazy-src=\"./img/3.jpg\">\n    <img data-lazy-src=\"./img/4.jpg\">\n    <img data-lazy-src=\"./img/5.jpg\">\n    <img data-lazy-src=\"./img/6.jpg\">\n</body>\n```\n\n#### 1.3.2.2、引入js\n\n```html\n<script src=\"./js/jquery-3.6.0.min.js\"></script>\n<script src=\"./js/EasyLazyload.min.js\"></script>\n<script>\n    lazyLoadInit({\n        showTime: 1100,\n        onLoadBackEnd: function(i, e) {\n            console.log(\"onLoadBackEnd:\" + i);\n        },\n        onLoadBackStart: function(i, e) {\n            console.log(\"onLoadBackStart:\" + i);\n        }\n    });\n</script>\n```\n\n### 1.3.3、完整的代码如下\n\n```html\n<body>\n    <img data-lazy-src=\"./img/1.jpg\">\n    <img data-lazy-src=\"./img/2.jpg\">\n    <img data-lazy-src=\"./img/3.jpg\">\n    <img data-lazy-src=\"./img/4.jpg\">\n    <img data-lazy-src=\"./img/5.jpg\">\n    <img data-lazy-src=\"./img/6.jpg\">\n</body>\n<script src=\"./js/jquery-3.6.0.min.js\"></script>\n<script src=\"./js/EasyLazyload.min.js\"></script>\n<script>\n    lazyLoadInit({\n        showTime: 1100,\n        onLoadBackEnd: function(i, e) {\n            console.log(\"onLoadBackEnd:\" + i);\n        },\n        onLoadBackStart: function(i, e) {\n            console.log(\"onLoadBackStart:\" + i);\n        }\n    });\n</script>\n```\n\n","tags":["学习笔记","jQuery"],"categories":["jQuery笔记"]},{"title":"jQuery笔记-04其他内容","url":"/2023/05/26/jQuery笔记-04其他内容/","content":"\n# 一、jQuery 拷贝对象\n\n## 1.1、说明\n\n​\t\t如果想要把某个对象拷贝（合并） 给另外一个对象使用，此时可以使用 $.extend() 方法。\n\n```markdown\n# 语法\n\t$.extend([deep], target, object1, [objectN])\n\t\n# 说明\n\t1. deep: 如果设为true 为深拷贝， 默认为false 浅拷贝\n\t2. target: 要拷贝的目标对象\n\t3. object1: 待拷贝到第一个对象的对象。\n\t4. objectN: 待拷贝到第N个对象的对象。\n\t5. 浅拷贝目标对象引用的被拷贝的对象地址，修改目标对象会影响被拷贝对象。\n\t6. 深拷贝，前面加true， 完全克隆，修改目标对象不会影响被拷贝对象。\n```\n\n## 1.2、拷贝案例\n\n### 1.2.1、案例1\n\n```html\n<body>\n    <script>\n        // 1、目标对象\n        var targetObj = {};\n\n        // 2、源对象\n        var source = {\n            id: 1,\n            uname: 'HelloWorld'\n        };\n\n        // 3、拷贝\n        $.extend(targetObj, source);\n\n        console.log(targetObj);\n    </script>\n</body>\n```\n\n### 1.2.2、案例2\n\n```html\n<body>\n    <script>\n        // 1、目标对象\n        var targetObj = {\n            id: 10\n        };\n\n        // 2、源对象\n        var source = {\n            id: 1,\n            uname: 'HelloWorld'\n        };\n\n        // 查看原来对象中的内容\n        console.log(targetObj);\n\n        // 3、拷贝，会覆盖targetObj 里面原来的数据\n        $.extend(targetObj, source);\n\n        console.log(targetObj);\n    </script>\n</body>\n```\n\n### 1.2.3、案例3\n\n```html\n<body>\n    <script>\n        // 1、目标对象\n        var targetObj = {\n            age: 90\n        };\n\n        // 2、源对象\n        var source = {\n            id: 1,\n            uname: 'HelloWorld'\n        };\n\n        // 查看原来对象中的内容\n        console.log(targetObj);\n\n        // 3、拷贝,会和原来对象进行合并。\n        $.extend(targetObj, source);\n\n        console.log(targetObj);\n    </script>\n</body>\n```\n\n### 1.2.4、案例4\n\n```html\n<body>\n    <script>\n        // 1、目标对象\n        var targetObj = {\n            id: 0,\n            msg: {\n                sex: '男'\n            }\n        };\n\n        // 2、源对象\n        var source = {\n            id: 1,\n            uname: 'HelloWorld',\n            msg: {\n                age: 18\n            }\n        };\n        // 3、拷贝,原对象中包含对象。\n        $.extend(targetObj, source);\n\n        console.log(targetObj);\n    </script>\n</body>\n```\n\n### 1.2.5、案例5\n\n```html\n<body>\n    <script>\n        // 1、目标对象\n        var targetObj = {\n            id: 0,\n            msg: {\n                sex: '男'\n            }\n        };\n\n        // 2、源对象\n        var source = {\n            id: 1,\n            uname: 'HelloWorld',\n            msg: {\n                age: 18\n            }\n        };\n        // 3、拷贝\n        $.extend(targetObj, source);\n\n        // 修改原对象中msg的年龄为30\n        targetObj.msg.age = 30;\n\n        console.log(targetObj);\n        console.log(source);\n        \n        // 总结：浅拷贝把原来对象里面的复杂数据类型地址拷贝给目标对象\n        // >> msg 指向的是同一个内存地址,一改全改\n    </script>\n</body>\n```\n\n### 1.2.6、案例6\n\n```html\n<body>\n    <script>\n        // 1、目标对象\n        var targetObj = {\n            id: 0,\n            msg: {\n                sex: '男'\n            }\n        };\n\n        // 2、源对象\n        var source = {\n            id: 1,\n            uname: 'HelloWorld',\n            msg: {\n                age: 18\n            }\n        };\n        // 3、拷贝\n        $.extend(true, targetObj, source);\n\n        console.log(targetObj);\n    </script>\n</body>\n```\n\n### 1.2.7、案例7\n\n```html\n<body>\n    <script>\n        // 1、目标对象\n        var targetObj = {\n            id: 0,\n            msg: {\n                sex: '男'\n            }\n        };\n\n        // 2、源对象\n        var source = {\n            id: 1,\n            uname: 'HelloWorld',\n            msg: {\n                age: 18\n            }\n        };\n        // 3、拷贝\n        $.extend(true, targetObj, source);\n\n        // 修改原对象中msg的年龄为30\n        targetObj.msg.age = 30;\n\n        console.log(targetObj);\n        console.log(source);\n\n        // 总结：深拷贝把里面的数据完全复制一份给目标对象 如果里面有不冲突的属性,会合并到一起 \n        // >> msg 指向的是不同的内存地址,你的修改和我没关系\n    </script>\n</body>\n```\n\n# 二、 jQuery 多库共存\n\n## 2.1、说明\n\n​\t\tjQuery使用$作为标识符，随着jQuery的流行,其他 js 库也会用这$作为标识符， 这样一起使用会引起冲突。\n\n​\t\t需要一个解决方案，让jQuery 和其他的js库不存在冲突，可以同时存在，这就叫做多库共存。\n\n​\t\t**jQuery 解决方案：**\n\n- 把里面的 $ 符号 统一改为 jQuery。 比如 jQuery(''div'')\n- jQuery 变量规定新的名称：$.noConflict()       var xx = $.noConflict();\n\n## 2.2、案例\n\n### 2.2.1、问题引入\n\n```html\n\n<body>\n    <div>CSS</div>\n    <script>\n        // 自定义函数功能，函数名恰好是 $\n\n        function $() {\n            console.log('HelloWorld');\n        }\n\n        $();\n\n        // 使用 jQuery的 $\n        var $div = $('div');\n        console.log($div); // 查询不到\n        \n        //  总结: 我自定义的 $ 和 jQuery的 $ 冲突了。\n    </script>\n</body>\n```\n\n### 2.2.2、解决方案一\n\n```html\n<body>\n    <div>CSS</div>\n    <script>\n        // 自定义函数功能，函数名恰好是 $\n\n        function $() {\n            console.log('HelloWorld');\n        }\n\n        $();\n\n        //  1. 如果$ 符号冲突 我们就使用 jQuery\n        var $div = jQuery('div');\n        console.log($div); // 查询不到\n    </script>\n</body>\n```\n\n### 2.2.3、解决方案二\n\n```html\n<body>\n    <div>CSS</div>\n    <script>\n        // 自定义函数功能，函数名恰好是 $\n\n        function $() {\n            console.log('HelloWorld');\n        }\n\n        $();\n\n        // 1. 如果$ 符号冲突，让jquery 释放对$ 控制权 调用者决定\n        var $$ = jQuery.noConflict();\n\n        // 2. 使用 $$\n        var $div = $$('div');\n        console.log($div); // 查询不到\n    </script>\n</body>\n```\n\n","tags":["学习笔记","jQuery"],"categories":["jQuery笔记"]},{"title":"jQuery笔记-03事件处理","url":"/2023/05/26/jQuery笔记-03事件处理/","content":"\n# 一、jQuery事件\n\n## 1.1、事件注册\n\n### 1.1.1、单个事件注册\n\n```markdown\n# 语法\n\telement.事件(function(){})\n\n# 案例\n\t$('div').click(function(){ \n\t\t// 事件处理程序 \n    })\n```\n\n​\t\t其他事件和原生基本一致。比如mouseover、mouseout、blur、focus、change、keydown、keyup、\n\nresize、scroll 等。\n\n### 1.1.2、案例\n\n```html\n<body>\n    <div>HelloWorld</div>\n    <script>\n        $('div').click(function() {\n            $(this).css('color', 'red');\n        });\n    </script>\n</body>\n```\n\n### 1.1.3、总结\n\n​\t\tjQuery 为我们提供了方便的事件注册机制。\n\n- 优点: 操作简单，且不用担心事件覆盖等问题。\n- 缺点: 普通的事件注册不能做事件委托，且无法实现事件解绑，需要借助其他方法。\n\n# 二、jQuery事件处理\n\n​\t\t因为普通注册事件方法的不足，jQuery又开发了多个处理方法，重点讲解如下：\n\n- on(): 用于事件绑定，目前最好用的事件绑定方法\n- off(): 事件解绑\n- trigger() / triggerHandler(): 事件触发\n\n## 2.1、on() 绑定事件\n\n### 2.1.1、说明\n\n​\t\ton() 方法在匹配元素上绑定一个或多个事件的事件处理函数。\n\n```markdown\n# 语法\n\telement.on(events,[selector],fn)\n# 说明\n\t1. events:一个或多个用空格分隔的事件类型，如\"click\"或\"keydown\" 。\n\t2. selector: 元素的子元素选择器 。\n\t3. fn:回调函数 即绑定在元素身上的侦听函数。\n```\n\n### 2.1.2、on方法优势一\n\n​\t\t可以绑定多个事件，多个处理事件处理程序。\n\n```html\n<script>\n    $('div').on({\n         mouseover: function() {\n             \n         },\n         mouseout: function() {\n             \n         },\n         click: function() {\n             \n         }\n    });\n    \n    // 如果事件处理程序相同\n    \n    $('div').on('mouseover mouseout', function() {\n         // 处理程序\n    });\n</script>\n```\n\n```html\n<body>\n    <div>HelloWorld</div>\n    <script>\n        $('div').on({\n            mouseover: function() {\n                $(this).css('color', 'red');\n            },\n            mouseout: function() {\n                $(this).css('color', 'blue');\n            },\n            click: function() {\n                $(this).css('color', 'skyblue');\n            }\n        });\n    </script>\n</body>\n```\n\n```html\n<head>\n    <style>\n        .current {\n            background-color: blue;\n        }\n    </style>\n</head>\n<body>\n    <div>HelloWorld</div>\n    <script>\n        $('div').on({\n            mouseover: function() {\n                $(this).addClass('current');\n            },\n            mouseout: function() {\n                $(this).removeClass('current');\n            }\n        });\n    </script>\n</body>\n```\n\n```html\n<head>\n    <style>\n        .current {\n            background-color: blue;\n        }\n    </style>\n</head>\n<body>\n    <div>HelloWorld</div>\n    <script>\n        $('div').on(\"mouseover mouseout\", function() {\n            $(this).toggleClass('current');\n        });\n    </script>\n</body>\n```\n\n### 2.1.3、on方法优势二\n\n​\t\t可以事件委派操作 。事件委派的定义就是，把原来加给子元素身上的事件绑定在父元素身上，就是把事件委派给父元素。\n\n```html\n<body>\n    <ul>\n        <li>周芷若</li>\n        <li>赵敏</li>\n        <li>张无忌</li>\n    </ul>\n    <script>\n        // 可以给每个 li 子元素添加点击事件\n        $('ul li').click(function() {\n            $(this).css('color', 'red');\n        });\n    </script>\n</body>\n```\n\n```html\n<body>\n    <ul>\n        <li>周芷若</li>\n        <li>赵敏</li>\n        <li>张无忌</li>\n    </ul>\n    <script>\n        // on可以实现事件委托（委派）\n        // >> click 是绑定在ul 身上的，但是 触发的对象是 ul 里面的 li 元素\n        $('ul').on('click', 'li', function() {\n            $(this).css('color', 'blue');\n        })\n    </script>\n</body>\n```\n\n​\t\t在此之前有bind(), live() delegate()等方法来处理事件绑定或者事件委派，最新版本的请用**on**替代他们。\n\n### 2.1.4、on方法优势三\n\n​\t\t动态创建的元素，click() 没有办法绑定事件， on() 可以给动态生成的元素绑定事件。\n\n```html\n<script>\n    $('div').on('click', 'p', function() {\n        alert(\"俺可以给动态生成的元素绑定事件\")\n    });\n</script>\n```\n\n```html\n<body>\n    <ul>\n\n    </ul>\n    <button>动态添加一个li节点元素</button>\n    <script>\n        // 1、为按钮绑定事件\n        $('button').click(function() {\n            // >> 动态创建li\n            var $li = $('<li>周芷若</li>');\n            // >> 添加到ul节点\n            $('ul').append($li);\n        });\n\n        // 2、为 li 节点动态的绑定点击事件\n        $('ul').on('click', 'li', function() {\n            $(this).css('color', 'blue');\n        });\n    </script>\n</body>\n```\n\n### 2.1.5、案例\n\n![0010](/assets/jQuery笔记/0010.png)\n\n```html\n<body>\n    <textarea name=\"\" class=\"txt\" cols=\"30\" rows=\"10\"></textarea>\n    <input type=\"button\" value=\"发表\" class=\"publish\">\n    <ul></ul>\n    <script>\n        // 1、点击发布按钮， 动态创建li，放入文本框的内容和删除按钮， 并且添加到ul 中\n        $('.publish').on('click', function() {\n            // >> 1.1 获取文本域的内容\n            var content = $('textarea').val();\n            if (content.trim() != '') {\n                // >> 1.2 创建 li\n                var $li = $('<li></li>');\n                $li.html(content + \" <a href='javascript:;'>删除</a>\");\n                // >> 1.3 添加到ul\n                $('ul').prepend($li);\n                // >> 1.4 清空textarea\n                $('textarea').val('');\n            }\n        });\n\n        // 2、点击的删除按钮，可以删除当前的li\n        // >> on 可以为未来的元素添加事件\n        $('ul').on('click', 'a', function() {\n            $(this).parent().remove();\n        });\n    </script>\n</body>\n```\n\n## 2.2、off() 解绑事件\n\n### 2.2.1、说明\n\n​\t\t当某个事件上面的逻辑，在特定需求下不需要的时候，可以把该事件上的逻辑移除，这个过程我们称为事件\n\n解绑。jQuery 为我们提供 了多种事件解绑方法：die() / undelegate() / off() 等，甚至还有只触发一次的事件绑定\n\n方法 one()，在这里我们重点讲解一下 off() 。\n\n​\t\t==**off() 方法可以移除通过 on() 方法添加的事件处理程序。**==\n\n### 2.2.2、语法\n\n```markdown\n1. $(\"p\").off() \t\t\t\t// 解绑p元素所有事件处理程序\n2. $(\"p\").off( \"click\") \t\t// 解绑p元素上面的点击事件 后面的 click 是侦听函数名\n3. $(\"ul\").off(\"click\", \"li\");  // 解绑事件委托\n```\n\n​\t\t如果有的事件只想触发一次， 可以使用 one() 来绑定事件。\n\n### 2.2.3、案例1\n\n```html\n<body>\n    <div>周芷若</div>\n    <script>\n        // 1、为 div 元素 添加点击事件和鼠标悬浮的事件\n        $(\"div\").on({\n            click: function() {\n                console.log(\"我点击了\");\n            },\n            mouseover: function() {\n                console.log('我鼠标经过了');\n            }\n        });\n\n        // 2、为 div 解绑所有的事件\n        $('div').off();\n    </script>\n</body>\n```\n\n### 2.2.4、案例2\n\n```html\n<body>\n    <div>周芷若</div>\n    <script>\n        // 1、为 div 元素 添加点击事件和鼠标悬浮的事件\n        $(\"div\").on({\n            click: function() {\n                console.log(\"我点击了\");\n            },\n            mouseover: function() {\n                console.log('我鼠标经过了');\n            }\n        });\n\n        // 2、只是解除了div身上的点击事件\n        $('div').off('click');\n    </script>\n</body>\n```\n\n### 2.2.5、案例3\n\n```html\n<body>\n    <ul>\n        <li>周芷若</li>\n        <li>赵敏</li>\n        <li>张无忌</li>\n    </ul>\n    <script>\n        // 1、使用 on 方法实现 对 li 进行事件委托\n        $('ul').on('click', 'li', function() {\n            $(this).css('color', 'red');\n        });\n\n\n        // 2、off()方法也能实现 对委托的元素进行事件解绑\n        $('ul').off('click', 'li');\n    </script>\n</body>\n```\n\n### 2.2.6、one() 方法\n\n​\t\tone() 只能触发事件一次。\n\n```html\n<body>\n    <div>周芷若</div>\n    <script>\n        // 1、使用 one() 方法实现绑定一次事件\n        $('div').one('click', function() {\n            console.log('我只是触发一次哦');\n        });\n    </script>\n</body>\n```\n\n## 2.3、trigger()自动触发事件\n\n### 2.3.1、说明\n\n​\t\t有些事件希望自动触发, 比如轮播图自动播放功能跟点击右侧按钮一致。可以利用定时器自动触发右侧按钮点击事件，不必鼠标点击触发。由此 jQuery 为我们提供了两个自动触发事件 trigger() 和 triggerHandler() ; \n\n```markdown\n1. element.click() \t\t\t\t\t\t// 第一种简写形式\n\n2. element.trigger(\"事件类型\")  \t\t// 第二种自动触发模式\n\n3. element.triggerHandler('事件类型') \t// 第三种自动触发模式\n\t\ttriggerHandler模式不会触发元素的默认行为，这是和前面两种的区别\n```\n\n### 2.3.2、案例1\n\n```html\n<body>\n    <div>周芷若</div>\n    <script>\n        // 1、绑定事件\n        $('div').on('click', function() {\n            $(this).css('color', 'red');\n        });\n\n        // 2、自动触发\n        $('div').click();\n    </script>\n</body>\n```\n\n### 2.3.3、案例2\n\n```html\n<body>\n    <div>周芷若</div>\n    <script>\n        // 1、绑定事件\n        $('div').on('click', function() {\n            $(this).css('color', 'red');\n        });\n\n        // 2、自动触发\n        $('div').trigger('click');\n    </script>\n</body>\n```\n\n### 2.3.4、案例3\n\n```html\n<body>\n    用户名：<input type=\"text\">\n    <script>\n        // 1、绑定事件\n        $(\"input\").on(\"focus\", function() {\n            $(this).val(\"HelloWorld\");\n        });\n\n        // 触发鼠标获取焦点的事件，会触发默认行为，有光标闪烁。\n        $(\"input\").trigger('focus');\n    </script>\n</body>\n```\n\n### 2.3.5、案例4\n\n```html\n<body>\n    用户名：<input type=\"text\">\n    <script>\n        // 1、绑定事件\n        $(\"input\").on(\"focus\", function() {\n            $(this).val(\"HelloWorld\");\n        });\n\n        // 触发鼠标获取焦点的事件，会触发默认行为，有光标闪烁。\n        $(\"input\").focus();\n    </script>\n</body>\n```\n\n### 2.3.6、案例5\n\n```html\n<body>\n    用户名：<input type=\"text\">\n    <script>\n        // 1、绑定事件\n        $(\"input\").on(\"focus\", function() {\n            $(this).val(\"HelloWorld\");\n        });\n\n        // 触发鼠标获取焦点的事件，但是不会触发默认行为，不会有光标闪烁。\n        $(\"input\").triggerHandler('focus');\n    </script>\n</body>\n```\n\n## 2.4、事件对象\n\n### 2.4.1、说明\n\n​\t\tjQuery 对DOM中的事件对象 event 进行了封装，兼容性更好，获取更方便，使用变化不大。事件被触发，就\n\n会有事件对象的产生。\n\n```markdown\n# 语法\n\telement.on(events,[selector],function(event) {})\n# 说明\n\t阻止默认行为：event.preventDefault() 或者 return false \n\t阻止冒泡： event.stopPropagation()\n```\n\n### 2.4.2、案例\n\n```html\n<body>\n    <div>张无忌</div>\n    <script>\n        // 1、为 document 对象 绑定点击事件\n        $(document).on(\"click\", function() {\n            console.log('点击了document文档对象');\n        });\n\n        // 2、为 div 绑定点击事件\n        $('div').on('click', function(event) {\n            console.log('我点击了div');\n            // >> 阻止事件冒泡\n            event.stopPropagation();\n        });\n    </script>\n</body>\n```\n\n​\t\t==**注意：jQuery中的 event 对象使用，可以借鉴 API 和 DOM 中的 event。**==\n\n","tags":["学习笔记","jQuery"],"categories":["jQuery笔记"]},{"title":"jQuery笔记-02元素操作","url":"/2023/05/26/jQuery笔记-02元素操作/","content":"\n# 一、属性操作\n\n## 1.1、说明\n\n​\t\tjQuery 常用属性操作有三种：prop() / attr() / data() ;\n\n## 1.2、元素固有属性值 prop()\n\n### 1.2.1、说明\n\n​\t\t所谓元素固有属性就是元素本身自带的属性，比如 `<a>` 元素里面的 href ，比如 `<input>` 元素里面的 type。\n\n### 1.2.2、获取属性\n\n#### 1.2.2.1、语法\n\n```markdown\n# prop('属性)\n```\n\n#### 1.2.2.2、案例1\n\n```html\n<body>\n    <a href=\"https://www.baidu.com\" title=\"百度一下呗\">百度一下,你就知道</a>\n    <script>\n        // prop(): 获取元素自有的属性\n        var href = $('a').prop('href');\n        var title = $('a').prop('title');\n        console.log(href);\n        console.log(title);\n    </script>\n</body>\n```\n\n#### 1.2.2.3、案例2\n\n```html\n<body>\n    跳舞:<input type=\"checkbox\" checked>\n    <script>\n        // prop(): 获取元素自有的属性\n        $('input').change(function() {\n            var status = $(this).prop('checked');\n            console.log(status);\n        });\n    </script>\n</body>\n```\n\n#### 1.2.2.4、案例3\n\n```html\n<body>\n    <div index='1'></div>\n    <script>\n        // 自定义元素的属性,通过prop是获取不到属性值的。\n        // prop(): 获取元素自有的属性\n        console.log($('div').prop('index'));\n    </script>\n</body>\n```\n\n### 1.2.3、设置属性语法\n\n#### 1.2.3.1、语法\n\n```markdown\n# prop('属性, '属性值)\n```\n\n#### 1.2.3.2、案例1\n\n```html\n<body>\n    <div></div>\n    <script>\n        // prop('属性', '属性值'): 设置元素自有的属性及属性值\n        $('div').prop('id', 'mydiv');\n    </script>\n</body>\n```\n\n#### 1.2.3.3、案例2\n\n```html\n<body>\n    <div></div>\n    <script>\n        // 通过prop('属性', '属性值') 设置自定义元素是会被忽略的。\n\n        // prop('属性', '属性值'): 设置元素自有的属性及属性值\n        $('div').prop('index', 'mydiv');\n    </script>\n</body>\n```\n\n### 1.2.4、总结\n\n​\t\tprop() 除了普通属性操作，更适合操作表单属性：disabled / checked / selected 等。\n\n## 1.3、元素自定义属性值 attr()\n\n### 1.3.1、说明\n\n​\t\t用户自己给元素添加的属性，我们称为自定义属性。 比如给 div 添加 index =“1”。\n\n### 1.3.2、获取属性语法\n\n#### 1.3.2.1、语法\n\n```markdown\n# attr('属性') \t// 类似原生 getAttribute()\n```\n\n#### 1.3.2.2、案例1\n\n```html\n<body>\n    <div index=\"1\"></div>\n    <script>\n        // attr('属性'): 获取元素自定义的属性及属性值\n        console.log($('div').attr('index'));\n    </script>\n</body>\n```\n\n#### 1.3.2.3、案例2\n\n```html\n<body>\n    <div id=\"helloworld\"></div>\n    <script>\n        // attr('属性'): 也可以获取元素自有的属性。\n        console.log($('div').attr('id'));\n    </script>\n</body>\n```\n\n#### 1.3.2.4、案例3\n\n```html\n<body>\n    <div data-index=\"10\"></div>\n    <script>\n        // 以前js讲过,对于自定义属性,最好和自有属性区分,那么区分方式就是在自定义属性前面加data前缀\n\n        // attr('属性'): 获取自定义属性\n        console.log($('div').attr('data-index'));\n    </script>\n</body>\n```\n\n### 1.3.3、设置属性语法\n\n#### 1.3.3.1、语法\n\n```markdown\n# attr('属性', '属性值') \t// 类似原生 setAttribute()\n```\n\n#### 1.3.3.2、案例1\n\n```html\n<body>\n    <div></div>\n    <script>\n        // attr('属性','属性值'): 设置元素自有的属性及属性值\n        $('div').attr('id', 'javascript');\n        \n        // attr('属性','属性值'): 设置元素自定义的属性及属性值\n        $('div').attr('data-index', \"100\");\n    </script>\n</body>\n```\n\n### 1.3.4、总结\n\n​\t\tattr() 除了普通属性操作，更适合操作自定义属性。（该方法也可以获取 H5 自定义属性【就是有data前缀定义的属性。】）\n\n## 1.4、数据缓存data()\n\n### 1.4.1、说明\n\n​\t\tdata() 方法可以在指定的元素上存取数据，并不会修改 DOM 元素结构。一旦页面刷新，之前存放的数据都将被移除。 \n\n### 1.4.2、附加数据\n\n#### 1.4.2.1、语法\n\n```markdown\n# data('name','value') \t// 向被选元素附加数据\n```\n\n#### 1.4.2.2、案例1\n\n```html\n<body>\n    <span>周芷若</span>\n    <script>\n        // data(): 这个里面的数据是存放在元素的内存里面\n        $('span').data('username', 'zhouzhou');\n    </script>\n</body>\n```\n\n![0008](/assets/jQuery笔记/0008.png)\n\n​\t\t会发现，span这个DOM元素并没有任何的变化，只是临时性的把数据存储到了这个DOM元素上。\n\n### 1.4.3、获取数据\n\n#### 1.4.3.1、语法\n\n```markdown\n# date('name') // 向被选元素获取数据\n```\n\n#### 1.4.3.2、案例1\n\n```html\n<body>\n    <span>周芷若</span>\n    <script>\n        // data('属性值','属性值'): 这个里面的数据是存放在元素的内存里面\n        $('span').data('username', 'zhouzhou');\n\n        // data('属性'): 获取属性值\n        console.log($('span').data('username'));\n    </script>\n</body>\n```\n\n![0009](/assets/jQuery笔记/0009.png)\n\n#### 1.4.3.3、案例2\n\n```html\n<body>\n    <span data-username='zhouzhiruo'>周芷若</span>\n    <script>\n        // data('属性'): 获取属性值,还可以读取 HTML5 自定义属性\n        console.log($('span').data('username'));\n    </script>\n</body>\n```\n\n## 1.5、全选案例\n\n```html\n<body>\n    全选: <input type=\"checkbox\" id=\"checkAll\"> <br/> \n    跳舞: <input class=\"j-checkbox\" type=\"checkbox\"> \n    学习: <input class=\"j-checkbox\" type=\"checkbox\"> \n    游泳: <input class=\"j-checkbox\" type=\"checkbox\" >\n    <script>\n        // 全选复选框的事件\n        $('#checkAll').click(function() {\n            // 1. 获取当前复选框的状态\n            var status = $(this).prop('checked');\n            // 2. 设置其他复选框的状态为当前复选框的状态\n            $(this).siblings('input').prop('checked', status);\n        });\n\n        // 如果小复选框被选中的个数等于3个 就应该把全选按钮选上，否则全选按钮不选。\n        $('.j-checkbox').click(function() {\n            // 如果选中的个数等于小复选框的个数\n            if ($('.j-checkbox').length == $(\".j-checkbox:checked\").length) {\n                $('#checkAll').prop('checked', true);\n            } else {\n                $('#checkAll').prop('checked', false);\n            }\n        });\n    </script>\n</body>\n```\n\n# 二、内容文本值\n\n## 2.1、概述\n\n### 2.1.1、说明\n\n​\t\t主要针对元素的**内容**还有**表单的值**操作。\n\n​\t\tjQuery的文本属性值常见操作有三种：html() / text() / val() ; 分别对应JS中的 innerHTML 、innerText 和\n\nvalue 属性。\n\n### 2.1.2、普通元素内容 html()\n\n​\t\t==**相当于原生inner HTML，html() 可识别标签**==\n\n```markdown\n1. \thtml() \t\t// 获取元素的内容\n2. \thtml('内容') // 设置元素的内容\n```\n\n```html\n<body>\n    <div id=\"content\"></div>\n    <script>\n        // 1、设置内容\n        $(\"#content\").html('<h1>HelloWorld</h1>');\n\n        // 2、获取内容\n        console.log($('#content').html());\n    </script>\n</body>\n```\n\n### 2.1.3、普通元素文本内容 text()\n\n​\t\t==**相当与原生 innerText，text() 不识别标签。**==\n\n```markdown\n1. text() \t\t\t\t// 获取元素的文本内容\n2. text('文本内容') \t // 设置元素的文本内容\n```\n\n```html\n<body>\n    <div id=\"content\"></div>\n    <script>\n        // 1、设置内容\n        $(\"#content\").text('<h1>HelloWorld</h1>');\n\n        // 2、获取内容\n        console.log($('#content').text());\n    </script>\n</body>\n```\n\n### 2.1.4、表单的值 val()\n\n​\t\t==**相当于原生value**==\n\n```markdown\n1. val() \t\t// 获取表单的值\n2. val('内容')  // 设置表单的值\n```\n\n```html\n<body>\n    用户名: <input type=\"text\" placeholder=\"请输入用户名\">\n    <script>\n        // 1、设置内容\n        $(\"input\").val('张无忌');\n\n        // 2、获取内容\n        console.log($('input').val());\n    </script>\n</body>\n```\n\n## 2.2、案例\n\n```html\n<body>\n    数量:\n    <input type=\"button\" value=\"-\" id=\"subtract\">\n    <input type=\"text\" style=\"width: 20px;\" value=\"1\" class=\"number\">\n    <input type=\"button\" value=\"+\" id=\"add\">\n    <script>\n        // 加法\n        $('#add').click(function() {\n            var value = $('.number').val();\n            value++;\n            $('.number').val(value);\n        });\n\n        // 减法\n        $('#subtract').click(function() {\n            var value = $('.number').val();\n            value--;\n            if (value >= 1) {\n                $('.number').val(value);\n            } else {\n                $(this).prop('disabled', true);\n            }\n        });\n    </script>\n</body>\n```\n\n# 三、元素操作\n\n## 3.1、说明\n\n​\t\tjQuery 元素操作主要讲的是用jQuery方法，操作标签的遍历、创建、添加、删除等操作。\n\n## 3.2、遍历元素\n\n### 3.2.1、说明\n\n​\t\tjQuery 隐式迭代是对同一类元素做了同样的操作。 如果想要给同一类元素做不同操作，就需要用到遍历。\n\n```html\n<body>\n    <div>JavaScript</div>\n    <div>HTML</div>\n    <div>CSS</div>\n    <script>\n        // 隐式迭代\n        // >> 对同一类元素做了同样的操作\n        $('div').css('color', 'red');\n    </script>\n</body>\n```\n\n### 3.2.2、语法1\n\n```markdown\n# 语法\n\t$(\"div\").each(function (index, domEle) { \n\t\t// 遍历操作 \n\t}）\n# 说明\n\t 1. each() 方法遍历匹配的每一个元素。主要用DOM处理。\n\t 2. 里面的回调函数有2个参数： index 是每个元素的索引号; domEle 是每个DOM元素对象，不是jquery对象\n\t 3. 所以要想使用jquery方法，需要给这个dom元素转换为jquery对象 $(domEle)\n```\n\n```html\n<body>\n    <div>JavaScript</div>\n    <div>HTML</div>\n    <div>CSS</div>\n    <script>\n        // 如果针对于同一类元素做不同操作，需要用到遍历元素（类似for，但是比for强大）\n        var arrs = ['red', 'blue', 'orange'];\n        $('div').each(function(index, domEle) {\n            console.log(index); // 索引号\n            $(domEle).css('color', arrs[index]);\n        });\n    </script>\n</body>\n```\n\n### 3.2.3、语法2\n\n```markdown\n# 语法\n\t$.each(object，function (index, element) { \n\t\t// 遍历操作 \n\t}）\n# 说明\n\t 1. $.each()方法可用于遍历任何对象。主要用于数据处理，比如数组，对象\n\t 2. 里面的函数有2个参数： index 是每个元素的索引号; element 遍历内容\t\n```\n\n```html\n<body>\n    <div>JavaScript</div>\n    <div>HTML</div>\n    <div>CSS</div>\n    <script>\n        // 如果针对于同一类元素做不同操作，需要用到遍历元素（类似for，但是比for强大）\n        var arrs = ['red', 'blue', 'skyblue'];\n        $.each($('div'), function(index, domEle) {\n            console.log(index); // 索引号\n            $(domEle).css('color', arrs[index]);\n        });\n    </script>\n</body>\n```\n\n```html\n<body>\n    <script>\n        // 遍历数组\n        var arrs = ['red', 'blue', 'skyblue'];\n        $.each(arrs, function(index, item) {\n            console.log(index); // 索引号\n            console.log(item); // 元素值\n        });\n    </script>\n</body>\n```\n\n```html\n<body>\n    <script>\n        // 遍历对象\n        var person = {\n            uname: 'HelloWorld',\n            age: 23\n        }\n        $.each(person, function(key, value) {\n            console.log(key); // 属性\n            console.log(value); // 属性值\n            console.log(key + \":\" + value);\n        });\n    </script>\n</body>\n```\n\n## 3.3、创建元素及添加元素\n\n### 3.3.1、创建元素\n\n```markdown\n# 语法\n\t$(''<li></li>'');\n\t动态的创建了一个 li 元素。\n```\n\n### 3.3.2、添加元素\n\n#### 3.3.2.1、内部添加\n\n```markdown\n# element.append('内容')\t\t把内容放入匹配元素内部最后面，类似原生 appendChild。\n\n# element.prepend('内容')\t\t把内容放入匹配元素内部最前面。\n```\n\n```html\n<body>\n    <ul>\n        <li>原先的li</li>\n    </ul>\n    <script>\n        // 内部的方式添加元素\n        // >> 创建li元素\n        var $li = $('<li>周芷若</li>');\n        // >> 追加到尾部\n        $('ul').append($li);\n    </script>\n</body>\n```\n\n```html\n<body>\n    <ul>\n        <li>原先的li</li>\n    </ul>\n    <script>\n        // 内部的方式添加元素\n        // >> 创建li元素\n        var $li = $('<li>周芷若</li>');\n        // >> 添加到匹配元素的最前面\n        $('ul').prepend($li);\n    </script>\n</body>\n```\n\n#### 3.3.2.2、外部添加\n\n```markdown\n# element.after('内容') \t\t// 把内容放入目标元素后面\n\n# element.before('内容') \t\t// 把内容放入目标元素前面\n```\n\n### 3.3.3、总结\n\n```markdown\n# 内部添加元素，生成之后，它们是父子关系。\n# 外部添加元素，生成之后，他们是兄弟关系。\n```\n\n```html\n<body>\n    <div class=\"demo\">张无忌</div>\n    <script>\n        // 外部的方式添加元素\n        // >> 创建div元素\n        var $div = $('<div>周芷若</div>');\n        // >> 把div放入demo目标元素后面\n        $('.demo').after($div);\n    </script>\n</body>\n\n```\n\n```html\n<body>\n    <div class=\"demo\">张无忌</div>\n    <script>\n        // 外部的方式添加元素\n        // >> 创建div元素\n        var $div = $('<div>周芷若</div>');\n        // >> 把div放入demo目标元素前面\n        $('.demo').before($div);\n    </script>\n</body>\n```\n\n## 3.4、删除元素\n\n### 3.4.1、语法\n\n```markdown\n# element.remove() \t\t// 删除匹配的元素（包括本身）\n\n# element.empty() \t\t// 删除匹配的元素集合中所有的子节点\n\n# element.html('') // 清空匹配的元素内容\n```\n\n### 3.4.2、案例1\n\n```html\n<body>\n    <ul>\n        <li>张无忌</li>\n        <li>周芷若</li>\n    </ul>\n    <script>\n        // 删除元素, remove(): 整个 ul 节点被删除了\n        $('ul').remove();\n    </script>\n</body>\n```\n\n### 3.4.3、案例2\n\n```html\n<body>\n    <ul>\n        <li>张无忌</li>\n        <li>周芷若</li>\n    </ul>\n    <script>\n        // 删除元素, empty(): ul元素下面的li子节点被删除了，ul元素还在\n        $('ul').empty();\n    </script>\n</body>\n```\n\n### 3.4.4、案例3\n\n```html\n<body>\n    <ul>\n        <li>张无忌</li>\n        <li>周芷若</li>\n    </ul>\n    <script>\n        // 删除元素, html(''): ul元素下面的li子节点被删除了，ul元素还在,和empty()方法作用一样\n        $('ul').html(\"\");\n    </script>\n</body>\n```\n\n### 3.3.5、总结\n\n```markdown\n1. remove 删除元素本身。\n2. empt() 和 html('') 作用等价，都可以删除元素里面的内容，只不过 html 还可以设置内容。\n```\n\n","tags":["学习笔记","jQuery"],"categories":["jQuery笔记"]},{"title":"jQuery笔记-01基础知识","url":"/2023/05/26/jQuery笔记-01基础知识/","content":"# 一、概述\n\n## 1.1、说明\n\n​\t\tjQuery 是一个快速、简洁的 JavaScript 库，其设计的宗旨是“write Less，Do More”，即倡导写更少的代码， 做更多的事情。\n\n​\t\tjQuery 封装了 JavaScript 常用的功能代码，优化了 DOM 操作、事件处理、动画设计和 Ajax 交互。\n\n​\t\t学习jQuery本质： 就是学习调用这些函数（方法）。\n\n​\t\tjQuery 出现的目的是加快前端人员的开发速度，我们可以非常方便的调用和使用它，从而提高开发效率。\n\n​\t\t常见的JavaScript 库：jQuery、Prototype、YUI、Dojo、Ext JS、移动端的zepto等，这些库都是对原生 \n\nJavaScript 的封装，内部都是用 JavaScript 实现的，我们主要学习的是 jQuery。\n\n​\t\t官网地址：https://jquery.com/ \n\n![0001](/assets/jQuery笔记/0001.png)\n\n## 1.2、为什么要学jQuery\n\n​\t\t使用javascript开发过程中，有许多的缺点：\n\n1. 查找元素的方法单一，麻烦。\n2. 遍历数组很麻烦，通常要嵌套一大堆的for循环。\n3. 有兼容性问题。\n4. 想要实现简单的动画效果，也很麻烦\n5. 代码冗余。\n\n## 1.3、优点\n\n- 轻量级。核心文件才几十kb，不会影响页面加载速度  \n- 跨浏览器兼容。基本兼容了现在主流的浏览器  \n- 链式编程、隐式迭代  \n- 对事件、样式、动画支持，大大简化了DOM操作 \n-  支持插件扩展开发。有着丰富的第三方的插件，例如： 树形菜单、日期控件、轮播图等 \n- 免费、开源\n\n## 1.4、jQuery的版本问题\n\n​\t1x ：兼容 IE 678 等低版本浏览器， 官网不再更新\n\n​\t2x ：不兼容 IE 678 等低版本浏览器， 官网不再更新\n\n​\t3x ：不兼容 IE 678 等低版本浏览器， 是官方主要更新维护的版本，也是更加的精简\n\n## 1.5、HelloWorld入门\n\n### 1.5.1、体验1\n\n```html\n<head>\n    <style>\n        div {\n            background-color: blue;\n            width: 200px;\n            height: 200px;\n        }\n    </style>\n    <script src=\"./js/jquery-3.6.0.min.js\"></script>\n    <script>\n        $(\"div\").hide();\n    </script>\n</head>\n\n<body>\n    <div></div>\n</body>\n```\n\n​\t\t作用是要将`div`隐藏，但是运行起来之后，发现程序并没有。原因是程序从上往下执行，还没有解析到`div`标签，就已经解析到了`$(\"div\").hide()` 。\n\n### 1.5.2、解决\n\n```html\n<head>\n    <style>\n        div {\n            background-color: blue;\n            width: 200px;\n            height: 200px;\n        }\n    </style>\n    <script src=\"./js/jquery-3.6.0.min.js\"></script>\n    <script>\n        // 更页面加载完毕之后，再去执行该代码。\n        $(document).ready(function() {\n            $(\"div\").hide();\n        });\n    </script>\n</head>\n\n<body>\n    <div></div>\n</body>\n```\n\n### 1.5.3、体验\n\n```html\n<head>\n    <script>\n        $(document).ready(function() {\n            console.log('HelloWorld,jQuery');\n        });\n    </script>\n</head>\n```\n\n# 二、jQuery基本使用\n\n## 2.1、入口函数\n\n### 2.1.1、写法一\n\n```html\n<head>\n    <script>\n        $(document).ready(function() {\n            // 此处是页面DOM加载完成的入口\n        });\n    </script>\n</head>\n```\n\n### 2.1.2、写法二\n\n```html\n<head>\n    <script src=\"./js/jquery-3.6.0.min.js\"></script>\n    <script>\n        $(function() {\n            // 此处是页面DOM加载完成的入口\n        })\n    </script>\n</head>\n```\n\n### 2.1.3、总结\n\n- 等着 DOM 结构渲染完毕即可执行内部代码，不必等到所有外部资源加载完成，jQuery 帮我们完成了封装\n- 相当于原生 js 中的 DOMContentLoaded。\n- 不同于原生 js 中的 load 事件是等页面文档、外部的 js 文件、css文件、图片加载完毕才执行内部代码。 \n- 更推荐使用第二种方式，书写简单方便。\n\n### 2.1.4、问题说明\n\n- 如果报了这个错误，$ is not defined，就说明没有正确引入jQuery文件。\n\n## 2.2、jQuery的顶级对象 $\n\n### 2.2.1、说明\n\n- \\$是 jQuery 的别称，在代码中可以使用 jQuery 代替，但一般为了方便，通常都直接使用 $ 。\n- \\$是jQuery的顶级对象，相当于原生JavaScript中的 window。把元素利用$包装成jQuery对象，就可以调用jQuery 的方法。\n\n```html\n<head>\n    <script src=\"./js/jquery-3.6.0.min.js\"></script>\n    <script>\n        //  $ 是jQuery的别称（另外的名字）\n        $(function() {\n            alert('Hello');\n        });\n\n        jQuery(function() {\n            alert('World');\n        });\n    </script>\n</head>\n```\n\n### 2.2.2、 jQuery对象和DOM对象\n\n​\t\t使用 jQuery 方法和原生JS获取的元素是不一样的，总结如下 : \n\n1. 用原生 JS 获取来的对象就是 DOM 对象\n2. jQuery 方法获取的元素就是 jQuery 对象。\n3. jQuery 对象本质是： 利用$对DOM 对象包装后产生的对象（伪数组形式存储）。\n\n>==注意：==\n>\n>​\t\t只有 jQuery 对象才能使用 jQuery 方法，DOM 对象则使用原生的 JavaScirpt 方法。\n\n![0002](/assets/jQuery笔记/0002.png)\n\n```html\n<body>\n    <div></div>\n    <script>\n        // 1. DOM 对象：  用原生js获取过来的对象就是DOM对象\n        var divObj = document.querySelector('div');\n        console.dir(divObj);\n\n        // 2. jQuery对象： 用jquery方式获取过来的对象是jQuery对象。 \n        // >> 本质： 通过$把DOM元素进行了包装\n        var $div = $('div');\n        console.dir($div); // S.fn.init(1)\n\n        // 3. jQuery 对象只能使用 jQuery 方法，DOM 对象则使用原生的 JavaScirpt 属性和方法\n        divObj.style.display = 'none';\t// DOM对象只能使用原始的对象中的属性和方法\n        $div.hide();\t// jQuery对象只能使用jQuery中的方法\n    </script>\n</body>\n```\n\n### 2.2.3、jQuery 对象和 DOM 对象转换\n\n#### 2.2.3.1、说明\n\n​\t\tDOM 对象与 jQuery 对象之间是可以相互转换的。\n\n​\t\t因为原生js 比 jQuery 更大，原生的一些属性和方法 jQuery没有给我们封装，那么意味着要想使用这些属性\n\n和方法需要把jQuery对象转换为DOM对象才能使用。\n\n#### 2.2.3.2、DOM 对象转换为 jQuery 对象\n\n```markdown\n# 语法\n\t$(DOM对象)\n# 案例\n\t$(document)\n```\n\n```html\n<head>\n    <style>\n        div {\n            background-color: red;\n            width: 100px;\n            height: 100px;\n        }\n    </style>\n</head>\n<body>\n    <div></div>\n    <script>\n        // 1. DOM 对象：用原生js获取过来的对象就是DOM对象\n        var divObj = document.querySelector('div');\n        // 2、将DOM对象转换为jQuery对象\n        var $div = $(divObj);\n        // 3、调用jQuery方法\n        $div.hide();\n    </script>\n</body>\n```\n\n#### 2.2.3.3、jQuery 对象转换为 DOM 对象\n\n```markdown\n# 语法1\n\t$(DOM对象)[index] index 是索引号\n# 案例1\n\t$(document)[0]\n# 语法2\n\t$(DOM对象).get(index) index 是索引号\n# 案例2\n\t$(document).get(0)\n```\n\n```html\n<head>\n    <style>\n        div {\n            background-color: red;\n            width: 100px;\n            height: 100px;\n        }\n    </style>\n</head>\n<body>\n    <div></div>\n    <script>\n        // 1. jQuery对象\n        var $div = $(\"div\");\n        // 2、将jQuery对象转换为DOM对象\n        var divObj = $div.get(0);\n        // 3、调用DOM对象的属性\n        divObj.style.display = 'none';\n    </script>\n</body>\n```\n\n# 三、jQuery选择器\n\n## 3.1、概述\n\n​\t\t原生 JS 获取元素方式很多，很杂，而且兼容性情况不一致，因此 jQuery 给我们做了封装，使获取元素统一标准。\n\n```markdown\n# 语法\n\t$(“选择器”) // 里面选择器直接写 CSS 选择器即可，但是要加引号\n```\n\n## 3.2、基础选择器\n\n### 3.2.1、说明\n\n![0003](/assets/jQuery笔记/0003.png)\n\n### 3.2.2、案例\n\n```html\n<body>\n    <div>HelloWorld</div>\n    <script>\n        // 1、基本选择器\n        console.log($('div'));\n    </script>\n</body>\n```\n\n## 3.3、层级选择器\n\n### 3.3.1、说明\n\n​\t\t层级选择器最常用的两个分别为：后代选择器和子代选择器。\n\n![0004](/assets/jQuery笔记/0004.png)\n\n### 3.3.2、案例\n\n```html\n<body>\n    <ul>\n        <li>张无忌</li>\n        <li>赵敏</li>\n    </ul>\n    <script>\n        // 1、层次选择器\n        console.log($('ul li'));\n    </script>\n</body>\n```\n\n## 3.4、筛选选择器(上)\n\n### 3.4.1、说明\n\n​\t\t筛选选择器，顾名思义就是在所有的选项中选择满足条件的进行筛选选择。常见如下 :\n\n![0005](/assets/jQuery笔记/0005.png)\n\n### 3.4.2、案例1\n\n```html\n<body>\n    <ul>\n        <li>多个里面筛选几个</li>\n        <li>多个里面筛选几个</li>\n        <li>多个里面筛选几个</li>\n        <li>多个里面筛选几个</li>\n        <li>多个里面筛选几个</li>\n        <li>多个里面筛选几个</li>\n    </ul>\n    <script>\n        // 1、设置第一个li字体为红色\n        $('ul li:first').css('color', 'red');\n        // 2、设置最后一个li字体为蓝色\n        $('ul li:last').css('color', 'blue');\n        // 3、设置第4个li字体为天蓝色[选取索引号为3的元素,索引号从0开始]\n        $('ul li:eq(3)').css('color', 'skyblue');\n    </script>\n</body>\n```\n\n### 3.4.3、案例2\n\n```html\n<body>\n    <ol>\n        <li>多个里面筛选几个</li>\n        <li>多个里面筛选几个</li>\n        <li>多个里面筛选几个</li>\n        <li>多个里面筛选几个</li>\n        <li>多个里面筛选几个</li>\n        <li>多个里面筛选几个</li>\n    </ol>\n    <script>\n        // 1、设置索引号为偶数的li背景颜色为红色，由于索引号从0开始,所以页面效果是奇数行会变为红色\n        $('ol li:even').css('backgroundColor', 'red');\n        // 2、设置索引号为奇数的li背景颜色为天蓝色，由于索引号从0开始,所以页面效果是偶数行会变为天蓝色\n        $('ol li:odd').css('backgroundColor', 'skyblue');\n    </script>\n</body>\n```\n\n## 3.5、筛选选择器(下)\n\n### 3.5.1、说明\n\n​\t\tjQuery中还有一些筛选方法，类似DOM中的通过一个节点找另外一个节点，父、子、兄以外有所加强。\n\n![0006](/assets/jQuery笔记/0006.png)\n\n### 3.5.2、案例1\n\n```html\n<body>\n    <div class=\"yeye\">\n        <div class=\"father\">\n            <div class=\"son\">儿子</div>\n        </div>\n    </div>\n    <script>\n        // parent() : 查找父级\n        console.log($('.son').parent());\n    </script>\n</body>\n```\n\n### 3.5.3、案例2\n\n```html\n<body>\n    <div class=\"nav\">\n        <p>HelloWorld</p>\n        <div>\n            <p>JavaScript</p>\n        </div>\n    </div>\n    <script>\n        // children() : 查找直接孩子,类似于 ul>li\n        $('.nav').children('p').css('color', 'red');\n    </script>\n</body>\n```\n\n### 3.5.4、案例3\n\n```html\n<body>\n    <div class=\"nav\">\n        <p>HelloWorld</p>\n        <div>\n            <p>JavaScript</p>\n        </div>\n    </div>\n    <script>\n        // find() : 查找后代元素,类似于 $('ul li')\n        $('.nav').find('p').css('color', 'red');\n    </script>\n</body>\n```\n\n### 3.5.5、案例4\n\n```html\n<body>\n    <ol>\n        <li>我是ol 的li</li>\n        <li>我是ol 的li</li>\n        <li class=\"item\">我是ol 的li</li>\n        <li>我是ol 的li</li>\n        <li>我是ol 的li</li>\n        <li>我是ol 的li</li>\n    </ol>\n    <script>\n        // siblings() : 查找兄弟节点,不包括自己本身\n        $('ol .item').siblings('li').css('color', 'red');\n    </script>\n</body>\n```\n\n```html\n<body>  \n    <div>HelloWorld</div>\n    <p class=\"item\">JavaScript</p>\n    <h1>Java</h1>\n    <p>CSS</p>\n    <div>HTML</div>\n\n    <script>\n        // siblings() : 查找兄弟节点,不包括自己本身\n        $('.item').siblings().css('color', 'red');\n    </script>\n</body>\n```\n\n```html\n<body>\n    <div>HelloWorld</div>\n    <p class=\"item\">JavaScript</p>\n    <h1>Java</h1>\n    <p>CSS</p>\n    <div>HTML</div>\n\n    <script>\n        // siblings() : 查找兄弟节点,不包括自己本身\n        $('.item').siblings('p').css('color', 'red');\n    </script>\n</body>\n```\n\n```markdown\n# siblings()，方法中可以设置选择器参数，如果没有，则是所有的兄弟节点,如果有指定的选择器,则筛选指定选择器的元素。\n```\n\n### 3.5.6、案例5\n\n```html\n<body>\n    <div>HelloWorld</div>\n    <p class=\"item\">JavaScript</p>\n    <h1>Java</h1>\n    <p>CSS</p>\n    <div>HTML</div>\n\n    <script>\n        // next() : 查找下一个兄弟节点\n        $('.item').next().css('color', 'red');\n    </script>\n</body>\n```\n\n### 3.5.7、案例6\n\n```html\n<body>\n    <ul>\n        <li>我是ol 的li</li>\n        <li>我是ol 的li</li>\n        <li>我是ol 的li</li>\n        <li>我是ol 的li</li>\n        <li>我是ol 的li</li>\n        <li>我是ol 的li</li>\n    </ul>\n\n    <script>\n        // eq() : 相当于$(\"ul li:eq(2)\"),index是从0开始\n        $('ul li').eq(2).css('color', 'red');\n    </script>\n</body>\n```\n\n### 3.5.8、案例7\n\n```html\n<body>\n    <div>HelloWorld</div>\n    <p class=\"item\">JavaScript</p>\n\n    <script>\n        // hasClass() :  判断是否有某个类名\n        console.log($('div').hasClass('item'));\n        console.log($('p').hasClass('item'));\n    </script>\n</body>\n```\n\n### 3.5.9、案例8\n\n```html\n<body>\n    <div>HelloWorld</div>\n    <p class=\"item\">JavaScript</p>\n    <h1>Java</h1>\n    <p>CSS</p>\n    <div>HTML</div>\n\n    <script>\n        // nextAll() :  查找当前元素之后所有的同辈元素\n        $('.item').nextAll().css('color', 'red');\n    </script>\n</body>\n```\n\n### 3.5.10、案例9\n\n```html\n<body>\n    <div>HelloWorld</div>\n    <p class=\"item\">JavaScript</p>\n    <h1>Java</h1>\n    <p>CSS</p>\n    <div>HTML</div>\n\n    <script>\n        // nextAll() :  查找当前元素之前所有的同辈元素\n        $('.item').prevAll().css('color', 'red');\n    </script>\n</body>\n```\n\n# 四、其他说明\n\n## 4.1、设置样式\n\n```html\n<body>\n    <div>JavaScript</div>\n\n    <script>\n        $('div').css('background-color', 'red');\n    </script>\n</body>\n```\n\n## 4.2、隐式迭代\n\n```html\n<body>\n    <div>JavaScript</div>\n    <div>HTML</div>\n    <div>CSS</div>\n\n    <script>\n        // 隐式迭代就是把匹配的所有元素内部进行遍历循环，给每一个元素添加css这个方法\n        $('div').css('background-color', 'red');\n    </script>\n</body>\n```\n\n​\t\t给匹配到的所有元素进行循环遍历，执行相应的方法，而不用我们再进行循环，简化我们的操作，方便我们调用。\n\n## 4.3、排他思想\n\n​\t\t想要多选一的效果，排他思想：当前元素设置样式，其余的兄弟元素清除样式。\n\n```html\n<body>\n    <button>快速</button>\n    <button>快速</button>\n    <button>快速</button>\n    <button>快速</button>\n\n    <script>\n        // 1. 隐式迭代 给所有的按钮都绑定了点击事件\n        $('button').click(function() {\n            // 2. 当前的元素变化背景颜色\n            $(this).css('backgroundColor', 'red');\n            // 3. 其余的兄弟去掉背景颜色 隐式迭代\n            $(this).siblings('button').css('backgroundColor', '');\n        });\n    </script>\n</body>\n```\n\n## 4.4、链式编程\n\n```html\n<body>\n    <button>快速</button>\n    <button>快速</button>\n    <button>快速</button>\n    <button>快速</button>\n\n    <script>\n        // 1. 隐式迭代 给所有的按钮都绑定了点击事件\n        $('button').click(function() {\n            // 2. 当前的元素变化背景颜色,并且将其余的兄弟去掉背景颜色\n            // >> 分开设置\n            // $(this).css('backgroundColor', 'red');\n            // $(this).siblings('button').css('backgroundColor', '');\n\n            // >> 链式编程\n            $(this).css('backgroundColor', 'red').siblings().css('backgroundColor', '');\n        });\n    </script>\n</body>\n```\n\n# 五、样式操作\n\n## 5.1、操作 css 方法\n\n### 5.1.1、说明\n\n​\t\tjQuery 可以使用 css 方法来修改简单元素样式； 也可以操作类，修改多个样式。\n\n```markdown\n# 语法\n\tcss();\n```\n\n### 5.1.2、参数只写属性名\n\n​\t\t参数只写属性名字，则是返回属性值。\n\n```html\n<body>\n    <div style=\"background-color: blue;\">JavaScript</div>\n\n    <script>\n        var result = $('div').css('background-color');\n        console.log(result);\n    </script>\n</body>\n```\n\n### 5.1.3、参数是属性名，属性值\n\n​\t\t参数是属性名，属性值，逗号分隔，是设置一组样式，属性必须加引号，值如果是数字可以不用跟单位和引号。\n\n```html\n<body>\n    <div>JavaScript</div>\n\n    <script>\n        $('div').css('width', '100px').css('height', 100);\n    </script>\n</body>\n```\n\n### 5.1.4、参数可以是对象形式\n\n```html\n<body>\n    <div>JavaScript</div>\n\n    <script>\n        $('div').css({\n            'width': '100px',\n            'height': '150px',\n            'background-color': 'red'\n        });\n    </script>\n</body>\n```\n\n### 5.1.5、注意\n\n```markdown\n# 注意：css() 多用于样式少时操作，多了则不太方便。\n```\n\n## 5.2、操作类样式方法\n\n### 5.2.1、添加类\n\n```html\n<head>\n    <style>\n        .current {\n            width: 100px;\n            height: 100px;\n            border: 1px solid red;\n        }\n    </style>\n</head>\n<body>\n    <div>JavaScript</div>\n\n    <script>\n        // 添加类样式,注意操作类里面的参数不要加点。\n        $('div').addClass('current');\n    </script>\n</body>\n```\n\n### 5.2.2、删除类\n\n```html\n<head>\n    <style>\n        .current {\n            width: 100px;\n            height: 100px;\n            border: 1px solid red;\n        }\n    </style>\n</head>\n<body>\n    <div class=\"current\">JavaScript</div>\n\n    <script>\n        // 移除类样式,注意操作类里面的参数不要加点。\n        $('div').removeClass('current');\n    </script>\n</body>\n```\n\n### 5.2.3、切换类\n\n```html\n<head>\n    <style>\n        .current {\n            width: 100px;\n            height: 100px;\n            border: 1px solid red;\n        }\n    </style>\n</head>\n<body>\n    <div class=\"current\">JavaScript</div>\n\n    <script>\n        // 切换类样式,注意操作类里面的参数不要加点。\n        $('div').click(function() {\n            $(this).toggleClass('current');\n        });\n    </script>\n</body>\n```\n\n### 5.2.4、注意\n\n- 设置类样式方法比较适合样式多时操作，可以弥补css()的不足。\n- 原生 JS 中 className 会覆盖元素原先里面的类名，jQuery 里面类操作只是对指定类进行操作，不影响原先的类名。这个addClass相当于追加类名 不影响以前的类名。\n\n# 六、效果操作\n\n## 6.1、概述\n\n​\t\tjQuery 给我们封装了很多动画效果，最为常见的如下：\n\n![0007](/assets/jQuery笔记/0007.png)\n\n## 6.2、**显示隐藏效果**\n\n### 6.2.1、显示效果\n\n#### 6.2.1.1、语法\n\n```markdown\n# 语法\n\tshow([speed,[easing],[fn]])\n# 说明\n\t1. 参数都可以省略,无动画直接显示。\n\t2. speed：三种预定速度之一的字符串(“slow”,“normal”,or“fast”)或表示动画时长的毫秒数值(如：1000)。 \n\t3. easing：用来指定切换效果，默认是“swing”，可用参数“linear”。\n\t4. fn: 回调函数，在动画完成时执行的函数，每个元素执行一次。\n```\n\n#### 6.2.1.2、案例\n\n```html\n<head>\n    <style>\n        div {\n            width: 150px;\n            height: 300px;\n            background-color: pink;\n            display: none;\n        }\n    </style>\n</head>\n<body>\n    <button>显示</button>\n    <div></div>\n    <script>\n        $('button').click(function() {\n            $(\"div\").show(2000);\n        });\n    </script>\n</body>\n```\n\n### 6.2.2、隐藏效果\n\n#### 6.2.2.1、语法\n\n```markdown\n# 语法\n\thide([speed,[easing],[fn]])\n# 说明\n\t1. 参数都可以省略,无动画直接显示。\n\t2. speed：三种预定速度之一的字符串(“slow”,“normal”,or“fast”)或表示动画时长的毫秒数值(如：1000)。 \n\t3. easing：用来指定切换效果，默认是“swing”，可用参数“linear”。\n\t4. fn: 回调函数，在动画完成时执行的函数，每个元素执行一次。\n```\n\n#### 6.2.2.2、案例\n\n```html\n<head>\n    <style>\n        div {\n            width: 150px;\n            height: 300px;\n            background-color: pink;\n        }\n    </style>\n</head>\n<body>\n    <button>隐藏</button>\n    <div></div>\n    <script>\n        $('button').click(function() {\n            $(\"div\").hide(2000);\n        });\n    </script>\n</body>\n```\n\n### 6.2.3、切换效果\n\n#### 6.2.3.1、语法\n\n```markdown\n# 语法\n\ttoggle([speed,[easing],[fn]])\n# 说明\n\t1. 参数都可以省略,无动画直接显示。\n\t2. speed：三种预定速度之一的字符串(“slow”,“normal”,or“fast”)或表示动画时长的毫秒数值(如：1000)。 \n\t3. easing：用来指定切换效果，默认是“swing”，可用参数“linear”。\n\t4. fn: 回调函数，在动画完成时执行的函数，每个元素执行一次。\n```\n\n#### 6.2.3.2、案例\n\n```html\n<head>\n    <style>\n        div {\n            width: 150px;\n            height: 300px;\n            background-color: pink;\n        }\n    </style>\n</head>\n<body>\n    <button>切换</button>\n    <div></div>\n    <script>\n        $('button').click(function() {\n            $(\"div\").toggle(2000);\n        });\n    </script>\n</body>\n```\n\n## 6.3、滑动效果\n\n### 6.3.1、语法\n\n```markdown\n# 上滑\n\tslideUp([speed,[easing],[fn]])\n\t\n# 下滑\n\tslideDown([speed,[easing],[fn]])\n\t\n# 滑动切换\n\tslideToggle([speed,[easing],[fn]])\n\t\n# 参数说明\n\t1. 参数都可以省略,无动画直接显示。\n\t2. speed：三种预定速度之一的字符串(“slow”,“normal”,or“fast”)或表示动画时长的毫秒数值(如：1000)。 \n\t3. easing：用来指定切换效果，默认是“swing”，可用参数“linear”。\n\t4. fn: 回调函数，在动画完成时执行的函数，每个元素执行一次。\n```\n\n### 6.3.2、案例\n\n```html\n<head>\n    <style>\n        div {\n            width: 150px;\n            height: 300px;\n            background-color: pink;\n            display: none;\n        }\n    </style>\n</head>\n<body>\n    <button>下拉滑动</button>\n    <button>上拉滑动</button>\n    <button>切换滑动</button>\n    <div></div>\n    <script>\n        // 下滑\n        $('button').eq(0).click(function() {\n            $(\"div\").slideDown(2000);\n        });\n\n        // 上滑\n        $('button').eq(1).click(function() {\n            $(\"div\").slideUp(2000);\n        });\n\n        // 切换\n        $('button').eq(2).click(function() {\n            $(\"div\").slideToggle(2000);\n        });\n    </script>\n</body>\n```\n\n## 6.4、淡入淡出\n\n### 6.4.1、语法\n\n```markdown\n# 淡入\n\tfadeIn([speed,[easing],[fn]])\n\t\n# 淡出\n\tfadeOut([speed,[easing],[fn]])\n\t\n# 淡入淡出切换\n\tfadeToggle([speed,[easing],[fn]])\n\t\n# 参数说明\n\t1. 参数都可以省略,无动画直接显示。\n\t2. speed：三种预定速度之一的字符串(“slow”,“normal”,or“fast”)或表示动画时长的毫秒数值(如：1000)。 \n\t3. easing：用来指定切换效果，默认是“swing”，可用参数“linear”。\n\t4. fn: 回调函数，在动画完成时执行的函数，每个元素执行一次。\n```\n\n### 6.4.2、案例\n\n```html\n<head>\n    <style>\n        div {\n            width: 150px;\n            height: 300px;\n            background-color: pink;\n            display: none;\n        }\n    </style>\n</head>\n<body>\n    <button>淡入</button>\n    <button>淡出</button>\n    <button>淡入淡出切换</button>\n    <div></div>\n    <script>\n        // 淡入\n        $('button').eq(0).click(function() {\n            $(\"div\").fadeIn(2000);\n        });\n\n        // 淡出\n        $('button').eq(1).click(function() {\n            $(\"div\").fadeOut(2000);\n        });\n\n        // 淡入淡出切换\n        $('button').eq(2).click(function() {\n            $(\"div\").fadeToggle(2000);\n        });\n    </script>\n</body>\n```\n\n## 6.5、渐进方式调整到指定的不透明度\n\n### 6.5.1、说明\n\n```markdown\n# 语法\n\tfadeTo([[speed],opacity,[easing],[fn]])\n# 参数说明\n\t1. opacity 【透明度必须写】，取值 0~1 之间。\n\t2. speed：三种预定速度之一的字符串(“slow”,“normal”,or“fast”)或表示动画时长的毫秒数值(如：1000)。【必须写】\n\t3. easing：(Optional) 用来指定切换效果，默认是“swing”，可用参数“linear”。\n\t4. fn: 回调函数，在动画完成时执行的函数，每个元素执行一次。\n```\n\n### 6.5.2、案例\n\n```html\n<head>\n    <style>\n        div {\n            width: 150px;\n            height: 300px;\n            background-color: pink;\n        }\n    </style>\n</head>\n<body>\n    <button>渐进方式调整到指定的不透明度</button>\n    <div></div>\n    <script>\n        $('button').click(function() {\n            $(\"div\").fadeTo(2000, 0.6);\n        });\n    </script>\n</body>\n```\n\n## 6.6、自定义动画 animate\n\n### 6.6.1、说明\n\n```markdown\n# 语法\n\tanimate(params,[speed],[easing],[fn])\n# 参数说明\n\t1. params: 想要更改的样式属性，以对象形式传递，必须写。 属性名可以不用带引号。\n\t2. speed：三种预定速度之一的字符串(“slow”,“normal”,or“fast”)或表示动画时长的毫秒数值(如：1000)。 \n\t3. easing： 用来指定切换效果，默认是“swing”，可用参数“linear”。\n\t4. fn: 回调函数，在动画完成时执行的函数，每个元素执行一次\n```\n\n### 6.6.2、案例\n\n```html\n<head>\n    <style>\n        div {\n            position: absolute;\n            width: 150px;\n            height: 300px;\n            background-color: pink;\n        }\n    </style>\n</head>\n<body>\n    <button>动起来</button>\n    <div></div>\n    <script>\n        $('button').click(function() {\n            $(\"div\").animate({\n                width: '300px',\n                heigth: '600px',\n                opacity: 0.6,\n                top: '100px',\n                left: '300px'\n            }, 3000);\n        });\n    </script>\n</body>\n```\n\n## 6.7、事件切换\n\n### 6.7.1、案例1\n\n```html\n<head>\n    <style>\n        div {\n            width: 150px;\n            height: 300px;\n            background-color: pink;\n        }\n    </style>\n</head>\n<body>\n    <div></div>\n    <script>\n        // 鼠标悬浮上去的事件\n        $('div').mouseover(function() {\n            $(this).fadeIn(3000);\n        });\n        // 鼠标离开的事件\n        $('div').mouseout(function() {\n            $(this).fadeOut(3000);\n        });\n    </script>\n</body>\n```\n\n### 6.7.2、事件切换\n\n```markdown\n# 语法\n\thover([over,]out)\n\thover 就是鼠标经过和离开的复合写法\n# 参数说明\n\t1. over:鼠标移到元素上要触发的函数\n\t2. out:鼠标移出元素要触发的函数\n\t3. 如果只写一个函数，则鼠标经过和离开都会触发它\n```\n\n```html\n<head>\n    <style>\n        div {\n            width: 150px;\n            height: 300px;\n            background-color: pink;\n        }\n    </style>\n</head>\n<body>\n    <div></div>\n    <script>\n        // 事件切换\n        $('div').hover(function() {\n            $(this).fadeIn(3000);\n        }, function() {\n            $(this).fadeOut(3000);\n        });\n    </script>\n</body>\n```\n\n```html\n<head>\n    <style>\n        div {\n            width: 150px;\n            height: 300px;\n            background-color: pink;\n        }\n    </style>\n</head>\n<body>\n    <div></div>\n    <script>\n        // 事件切换\n        // >> hover  如果只写一个函数，那么鼠标经过和鼠标离开都会触发这个函数\n        $('div').hover(function() {\n            $(this).fadeToggle(3000);\n        });\n    </script>\n</body>\n```\n\n## 6.8、动画队列及其停止排队方法\n\n### 6.8.1、说明\n\n​\t\t动画或者效果一旦触发就会执行，如果多次触发，就造成多个动画或者效果排队执行。此时就需要停止排队。\n\n```markdown\n# 语法\n\tstop()\n# 说明\n\t1. stop() 方法用于停止动画或效果。\n\t2. stop() 写到动画或者效果的前面， 相当于停止结束上一次的动画。\n```\n\n### 6.8.2、案例\n\n```html\n<body>\n    <div></div>\n    <script>\n        // 事件切换\n        $('div').hover(function() {\n             // stop 方法必须写到动画的前面\n            $(this).stop().fadeToggle(3000);\n        });\n    </script>\n</body>\n```\n\n","tags":["学习笔记","jQuery"],"categories":["jQuery笔记"]},{"title":"JavaScript笔记-12ES6","url":"/2023/05/26/JavaScript笔记-12ES6/","content":"\n# 一、ES6概述\n\n## 1.1、ES6是什么\n\n​\tES6，是ECMAScript 6的简称，它是 JavaScript 语言的下一代标准，已经在2015年的6月正式发布。\n\n​\t它的目标是使 JavaScript语言可以用于编写复杂的大型应用程序，成为企业级开发语言。\n\n## 1.2、ES6为什么要学习\n\n​\t现在使用主流的前端框架中，如ReactJS、Vue.js、Angularjs等，都会使用到ES6的新特性，ES6也就成为了必修课，所以在学习这些前端框架之前，是非常有必要去学习ES6的内容。\n\n## 1.3、什么是ECMAScript？\n\n​\t**web1.0时代：**\n\n​\t最初的网页以HTML为主，是纯静态的网页。网页是只读的，信息流只能从服务的到客户端单向流通。开发人员也只关心页面的样式和内容即可。\n\n​\t**web2.0时代：**\n\n- 1995年，网景工程师Brendan Eich 花了10天时间设计了JavaScript语言。\n- 1996年，微软发布了JScript，其实是JavaScript的逆向工程实现。\n- 1997年，为了统一各种不同script脚本语言，ECMA（欧洲计算机制造商协会）以JavaScript为基础，制定了\n\nECMAscript 标准规范。JavaScript和JScript都是 ECMAScript 的标准实现者，随后各大浏览器厂商纷纷实现了\n\nECMAScript 标准。\n\n​\t所以，ECMAScript是浏览器脚本语言的规范，而各种我们熟知的js语言，如JavaScript则是规范的具体实现。\n\n## 1.4、ECMAScript的快速发展\n\n​\t而后，ECMAScript就进入了快速发展期。\n\n- 1998年6月，ECMAScript 2.0 发布。\n\n- 1999年12月，ECMAScript 3.0 发布。这时，ECMAScript 规范本身也相对比较完善和稳定了，但是接下来的事情，就比较悲剧了。2007年10月，ECMAScript 4.0 草案发布。这次的新规范，历时颇久，规范的新内容也有了很多争议。在制定ES4的时候，是分成了两个工作组同时工作的。\n\n  一边是以 Adobe, Mozilla, Opera 和 Google为主的 ECMAScript 4 工作组。\n\n  一边是以 Microsoft 和 Yahoo 为主的 ECMAScript 3.1 工作组。\n\n  ECMAScript 4 的很多主张比较激进，改动较大。而 ECMAScript 3.1 则主张小幅更新。最终经过 TC39 的会议，决定将一部分不那么激进的改动保留发布为 ECMAScript 3.1，而ES4的内容，则延续到了后来的ECMAScript5和6版本中\n\n\n- 2009年12月，ECMAScript 5 发布。\n\n- 2011年6月，ECMAScript 5.1 发布。\n\n- 2015年6月，ECMAScript 6，也就是 ECMAScript 2015 发布了。 并且从 ECMAScript 6 开始，开始采用年号来做版本。即 ECMAScript 2015，就是ECMAScript6。\n\n- 2016年 6月，小幅修订的《ECMAScript 2016标准》 (简称 ES2016)如期发布， 这个版本可以看作是 ES6.1版，因为两者的差异非常小(只新增了数组实例的 includes 方法 和指数运算符)，基本上可以认为是同 一个标准 。\n\n- 2017 年 6 月发布了ES2017 标准。\n\n  因此， ES6 既是一个历史名词，也是一个泛指，含义是 5.1 版本以后的 JavaScript 的下一代 标准，涵盖了 ES2015、ES2016、 ES2017 等，而 ES2015 则是正式名称，特指当年发布的正式版本的标准语言。\n\n## 1.5、ECMAScript和JavaScript的关系\n\n- ==ECMA 是一个组织，由这个组织定义了一套标准，JavaScript 是实现。就等同于，JDBC是一套标准，MySQL驱动、Oracle驱动是具体的实现。由于ECMA的标准目前来说，也就只有JavaScript去实现了，所以可以通俗的理解为，ECMAScript就是JavaScript。==\n- ECMAScript 简称 ECMA 或 ES\n\n# 二、变量/常量\n\n## 2.1、var定义变量\n\n​\t之前，我们写js定义变量的时候，只有一个关键字：`var`。但是通过`var`定义的变量会有一个问题：就是通过该关键字定义的变量有时候会莫名的变成==**全局变量**== , 也就是说`var`定义的变量没有==块级别的作用域==，因为`var`的作用域是函数 。\n\n### 2.1.1、案例1\n\n- 源码`test001.html`\n\n  ```javascript\n  <script type=\"text/javascript\">\n      if(\"Hello\" == \"Hello\"){\n          var x = 12;\n      }\n      alert(x);\n  </script>\n  ```\n\n- 运行结果\n\n  ```tex\n  12\n  ```\n\n  可以看到在一对花括号`{}`定义一个变量，在外部依然可以访问到。\n\n### 2.1.2、案例2\n\n- 源码 `test001.html`\n\n  ```javascript\n  <script type=\"text/javascript\">\n      for (var i = 1; i <= 6 ; i++) {\n          console.info(i);\n      }\n      console.info(\"跳出循环后，i的值 = \" + i);\n  </script>\n  ```\n\n\n- 运行结果\n\n  ```java\n  1\n  2\n  3\n  4\n  5\n  6\n  跳出循环后，i的值 = 7\n  ```\n\n- 结果分析\n\n  ​\t**可以看出，在循环外部也可以获取到变量i的值，显然变量i的作用域范围太大了，在做复杂页面时，会带来很大的问题。**\n\n## 2.2、let定义变量\n\n​\t`let` 所声明的变量，只在 let 命令所在的代码块内有效。\n\n### 2.2.1、案例1\n\n- 源码 `test001.html`\n\n   ```javascript\n     <script type=\"text/javascript\">\n      for (let i = 1; i <= 6 ; i++) {\n          console.info(i);\n      }\n      console.info(\"跳出循环后，i的值 = \" + i);\n     </script>\n   ```\n\n- 运行结果\n\n  ```javascript\n  1\n  2\n  3\n  4\n  5\n  6\n  Uncaught ReferenceError: i is not defined\n  ```\n\n- 结果分析\n\n  ​\t**这样，就把变量的i的作用域控制在了循环内部。**\n\n## 2.3、const定义常量\n\n​\t在之前ES5中，是没有办法定义常量的，但是到了ES6中，有了对常量的定义，即使用`const`关键字。\n\n### 2.3.1、案例1\n\n- 源码 `test001.html`\n\n  ```javascript\n  <script type=\"text/javascript\">\n\n      // 定义字符串x\n      const x = \"HelloWorld\";\n      console.info(x);\n\n      // 再对x重新赋值\n      x = 23;\n      console.info(x);\n\n  </script>\n  ```\n\n- 运行结果\n\n  ```javascript\n  HelloWorld\n  Uncaught TypeError: Assignment to constant variable. // 不能对常量重新赋值\n  ```\n\n- 分析\n\n  ​\t**可以看到，变量x的值是不能修改的。和Java语言中的final关键字类似。**\n\n# 三、字符串扩展\n\n## 3.1、新的API扩展\n\n### 3.1.1、新增方法\n\n- includes() ：返回布尔值，表示是否找到了参数字符串。\n- startsWith() ：返回布尔值，表示参数字符串是否在原字符串的头部。\n- endsWith() ：返回布尔值，表示参数字符串是否在原字符串的尾部。\n- repeat()：返回一个字符串，根据给定的数值对字符串重复指定的次数。\n\n### 3.1.2、案例\n\n```javascript\n<script type=\"text/javascript\">\n\n    let str = \"HelloWorld\";\n\n    let b1 = str.includes(\"Hello\");\n    console.info(\"HelloWorld是否包含Hello字符串: \" + b1);\t\t// true\n\n    let b2 = str.startsWith(\"Hello\");\n    console.info(\"HelloWorld是否以Hello字符串开头: \" + b2);\t   // true\n\n    let b3 = str.endsWith(\"World\");\n    console.info(\"HelloWorld是否以World字符串结尾: \" + b3);\t   // true\n\n\tlet value = \"Hello\".repeat(3);\n  \tconsole.info(value);\t\t\t\t\t\t\t\t\t//  HelloHelloHello\n\n</script>\n```\n\n## 3.2、字符串模板\n\n### 3.2.1、之前写法\n\n​\t在之前如果要定义很长的字符串，是这样的：\n\n```java\n<script type=\"text/javascript\">\n    let str = \"Hello\" +\n        \"World\" +\n        \"Spring\";\n</script>\n// 虽然开发工具可以自动的帮助我们实现使用“+”号进行拼接，但是看起来总是那么的不舒服。\n```\n\n### 3.2.2、模板语法\n\n​\t解决这个问题，可以使用ES6提供的字符串模板来去实现，语法：使用【`】作为字符串的模板语法。\n\n### 3.2.3、案例1：随意折行\n\n```javascript\n<script type=\"text/javascript\">\n    let str = `Hello\n        World\n        Spring\n    `;\n\n    console.info(str);\n</script>\n/**\n\t在两个`之间的部分都会被作为字符串的值，可以任意换行\n*/\n```\n\n### 3.2.4、案例2：字符串拼接\n\n```javascript\n<script type=\"text/javascript\">\n\n    // 过滤掉不能被3整除的数\n    let name = 'HelloWorld';\n    let age = 23;\n    let address = \"河南安阳\";\n\n    let str = `姓名是:${name}年龄是:${age}家庭住址是:${address}`\n\n    console.info(str);\n\n</script>\n```\n\n### 3.2.5、案例3、调用函数\n\n```javascript\n<script type=\"text/javascript\">\n\n    let fn = function () {\n        return \"HelloWorld\";\n    }\n\n    let content = `你好, ${fn()}`;\n\n    console.info(content);\n\n</script>\n```\n\n# 四、解构表达式\n\n## 4.1、说明\n\n​\tES6中允许按照一定模式从数组和对象中提取值，然后对变量进行赋值，这被称为解构。\n\n## 4.2、数组解构\n\n​\t数组解构允许我们按照一一对应的关系从数组中提取值，并且将值一一赋值给对应的变量。\n\n## 4.2.1、之前写法\n\n```javascript\n<script type=\"text/javascript\">\n\n    let arrs = [1,2,3];\n\n\tlet x = arrs[0];\n\tlet y = arrs[1];\n\tlet z = arrs[2];\n\n    console.info(x);\n\tconsole.info(y);\n\tconsole.info(z);\n\n</script>\n/*\n\t之前写法中，如果要获取数组中每个元素的值分别赋值给变量，只能通过下标的方式.\n*/\n```\n\n### 4.2.2、案例1\n\n```javascript\n<script type=\"text/javascript\">\n\n    let arrs = [1,2,3];\n\n    let [x,y,z] = arrs;\t// x，y，z将与arrs中的每个位置对应来取值。\n\n    console.info(x,y,z);\n\n</script>\n// let [x,y,z] = arrs 注意：等号左边的[]不是数组，表示的解构，表示的从等号右边的数组中提取值。\n```\n\n### 4.2.3、案例2\n\n```javascript\n<script type=\"text/javascript\">\n\n   let [ [num1,num2,num3] , num , value ] = [ [1,2,3] , 34 , 'HelloWorld' ];\n\n   console.info(num1,num2,num3,num,value);\n</script>\n```\n\n## 4.3、对象解构\n\n​\t对象解构允许我们使用变量的名字匹配对象的属性，匹配成功，则会将对象属性的值赋值给变量。\n\n### 4.3.1、之前写法\n\n```javascript\n<script type=\"text/javascript\">\n\n   let person = {\n       name: \"Hello\",\n       age: 12,\n       address: [\"河南\",\"山东\"]\n   };\n\n   console.info(person.name);\n   console.info(person.age);\n   console.info(person.address);\n\n</script>\n/*\n\t之前写法中，如果要获取对象中的属性，需要通过【对象名.属性】的方式实现\t\n*/\n```\n\n### 4.3.2、案例1\n\n```javascript\n<script type=\"text/javascript\">\n\n   let person = {\n       name: \"Hello\",\n       age: 12,\n       address: [\"河南\",\"山东\"]\n   };\n\n   let {name,age,address} = person;\t// {}中的name、age和address需要和person中的属性一致\n\n   console.info(name);\n   console.info(age);\n   console.info(address);\n\n</script>\n```\n\n### 4.3.3、案例2\n\n```javascript\n<script type=\"text/javascript\">\n\n   let person = {\n       name: \"Hello\",\n       age: 12,\n       address: [\"河南\",\"山东\"]\n   };\n\n   // 当然也可以不一致,如果想要用其它变量接收，需要额外指定别名，需要用【：】指定\n   // name是person中的属性名，冒号后面的myName是解构后要赋值给的变量。\n   let {name:myName,age:myAge,address} = person;\t\n\n   console.info(myName);\n   console.info(myAge);\n   console.info(address);\n\n</script>\n```\n\n# 五、函数优化\n\n## 5.1、参数展开/rest参数/剩余参数/可变参数\n\n​\t剩余参数是将剩下的参数收集起来放在一个数组中。\n\n### 5.1.1、案例1：rest参数\n\n```javascript\n<script type=\"text/javascript\">\n\n    // 函数展开/可变参数\n    function info(num1,num2,...args){\n        alert(num1);\n        alert(num2);\n        alert(args);\t\t// 30,40,50。args是一个数组，以数组的方式接收函数中剩余的参数\n    }\n\n    info(10,20,30,40,50);\n\n</script>\n```\n\n==**作用：收集函数参数中剩余的参数，必须作为最后一个参数位置。**==\n\n### 5.1.2、案例2：展开数组\n\n```javascript\n<script type=\"text/javascript\">\n\n    let arr1 = [1,2,3];\n    let arr2 = [4,5,6];\n\n    let arr3 = [...arr1 , ...arr2];\n    alert(arr3);\n\n</script>\n```\n\n## 5.2、函数参数默认值\n\n### 5.2.1、之前如何实现\n\n​\t在ES6之前是不提供函数默认参数值的实现，只能通过变通写法。\n\n```javascript\n<script type=\"text/javascript\">\n\n    // 假设num2的默认值是2\n    function add(num1, num2){\n        if (!num2){\n            num2 = 2;\n        }\n        return num1 + num2;\n    }\n\n    console.info(add(10)); // 12\n    console.info(add(10 , 8)); // 18\n\n</script>\n```\n\n### 5.2.2、案例\n\n```javascript\n<script type=\"text/javascript\">\n\n    // 假设num2的默认值是2\n    function add(num1, num2 = 2){\t// 直接在参数上直接赋值即可\n        return num1 + num2;\n    }\n\n    console.info(add(20)); // 22\n    console.info(add(20 , 8)); // 28\n\n</script>\n```\n\n## 5.3、箭头函数\n\n### 5.3.1、之前定义函数\n\n```javascript\n<script type=\"text/javascript\">\n\n    // 使用function关键字定义函数.\n    function show(username){\t\n        console.info(\"Hello:\" + username);\n    }\n\n    show(\"张三\");\n\n</script>\n```\n\n### 5.3.2、案例1：单个参数\n\n```javascript\n<script type=\"text/javascript\">\n\n    let show = username => console.info(\"Hello:\" + username);\n\n    show(\"李四\");\n\n</script>\n/**\n\t语法：\n\t\tlet 函数名 = 参数名 => 函数体\n*/\n```\n\n### 5.3.3、案例2：多个参数\n\n```javascript\n<script type=\"text/javascript\">\n\n    let add = (num1,num2) => console.info(num1 + num2);\n\n    add(10,20);\n\n</script>\n/*\n\t多个参数需要使用【()】小括号给括起来.\n*/\n```\n\n### 5.3.4、案例3：没有参数\n\n```javascript\n<script type=\"text/javascript\">\n\n   let info = () => console.info(\"打印信息\");\n\n   info();\n\n</script>\n/*\n\t即使函数没有参数，也需要使用【()】小括号来去表示，来去代表参数部分\n*/\n```\n\n### 5.3.5、案例4：函数体有多条语句\n\n```javascript\n<script type=\"text/javascript\">\n\n    let length = (str) => {\n        if(str){\n            return str.length;\n        }\n        return 0;\n    }\n\n    console.info(length(\"123\"));\n\n</script>\n/*\n\t函数体有多条语句时候，需要使用【{}】花括号包裹起来\n*/\n```\n\n### 5.3.6、案例5：关于函数体的其他说明\n\n如果函数中有单个表达式或语句：那么==**1、函数体外部的`{}`是可以省略的；2、使用return可以省略。**==\n\n#### 5.3.6.1、细节1：如果是单个表达式，则自带return\n\n```javascript\n<script type=\"text/javascript\">\n\n    // 求两个数的和\n    let sum = (num1 , num2) => {\n        return num1 + num2;\n    }\n\n    alert(sum(10,30));\n\n</script>\n```\n\n```javascript\n<script type=\"text/javascript\">\n\n    // 求两个数的和\n    let sum = (num1 , num2) => num1 + num2;\t\t// 自带return\n\n    alert(sum(10,30));\n\n</script>\n```\n\n#### 5.3.6.2、细节2：如果是单条语句，花括号可以省略\n\n```javascript\n<script type=\"text/javascript\">\n\n    // 求两个数的和\n    let sum = (num1 , num2) => {\n        alert(num1 + num2);\n    }\n\n    sum(10,25);\n\n</script>\n```\n\n```javascript\n<script type=\"text/javascript\">\n\n    // 求两个数的和\n    let sum = (num1 , num2) => alert(num1 + num2);\n\n    sum(10,25);\n\n</script>\n```\n\n### 5.3.7、箭头函数中的this\n\n​\t在普通函数中的`this`指向的是：谁调用了这个函数，那么这个函数中的`this`就是谁。\n\n​\t**箭头函数不绑定this，换句话说，箭头函数是没有自己的this，如果在箭头函数中使用this，那么this指向的是箭头函数所在定义位置中的this，也就是说箭头函数定义在哪里，箭头函数中的this就指向谁。通俗一点说，箭头函数里的this指的是定义这个箭头函数时外层代码的this。**\n\n#### 5.3.7.1、案例1\n\n- ES5代码\n\n  ```javascript\n  <script type=\"text/javascript\">\n\n      function Person(){\n          this.username = \"HelloWorld\";\n          this.run = function(){\n              console.info(this.username + \"在跑步\");\n          }\n      }\n\n      var p1 = new Person();\n  \t// HelloWorld在跑步，原因是run方法是p1对象调用者，那么run方法中的this指向的就是p1这个实例对象，而p1的实例对象中有username属性是HelloWorld.\n      p1.run();\t\t\t\t\n\n      var p2 = p1.run;\n  \t// undefined在跑步 , 原因是run方法是window对象直接调用的，那么run方法中的this指向的就是window,而window是没有username属性的，所以是undefined。\n      p2();\n\n  </script>\n  ```\n\n- ES6代码\n\n  ```javascript\n  <script type=\"text/javascript\">\n\n      function Person(){\n          this.username = \"HelloWorld\";\n          this.run = () => {\n              console.info(this.username + \"在跑步\");\n          }\n      }\n\n      var p1 = new Person();\n  \t// HelloWorld在跑步\n      p1.run();\n\n      var p2 = p1.run;\n  \t// HelloWorld在跑步，可以看到，更改了run方法的调用，但是依然没有影响到run方法中的this的指向\n      p2();\n\n  </script>\n  ```\n\n  ```javascript\n  <script type=\"text/javascript\">\n\n      function Person(){\n          this.username = \"HelloWorld\";\n          this.run = () => {\n              console.info(this.username + \"在跑步\");\n          }\n      }\n\n  \t// 先调用一下\n      Person();\n\n      var p2 = run;\n  \t// HelloWorld在跑步\n      p2();\n\n  </script>\n  ```\n\n  ==可以发现：箭头函数中的this的指向就是：箭头函数定义在哪里，那么箭头函数中的this指向就是哪里，箭头函数中的this就是外层代码this的引用。本例：箭头函数中的this就是Person函数中的this。==\n\n#### 5.3.7.2、案例2\n\n- ES5代码\n\n  ```javascript\n  <script type=\"text/javascript\">\n\n      var person = {username: \"HelloWorld\"};\n\n      function fn1(){\n          return function(){\n              console.info(this.username);\n          }\n      }\n\n      var fn = fn1.call(person);\n      fn();\t// undefined\n  </script>\n  ```\n\n- ES6代码\n\n  ```javascript\n  <script type=\"text/javascript\">\n\n      var person = {username: \"HelloWorld\"};\n\n      function fn1(){\n          return ()=> {\n              console.info(this.username);\n          }\n      }\n\n      var fn = fn1.call(person);\n      fn();\t// HelloWorld\n  </script>\n  ```\n\n#### 5.3.7.3、案例3\n\n- ES5代码\n\n  ```javascript\n  <script type=\"text/javascript\">\n\n     var obj = {\n         age: 20,\n         run: function(){\n             console.info(this.age);\n         }\n     };\n\n     obj.run(); // 20\n  </script>\n  ```\n\n- ES6代码\n\n  ```javascript\n  <script type=\"text/javascript\">\n\n     var obj = {\n         age: 20,\n         run: ()=>{\n             console.info(this.age);\n         }\n     };\n\n     obj.run();  // undefined\n  </script>\n  ```\n\n  ==使用对象字面量的时候，**不要在其定义的方法里使用箭头函数**，这属于**箭头函数的禁忌**==\n\n## 5.4、对象的函数属性简写\n\n### 5.4.1、之前写法\n\n```javascript\n<script type=\"text/javascript\">\n\n    let person = {\n        username : \"张三\",\n        run: function(address){\t // 属性：function函数\n            console.info(this.username + \"在\" + address + \"跑步\");\n        }\n    };\n\n    person.run(\"操场\");\n\n</script>\n```\n\n### 5.4.2、箭头函数写法\n\n```javascript\n<script type=\"text/javascript\">\n\n    let person = {\n        username : \"张三\",\n        run: (address) => {\n          console.info(person.username + \"在\" + address + \"跑步\")// 注意这里不能用this.username\n        }\n    };\n\n    person.run(\"操场\");\n\n</script>\n```\n\n### 5.4.3、对象的函数属性写法\n\n```javascript\n<script type=\"text/javascript\">\n\n    let person = {\n        username : \"张三\",\n        run(address){\t\t\t\t// 在对象中直接定义函数。\n            console.info(this.username + \"在\" + address + \"跑步\");\n        }\n    };\n\n    person.run(\"操场\");\n\n</script>\n```\n\n### 5.4.4、对象的其他简单写法\n\n- 以前写法\n\n  ```javascript\n  <script type=\"text/javascript\">\n\n      let name = \"HelloWorld\";\n      let age = 23;\n\n      let person = {name:name , age:age};\n\n      console.info(person.name + \",\" + person.age);\n\n  </script>\n  ```\n\n- ES6新写法\n\n  ​\t键值对出现了重复，ES6 中，如果属性名和和所分配的变量名一样，就可以从对象属性中删掉这些重复的变量名称。\n\n  ```javascript\n  <script type=\"text/javascript\">\n\n      let name = \"HelloWorld\";\n      let age = 23;\n\n      let person = {name, age};\n\n      console.info(person.name + \",\" + person.age);\n  </script>\n  ```\n\n## 5.5、箭头函数结合解构表达式\n\n### 5.5.1、之前写法\n\n```javascript\n<script type=\"text/javascript\">\n\n    let person = {\n        username: \"张三\",\n        age: 12\n    }\n\n\t// 打印对象\n    function info(obj){\n        console.info(\"姓名是：\" + obj.username);\n    }\n\n    info(person);\n\n</script>\n```\n\n### 5.5.2、改进1:使用箭头函数\n\n```javascript\n<script type=\"text/javascript\">\n\n    let person = {\n        username: \"李四\",\n        age: 12\n    }\n\n    let info = (obj) => console.info(\"姓名是：\" + obj.username);\n\n    info(person);\n\n</script>\n```\n\n### 5.5.3、改进2:使用箭头函数+解构表达式\n\n```javascript\n<script type=\"text/javascript\">\n\n    let person = {\n        username: \"王五\",\n        age: 12\n    }\n\n    let info = ({username:name}) => console.info(\"姓名是：\" + name);\n\n    info(person);\n\n</script>\n```\n\n## 5.6、map和reduce\n\n### 5.6.1、map：映射\n\n#### 5.6.1.1、说明\n\n​\t`map()`：该函数的参数接收一个函数fn，将原数组中的所有元素用这个fn函数处理后放入新数组返回。\n\n#### 5.6.1.2、案例1\n\n​\t==**给定一个数组，将数组中的每个元素求平方然后组成一个新的数组**==\n\n```javascript\n<script type=\"text/javascript\">\n    let arrs = [1,2,3,4,5,6];\n\n    let arrsNew = arrs.map(item => {\n        return item * item;\n    });\n    console.info(arrsNew);\n</script>\n```\n\n```javascript\n<script type=\"text/javascript\">\n\n    let arrs = [1,2,3,4,5,6];\n\n    let arrsNew = arrs.map(item => item * item); // 使用箭头函数改造一下\n    console.info(arrsNew);\n\n</script>\n```\n\n### 5.6.2、reduce：合并/汇总\n\n#### 5.6.2.1、说明\n\n​\t`reduce() `：该函数的参数接收一个函数fn（必须）和一个初始值value（可选），fn函数接收两个参数：\n\n- 第一个参数是上一次reduce处理的结果\n- 第二个参数是数组中要处理的下一个元素\n\n  `reduce()` 会从左到右依次把数组中的元素用reduce处理，并把处理的结果作为下次reduce的第一个参数。如果是第一次，会把前两个元素作为计算参数，或者把用户指定的初始值作为起始参数。\n\n#### 5.6.2.2、案例1：没有初始值\n\n​\t==**给定一个数组，求数组中所有元素的和**==\n\n```javascript\n<script type=\"text/javascript\">\n\n    let arrs = [1,2,3,4,5,6];\n\n    let result = arrs.reduce((a,b) => {\n        return a + b;\n    });\n\n    console.info(result);\t// 21\n</script>\n```\n\n#### 5.6.2.3、案例2：有初始值\n\n​\t==**给定一个数组，求数组中所有元素的和，指定一个初始值10**==\n\n```javascript\n<script type=\"text/javascript\">\n\n    let arrs = [1,2,3,4,5,6];\n\n    let result = arrs.reduce((a,b) => {\n        return a + b;\n    },10);\n\n    console.info(result);\n</script>\n```\n\n## 5.7、filter：过滤\n\n### 5.7.1、说明\n\n​\t用于把数组中的某些元素过滤掉，返回剩下的符合条件的元素。实现方式是：filter函数的参数接收一个函数，然后把传入的函数作用于每一个元素，然后根据返回值是true和false决定保留还是丢掉该元素。\n\n### 5.7.2、案例\n\n​\t给定一个数组，过滤掉不能被3整除的数，然后返回新数组。\n\n```javascript\n<script type=\"text/javascript\">\n\n    // 过滤掉不能被3整除的数\n    let arrs = [12,34,56,41,24];\n\n    let result = arrs.filter(function(item){\n        return item % 3 == 0;\n    });\n\n    console.info(result);\n\n</script>\n```\n\n```javascript\n<script type=\"text/javascript\">\n\n    // 过滤掉不能被3整除的数\n    let arrs = [12,34,56,41,24];\n\n    let result = arrs.filter(item => item % 3 == 0);\t// 使用箭头函数实现\n\n    console.info(result);\n\n</script>\n```\n\n## 5.8、forEach：迭代\n\n### 5.8.1、说明\n\n​\t用来遍历数组\n\n### 5.8.2、案例\n\n```javascript\n<script type=\"text/javascript\">\n\n    // 循环遍历\n    let arrs = [12,34,56,41,24];\n\n    arrs.forEach(function(item,index){\n        alert(index + \", \" + item);\n    })\n\n</script>\n```\n\n```javascript\n<script type=\"text/javascript\">\n\n    // 循环遍历\n    let arrs = [12,34,56,41,24];\n\n    arrs.forEach((item,index) => {alert(index + \":\" + item)});\n\n</script>\n```\n\n# 六、扩展运算符\n\n## 6.1、说明\n\n​\t扩展运算符(spread)是三个点(...)， 作用是将一个==数组==转为用==逗号==分隔的参数序列。\n\n## 6.2、案例\n\n- 直接打印数组\n\n  ```javascript\n  <script type=\"text/javascript\">\n\n      console.info([1,2,3]);  // [1,2,3],就是数组对象\n\n  </script>\n  ```\n\n- 扩展运算符使用\n\n  ```javascript\n  <script type=\"text/javascript\">\n\n      console.info(...[1,2,3]); \t// 1,2,3 将数组用逗号一个一个的分隔成序列\n\n  </script>\n  ```\n\n- 与函数结合使用\n\n  ```javascript\n  <script type=\"text/javascript\">\n\n      function add(num1,num2){\n          return num1 + num2;\n      }\n\n      let result = add(...[10,20]);\n\n      console.info(result);\t// 30\n\n  </script>\n  ```\n\n- 数组合并\n\n  ```javascript\n  <script type=\"text/javascript\">\n\n      // 定义两个数组\n      let arr1 = [1,2,3,4];\n      let arr2 = [9,8,7,6];\n\n      // 数组合并\n      let arr3 = [...arr1 , ...arr2];\n\n      console.info(arr3);\n\n  </script>\n  ```\n\n- 结合数组的push方法\n\n  ```javascript\n  <script type=\"text/javascript\">\n\n      let arrs1 = [1,2,3];\n      let arrs2 = [4,5,6];\n\n      // 将arrs2中的元素追加到arrs1中\n      arrs1.push(...arrs2);\n      console.info(arrs1);\n\n  </script>\n  ```\n\n- 与解构表达式结合使用\n\n  ```javascript\n  <script type=\"text/javascript\">\n\n      // 定义数组\n      let arr1 = [1,2,3,4];\n\n      // 解构表达式\n      let [first,...other] = [1,2,3,4];\n\n      console.info(first);\t// 1\n      console.info(other);\t// [2,3,4]\n\n  </script>\n  ```\n\n- 将字符串转换为数组\n\n  ```javascript\n  <script type=\"text/javascript\">\n\n      // 定义字符串\n      let str = \"Hello\";\n\n      let arr = [...str];\n\n      console.info(arr);  // [\"H\", \"e\", \"l\", \"l\", \"o\"]\n\n  </script>\n  ```\n\n# 七、Promise异步计算\n\n## 7.1、先看简单案例\n\n​\t在JavaScript的世界中，所有代码都是单线程执行的。由于这个“缺陷”，导致JavaScript的所有网络操作，浏览器事件，都必须是异步执行。异步执行可以用回调函数/钩子函数实现。\n\n```javascript\n<script type=\"text/javascript\">\n\n    function callback() {\n        console.log('完成');\n    }\n\n    console.log('before setTimeout()');\n    setTimeout(callback, 1000); // 1秒钟后调用callback函数,setTimeout函数就是一个异步操作。\n    console.log('after setTimeout()');\n    \n</script>\n// 程序执行结果:\nbefore setTimeout()\nafter setTimeout()\n完成\n// 分析:\n可见，异步操作会在将来的某个时间点触发一个函数调用。其实AJAX就是典型的异步操作。\n```\n\n## 7.2、以ajax案例引入Promise\n\n```javascript\n<script type=\"text/javascript\">\n\n    request.onreadystatechange = function () {\n        if (request.readyState === 4) {\n            if (request.status === 200) {\n                return success(request.responseText);\n            } else {\n                return fail(request.status);\n            }\n        }\n    }\n\n</script>\n/**\n\t以上是一段伪代码，是我们以前经常写的代码，当成功就执行success函数，执行失败就执行fail函数。\n把回调函数success和fail写到一个AJAX操作里很正常，但是不好看，写起来非常麻烦。\n\t下面代码是对以上代码的改进：\n*/\n```\n\n```javascript\n<script type=\"text/javascript\">\n\n    var ajax = ajaxGet('http://...');\n    ajax.ifSuccess(success)\n        .ifFail(fail);\n\n</script>\n/*\n\t这种链式写法的好处在于，先统一执行AJAX逻辑，不关心如何处理结果，然后，根据结果是成功还是失败，在将来的某个时候调用success函数或fail函数。\n*/\n```\n\n​\t古人云：“君子一诺千金”，==**这种“承诺将来会执行”的对象在JavaScript中称为Promise对象。**==\n\n## 7.3、Promise\n\n​\t所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。\n\n​\t我们可以通过Promise的构造函数来创建Promise对象，并在内部封装一个异步执行的结果。\n\n- ==**语法**==\n\n  ```javascript\n  <script type=\"text/javascript\">\n\n      const promise = new Promise(function(resolve, reject) {\n          // 执行异步操作\n        \t$.ajax({\n  \t\t\turl: '',\n              success(value){\n  \t\t\t\tresolve(value); // 调用resolve，代表Promise将返回成功的结果\n              },\n              eror(){\n  \t\t\t\treject(error);// 调用reject，代表Promise会返回失败结果\n              }\n          });\n      });\n  </script>\n  ```\n\n- then\n\n  ​\t如果我们想要等待异步执行完成，做一些事情，我们可以通过promise的then方法来实现，其实换句话说，then函数中接收的`function(value)`就是`resolve`。语法：\n\n  ```javascript\n  <script type=\"text/javascript\">\n      promise.then(function(value){ \n          // 异步执行成功后的回调 \n      })\n  </script>\n  ```\n\n- catch\n\n  ​\t如果想要处理promise异步执行失败的事件，还可以跟上catch：\n\n  ```javascript\n  <script type=\"text/javascript\">\n      promise.then(function(value){ \n          // 异步执行成功后的回调 \n      }).catch(function(error){ \n          // 异步执行失败后的回调 \n      })\n  </script>\n  ```\n\n## 7.4、案例1\n\n​\t异步计算，根据得到的随机数是否大于0.5，如果大于0.5则表示执行成功，否则表示执行失败。\n\n```javascript\n<script type=\"text/javascript\">\n\n    let p = new Promise(function (resolve, reject) {\n        // 在Promise构造方法的内部编写异步代码,使用setTimeout()函数模拟\n        setTimeout(function(){\n            let v = Math.random();\n            if (v > 0.5){\n                resolve(\"执行成功\" + v);\n            }else {\n                reject(\"执行失败\" + v);\n            }\n        },2000);\n    });\n\n    console.info(\"begin\");\n\n    p.then(function(msg){\n        console.info(msg);\n    }).catch(function(msg){\n        console.info(msg);\n    });\n\n    console.info(\"end\");\n\n</script>\n// 结果分析\nbegin\nend\n执行成功0.7648843061927828\n```\n\n## 7.5、案例2\n\n​\t`7.4`这个案例好像看起来和传统的ajax也差不多，甚至要比传统的更麻烦了一点，下面这个案例在以上案例的基础之上再来看一个问题。\n\n​\t需求：模拟两次异步操作，首先第一次：根据得到的随机数是否大于0.5，如果大于0.5则表示执行成功，如果成功之后，==再发送一个异步操作，根据得到的随机数是否大于0.8，如果大于0.8则表示执行成功，否则失败==；否则表示执行失败。\n\n​\t代码可能会这么写：\n\n```javascript\n<script type=\"text/javascript\">\n\n    let p1 = new Promise(function (resolve, reject) {\n        setTimeout(function(){\n            let v = Math.random();\n            if (v > 0.5){\n                resolve(\"执行成功\" + v);\n            }else {\n                reject(\"执行失败\" + v);\n            }\n        },2000);\n    });\n\n    let p2 = new Promise(function (resolve, reject) {\n        setTimeout(function(){\n            let v = Math.random();\n            if (v > 0.8){\n                resolve(\"执行成功\" + v);\n            }else {\n                reject(\"执行失败\" + v);\n            }\n        },3000);\n    });\n\n    p1.then(function(msg){\n            console.info(msg);\n\n            // 这个是核心，注意：在p1的then里面再去调用p2的then\n            p2.then(function(msg){\n                // ....\n            }).catch(function(msg){\n                // ....\n            })\n\n        })\n        .catch(function(msg){\n            console.info(msg);\n        });\n\n</script>\n```\n\n​\t如果真要这么写就体现不出来`Promise`异步的优势了，那还不如干脆不用呢？正是因为这样，`Promise`提供了一个`all`方法来供我们使用。代码如下：\n\n```javascript\n<script type=\"text/javascript\">\n\n    let p1 = new Promise(function (resolve, reject) {\n        setTimeout(function(){\n            let v = Math.random();\n            if (v > 0.5){\n                resolve(\"执行成功\" + v);\n            }else {\n                reject(\"执行失败\" + v);\n            }\n        },2000);\n    });\n\n    let p2 = new Promise(function (resolve, reject) {\n        setTimeout(function(){\n            let v = Math.random();\n            if (v > 0.8){\n                resolve(\"执行成功\" + v);\n            }else {\n                reject(\"执行失败\" + v);\n            }\n        },3000);\n    });\n\n\t// all方法接收一个数组,当p1和p2都执行成功后，才会执行then，只要有一个失败，就执行catch.\n    Promise.all([p1,p2]).then(function(msg){\n        console.info(\"全部成功了\");\n        console.info(msg);\n    }).catch(function(msg){\n        console.info(\"至少一个失败了\");\n        console.info(msg);\n    })\n</script>\n```\n\n## 7.6、案例2改进\n\n​\t大家会发现，案例2中，创建的两个`Promise`对象`p1`和`p2`内部代码都是一样的，唯一的区别就是里面的判断条件不一样，那我们可以这样改进，将`Promise`构造函数中的代码抽取出来，封装成一个方法，不同的数据作为函数的参数传递进来，代码如下：\n\n```javascript\n<script type=\"text/javascript\">\n\n    function createPromise(number){\n        return new Promise(function (resolve, reject) {\n            setTimeout(function(){\n                let v = Math.random();\n                if (v > number){\n                    resolve(\"执行成功\" + v);\n                }else {\n                    reject(\"执行失败\" + v);\n                }\n            },2000);\n        });\n    }\n\n    Promise.all([\n        createPromise(0.5),\n        createPromise(0.8)\n    ]).then(function(msg){\n        console.info(\"全部成功了\");\n        console.info(msg);\n    }).catch(function(msg){\n        console.info(\"至少一个失败了\");\n        console.info(msg);\n    })\n\n</script>\n```\n\n# 八、Set和Map\n\n## 8.1、Set\n\n### 8.1.1、说明\n\n​\tSet，本质与数组类似。不同在于Set中只能保存不同元素，即Set中都是不重复的元素。==**类似于Java中的Set集合。**==\n\n### 8.1.2、案例\n\n- 构造Set\n\n  ```javascript\n  <script type=\"text/javascript\">\n\n      let set = new Set()\n      set.add(\"HelloWorld\");\t// 向Set集合中添加元素\n      set.add(123);\n\n      set.forEach((item) => {\n          console.info(item);\n      });\n\n  </script>\n  ```\n\n- 接收一个数组\n\n  ```javascript\n  <script type=\"text/javascript\">\n\n      let arrs = [1,2,3,4,4,5]; // 定义一个数组，有重复元素\n      let set = new Set(arrs);\n\n      set.forEach((item) => {\n          console.info(item);\t\t// 结果是：1,2,3,4,5\n      });\n  </script>\n  ```\n\n- Set的其他方法\n\n  ```javascript\n  <script type=\"text/javascript\">\n\n      let arrs = [1,2,3,4,4,5]; // 定义一个数组，有重复元素\n      let set = new Set(arrs);\n\n      set.clear();// 清空\n      set.delete(2);// 删除指定元素\n      set.has(2);   // 判断指定元素是否存在\n      set.size;     // 计算集合的元素个数,注意：不是方法，而是属性。\n\n      set.forEach((item) => {\n          console.info(item);\n      });\n  </script>\n  ```\n\n## 8.2、Map\n\n### 8.2.1、说明\n\n​\tmap，本质是与Object类似的结构。不同在于，Object强制规定key只能是字符串，而Map结构的key可以是任意对象。即：\n\n- object是 `<string,object>`集合\n- map是是`<Object,Object>集合`\n\n### 8.2.2、案例\n\n- 构造方法\n\n  ```javascript\n  <script type=\"text/javascript\">\n\n      let map = new Map();\n      map.set(\"S001\", \"HelloWorld\");\n      map.set(\"S002\", \"Spring\");\n\n      console.info(map);\t// {\"S001\" => \"HelloWorld\", \"S002\" => \"Spring\"}\n  </script>\n  ```\n\n- map接收一个数组，数组中的元素是键值对数组\n\n  ```javascript\n  <script type=\"text/javascript\">\n\n      let arrs1 = ['S001','HelloWorld'];\n      let arrs2 = ['S002','Spring'];\n\n      let map = new Map([arrs1 , arrs2]);\n\n      console.info(map);\t//  {\"S001\" => \"HelloWorld\", \"S002\" => \"Spring\"}\n  </script>\n  ```\n\n- 接收一个Set\n\n  ```javascript\n  <script type=\"text/javascript\">\n\n      // 定义两个数组\n      let arrs1 = ['S001','HelloWorld'];\n      let arrs2 = ['S002','SpringMVC'];\n\n      // 定义Set,该Set接收一个数组，而这个数组中又包含了两个数组。\n      let set = new Set([arrs1,arrs2]);\n\n      // 构造Map传入一个Set\n      let map = new Map(set);\n\n      console.info(map);\n  </script>\n  ```\n\n- 接收一个Map\n\n  ```javascript\n  <script type=\"text/javascript\">\n\n      // 定义一个Map\n      let map1 = new Map();\n      map1.set(\"S001\" , \"彭依凝\");\n\n      // 构造map时传入一个Map\n      let map2 = new Map(map1);\n      map2.set(\"S002\" , \"段康家\");\n\n      console.info(map2);\n  </script>\n  ```\n\n- 其他方法\n\n  ```javascript\n  <script type=\"text/javascript\">\n\n      // 定义一个Map\n      let map = new Map();\n      map.set(\"S001\" , \"彭依凝\");\n      map.set(\"S002\" , \"王浩\");\n\n      map.clear();         // 清空\n      map.delete(key); // 根据指定的key删除指定元素\n      map.has(key);       // 根据指定的key判断是否存在\n      map.size; // 元素个数。是属性，不是方法\n  </script>\n  ```\n\n\n- 遍历Map\n\n  ​\t==forEach()方法==\n\n  ```javascript\n  <script type=\"text/javascript\">\n\n      // 定义一个Map\n      let map = new Map();\n      map.set(\"S001\" , \"彭依凝\");\n      map.set(\"S002\" , \"王浩\");\n\n      map.forEach(((value, key) => {\n          console.info(key + \"=\" +value);\n      }))\n  </script>\n  ```\n\n- 遍历Map\n\n  ​\t==keys()方法，该方法返回的是迭代器==\n\n  ```javascript\n  <script type=\"text/javascript\">\n\n      // 定义一个Map\n      let map = new Map();\n      map.set(\"S001\" , \"彭依凝\");\n      map.set(\"S002\" , \"王浩\");\n\n      // keys()方法返回所有key的迭代器\n      let iters = map.keys();\n\n      for (let key of iters){\n          let value = map.get(key);\n          console.info(key + \",\" + value);\n      }\n  </script>\n  ```\n\n- 遍历\n\n  ​\t==values()方法，获取所有value的迭代器==\n\n  ```javascript\n  <script type=\"text/javascript\">\n\n      // 定义一个Map\n      let map = new Map();\n      map.set(\"S001\" , \"彭依凝\");\n      map.set(\"S002\" , \"王浩\");\n\n      // values()方法返回所有value的迭代器\n      let iters = map.values();\n\n      for (let value of iters){\n          console.info(value);\n      }\n  </script>\n  ```\n\n- 遍历\n\n  ​\t==entries()方法==\n\n  ```javascript\n  <script type=\"text/javascript\">\n\n      // 定义一个Map\n      let map = new Map();\n      map.set(\"S001\" , \"彭依凝\");\n      map.set(\"S002\" , \"王浩\");\n\n      // entries()方法返回所有entries的迭代器\n      let iters = map.entries();\n\n  \t// 使用解构表达式\n      for (let [key,value] of iters){\n          console.info(key + \"=\" + value);\n      }\n  </script>\n  ```\n\n# 九、class类\n\n## 9.1、说明\n\n​\t在ES6之前，是通过自定义构造函数来去模拟类并创建对象，在ES6中，通过class关键字就可以定义类。\n\n## 9.2、定义类\n\n### 9.2.1、类中定义方法\n\n```javascript\n<script type=\"text/javascript\">\n\n    // 定义类\n    class Person{\n        info(){\n            console.info(\"这个是Person类\");\n        }\n    }\n\n\t// 创建实例对象\n    let p1 = new Person();\n    p1.info();\n\n</script>\n```\n\n### 9.2.2、构造方法\n\n```javascript\n<script type=\"text/javascript\">\n\n    // 定义类\n    class Person{\n        // 构造方法，并初始化属性\n        constructor(username,age){\n            this.username = username; // 添加属性并赋值\n            this.age = age;\n        }\n        info(){\n            console.info(this.username + \"年龄是\" + this.age);\n        }\n    }\n\n\t// 实例化对象\n    let p1 = new Person(\"HelloWorld\",12);\n    p1.info();\n\n</script>\n```\n\n### 9.2.3、静态方法\n\n```javascript\n<script type=\"text/javascript\">\n\n    // 定义类\n    class Person{\n        static info(){\n            console.info(\"这个是静态方法\");\n        }\n    }\n\n    Person.info();\t// 静态方法通过类名直接调用\n</script>\n```\n\n### 9.2.4、总结\n\n- 创建的每一个class类，都会有一个constructor()方法，该方法是一种用于创建和初始化class的属性。\n- 如果一个类没有指定constructor() 方法，则会添加默认的constructor()方法；\n- ==一个类只允许有一个constructor()方法==\n\n## 9.3、继承\n\n### 9.3.1、说明\n\n​\t==通过extends实现继承==\n\n### 9.3.2、案例\n\n- 案例1\n\n  ```javascript\n  <script type=\"text/javascript\">\n\n      // 定义父类\n      class Animal{\n          constructor(username,age){\n              this.username = username;\n              this.age = age;\n          }\n          info(){\n              console.info(\"Animal..info,姓名\" + this.username + \",\" + this.age);\n          }\n      }\n      // 定义子类\n      class Dog extends Animal{\n          \n      }\n\n      let dog = new Dog(\"旺财\",10);\n      dog.info();\n\n  </script>\n  ```\n\n- 案例2：super调用父类构造方法\n\n  ```javascript\n  <script type=\"text/javascript\">\n\n      // 定义父类\n      class Animal{\n          constructor(username,age){\n              this.username = username;\n              this.age = age;\n          }\n          info(){\n              console.info(\"Animal..info,姓名\" + this.username + \",\" + this.age);\n          }\n      }\n      // 定义子类\n      class Dog extends Animal{\n          constructor(username,age,address){\n              super(username, age);\n              this.address = address;\n          }\n          info(){\n              super.info();\n              console.info(\"家庭住址是:\" + this.address);\n          }\n      }\n\n      let dog = new Dog(\"旺财\",10,\"河南省\");\n      dog.info();\n\n  </script>\n  ```\n\n### 9.3.3、super调用父类的普通方法\n\n```javascript\n<script type=\"text/javascript\">\n    class Animal{\n        constructor(name,age){\n            this.name = name;\n            this.age = age;\n        }\n        info(){\n            console.info(\"Animal..info,姓名\" + this.name + \",\" + this.age);\n        }\n    }\n\n    class Dog extends Animal{\n        constructor(name,age,address){\n            super(name,age);\t\t\t\t// super必须在子类构造方法的第一句\n            this.address = address;\n        }\n        info() {\n            super.info();\t// super调用父类的普通的方法\n            console.info(\"子类的地址是：\" + this.address)\n        }\n    }\n\n    let dog1 = new Dog(\"土狗\",12,\"浙江绍兴\");\n    dog1.info();\n\n</script>\n```\n\n### 9.3.4、方法重写\n\n```javascript\n<script type=\"text/javascript\">\n\n    class Animal{\n        info(){\n            console.info(\"这个是父类的info方法\");\n        }\n    }\n\n    class Dog extends Animal{\n        info() {\n            console.info(\"这个是子类的info方法\")\n        }\n    }\n\n    let dog1 = new Dog();\n    dog1.info();\n</script>\n```\n\n## 9.4、this详解\n\n### 9.4.1、先看案例\n\n```javascript\n<body>\n    <button id=\"btn\">打印信息</button>\n    <script type=\"text/javascript\">\n\n        class Person{\n            constructor(username){\n                this.username = username;\n                // 获取按钮\n                this.btn = document.getElementById(\"btn\");\n                // 给此按钮绑定点击事件为info。\n                this.btn.onclick = this.info;\n            }\n            info(){\n                console.info(\"名字是:\" + this.username);\n            }\n        }\n\n        new Person(\"HelloWorld\");\n    </script>\n</body>\n```\n\n​\t测试：页面运行之后，打开页面上会有一个`button`按钮，然后点击`button`按钮，会触发单击事件，而事件处理程序是`info`方法，程序打印结果是：**名字是:undefined** ，并不是：**名字是:HelloWorld** 。\n\n​\t说明`this`中根本就没有`username` ， 换句话说，`this`指向了谁，就需要考虑一下了。\n\n### 9.4.2、this指向问题探讨\n\n#### 9.4.2.1、构造方法中的this\n\n```javascript\n<script type=\"text/javascript\">\n\n    let this_;\n    class Person{\n        constructor(username){\n        \t// 将构造函数中的this赋值给一个全局变量\n            this_ = this; \n            this.username = username;\n        }\n        info(){\n            console.info(\"名字是:\" + this.username);\n        }\n    }\n\n    let p1 = new Person(\"HelloWorld\");\n\n\t// true\n    console.info(p1 == this_); \n\n</script>\n```\n\n​\t==**打印的结果是true，说明构造函数中的this就是指的当前new出来的实例对象，即p1。**==\n\n#### 9.4.2.2、普通函数中的this\n\n```javascript\n<script type=\"text/javascript\">\n    let this_;\n    class Person{\n        constructor(username){\n            this.username = username;\n        }\n        run(){\n            this_ = this;\n            console.info(this);\n        }\n    }\n\n    let p1 = new Person(\"HelloWorld\");\n    p1.run();\n    console.info(p1 == this_); // true\n</script>\n```\n\n​\t==**打印的结果是true，说明run方法中的this就是实例对象p1，这是因为run方法本身就是由p1对象调用的，所以run方法的this指的就是谁调用了我，那么this就指向谁。**==\n\n#### 9.4.2.3、特殊案例\n\n```javascript\n<body>\n    <button id=\"btn\">打印信息</button>\n    <script type=\"text/javascript\">\n        class Person{\n            constructor(username){\n                this.username = username;\n                // 获取按钮\n                this.btn = document.getElementById(\"btn\");\n                // 给此按钮绑定点击事件为info。\n                this.btn.onclick = this.info;\n            }\n            info(){\n                console.info(this); \t\t\t\t\t// <button id=\"btn\">打印信息</button>\n                console.info(\"名字是:\" + this.username); // undefined\n            }\n        }\n\n        let p1 = new Person(\"HelloWorld\");\n    </script>\n</body>\n```\n\n​\t**程序运行完毕之后，单击按钮，分别查看info方法里面的this和this.username的值，会发现this指向的是button，这个因为info方法本身是通过button按钮点击执行的，所以函数中的this指的就是谁调用了我，那我就是谁，所以当前this指的就是button。正是因为this指向是button，而button中是不存在username属性的，所以打印的结果是undefined。**\n\n​\t**此时，我现在就想单击按钮的时候，打印HelloWorld，也就是说info中的this不是指向的是button按钮，而是实例对象p1，那么此时可以借助箭头函数实现。**\n\n```javascript\n<body>\n    <button id=\"btn\">打印信息</button>\n    <script type=\"text/javascript\">\n\n        class Person{\n            constructor(username){\n                this.username = username;\n                // 获取按钮\n                this.btn = document.getElementById(\"btn\");\n                // 给此按钮绑定点击事件为info。\n                this.btn.onclick = ()=> {\n                    console.info(\"名字是:\" + this.username); // HelloWorld\n                };\n            }\n        }\n\n        let p1 = new Person(\"HelloWorld\");\n    </script>\n</body>\n```\n\n# 十、Generator函数\n\n## 10.1、说明\n\n​\tGenerator 函数是 ES6 提供的 一种异步编程解决方案，==语法行为与传统函数完全不同 。==\n\n​\tGenerator函数有两个特征: 一是 function关键字与函数名 之间有一个星号；二是 函数体内部使用 yield语句定义不同的内部状态。\n\n​\t作用：Generator是一个迭代器生成函数，其返回值是一个迭代器（Iterator），可用于异步调用。\n\n## 10.2、使用案例\n\n```javascript\n<script type=\"text/javascript\">\n\n    function* tell(){\n        yield \"A\";\n        yield \"B\";\n        yield \"C\";\n        return;\n    }\n\n    let gen = tell();\n    console.info(gen.next());   // {value: \"A\", done: false}\n    console.info(gen.next());   // {value: \"B\", done: false}\n    console.info(gen.next());   // {value: \"C\", done: false}\n    console.info(gen.next());   // {value: undefined, done: true}\n</script>\n/*\n\t可以看到，通过tell()返回的gen对象，该对象是一个迭代器，每调用一次next()方法返回一个对象，该对象包含了value值和done状态。直到遇到return关键字或者函数执行完毕，这个时候返回的状态为ture，表示已经执行结束了。\n*/\n```\n\n## 10.3、遍历\n\n​\t==通过for...of 循环可以去遍历Generator函数返回的迭代器==\n\n```javascript\n<script type=\"text/javascript\">\n\n    function* tell(){\n        yield \"A\";\n        yield \"B\";\n        yield \"C\";\n        return;\n    }\n\n    let gen = tell();\n\n    for (let obj of gen){\n        console.info(obj);\n    }\n</script>\n```\n\n# 十一、修饰器\n\n## 11.1、说明\n\n​\t修饰器(Decorator)是一个函数， 用来修改类的行为。 ES2017 引入了这项功能， 目前 Babel 转码器己经支持。\n\n​\t==**修饰器类似于Java语言中的注解。**==\n\n## 11.2、案例\n\n```javascript\n<script type=\"text/javascript\">\n\n    // 定义一个普通方法，target对象是修饰的目标对象，这里是Person类\n    function D(target){\n       target.age = 12; // 为Person类添加一个静态属性age\n    }\n\n    @D  // 通过@符号进行引用该方法，类似java中的注解\n    class Person{\n        constructor(username) {\n            this.username = username;\n        }\n    }\n\n    console.info(Person.age);\n\n</script>\n/**\n\t运行之后会报错。\n\t原因是，在ES6中，并没有支持该用法，在ES2017中才有，所以我们不能直接运行了，需要进行编码后再运行。\n转码的意思是：将ES6或ES2017转为ES5执行。类似这样：\n\t转码前 \n\t\tinput .map(item =>item + 1);\n\t转码后 \n\t\tinput.map(function (item) { \n\t\t\t\t\treturn item + 1; \n\t\t})\n\t\n\t转码的意思：简单来说，就是将高版本的代码翻译成相同功能的低版本的代码，目的是为了达到兼容。\n*/\n```\n\n# 十二、转码器\n\n## 12.1、说明\n\n- Babel (babeljs.io)是一个广为使用的 ES6 转码器，可以将 ES6 代码转为 ES5 代码，从而 在浏览器或其他环境执行。\n\n- Google 公司的 Traceur 转码器 Cgithub.com/google/traceur-compiler)， 也可以将 ES6 代码转为ES5的代\n\n  码。\n\n- 这2款都是非常优秀的转码工具，但是我们并不使用，==使用阿里巴巴开源的企业级react框架：UmiJS。==\n\n## 12.2、介绍\n\n​\t[官网](https://umijs.org/zh/)\n\n​\tUmiJS读音：乌米。\n\n​\t特点：\n\n- 插件化\n\n  ​\tumi 的整个生命周期都是插件化的，甚至其内部实现就是由大量插件组成，比如 pwa、按需加载、一键切换 preact、一键兼容 ie9 等等，都是由插件实现。\n\n- 开箱即用\n\n  ​\t你只需一个 umi 依赖就可启动开发，无需安装 react、preact、webpack、react-router、babel、jest 等等。\n\n- 约定式路由\n\n  ​\t类 next.js 的约定式路由，无需再维护一份冗余的路由配置，支持权限、动态路由、嵌套路由等等。\n\n## 12.3、部署安装\n\n### 12.3.1、首先需要安装Node.js \n\n- 安装node-v8.12.0-x64.msi，一路下一步安装 \n\n- 安装完成后，打开cmd命令窗口，通过node -v 命令查看其版本号 \n\n  ```tex\n  C:\\Users\\Administrator>node -v\n  v8.11.1\n  ```\n\n### 12.3.2、接下来开始安装yarn\n\n- 说明：本案例使用tyarn，使用的是npm.taobao.org的源，速度要快一些，可以把yarn看做了优化了的npm。\n\n- npm i yarn tyarn -g #-g 是指全局安装 \n\n  ```tex\n  C:\\Users\\Administrator>npm i yarn tyarn -g\n\n  D:\\development\\nodejs\\node_global\\tyarn -> D:\\development\\nodejs\\node_global\\node_modules\\tyarn\\index.\n  D:\\development\\nodejs\\node_global\\yarnpkg -> D:\\development\\nodejs\\node_global\\node_modules\\yarn\\bin\\y\n  D:\\development\\nodejs\\node_global\\yarn -> D:\\development\\nodejs\\node_global\\node_modules\\yarn\\bin\\yarn\n  + tyarn@0.1.1\n  + yarn@1.22.4\n  ```\n\n- tyarn -v #进行测试，如果能够正常输出版本信息则说明安装成功了 \n\n  ```tex\n  C:\\Users\\Administrator>tyarn -v\n\n  'tyarn' 不是内部或外部命令，也不是可运行的程序\n  或批处理文件。\n  ```\n\n- 注意：如果测试失败，提示'tyarn'不是内部或外部命令，是由于没有将yarn添加到环境变量中导致。\n\n  通过以上的安装，知道，我的`tyarn`是安装在了`D:\\development\\nodejs\\node_global\\tyarn`。所以我就把这个路径添加到环境变量里面去。\n\n  ![001](/assets/JavaScript笔记/0129.png)\n\n  ```tex\n  C:\\Users\\Administrator>tyarn -v\n\n  1.22.4\n  ```\n\n### 12.3.3、下面开始安装umi \n\ntyarn global add umi \n\numi #进行测试\n\n## 12.4、入门案例：解决修饰器问题\n\n# 十三、模块化\n\n## 13.1、说明\n\n​\t模块化就是把代码进行拆分，方便重复利用。类似java中的导包：要使用一个包，必须先导包。而JS中没有包的概念，换来的是模块。模块就是一个js文件。\n\n​\t模块功能主要由两个命令构成：export和import。\n\n- export：命令用于规定模块的对外接口，\n- import：命令用于导入其他模块提供的功能，import去导入模块只会导入一次。\n\n## 13.2、导出变量/常量\n\n### 13.2.1、方式1\n\n- 步骤一：定义Utils.js文件定义要导出的变量/常量\n\n  ```javascript\n  export let num1 = 12;\n  export let value = \"Hello\";\n  export const num3 = 78;\n  ```\n\n- 步骤二：新建test.html文件导入\n\n  ```javascript\n  <script type=\"module\">\n\n      import {num1,value,num3} from \"./Utils.js\"\n\n      console.info(num1);\n      console.info(value);\n      console.info(num3);\n\n  </script>\n  ```\n\n### 13.2.2、方式2\n\n- 定义Utils.js文件定义要导出的变量/常量\n\n  ```javascript\n  let num1 = 12;\n  let value = \"Hello\";\n  const num3 = 78;\n\n  export {\n      num1,value,num3\n  }\n  ```\n\n- 新建test.html文件导入\n\n  ```javascript\n  <script type=\"module\">\n\n      import {num1,value,num3} from \"./Utils.js\"\n\n      console.info(num1);\n      console.info(value);\n      console.info(num3);\n\n  </script>\n  ```\n\n### 13.2.3、方式3：export导出时定义别名\n\n- 定义Utils.js文件定义要导出的变量/常量\n\n  ```javascript\n  let num1 = 12;\n  let value = \"Hello\";\n  const num3 = 78;\n\n  export {\n      num1 as a,\n      value as b,\n      num3 as c\n  }\n  ```\n\n- 新建test.html文件导入\n\n  ```javascript\n  <script type=\"module\">\n\n      import {a,b,c} from \"./Utils.js\"\n\n      console.info(a);\n      console.info(b);\n      console.info(c);\n\n  </script>\n  ```\n\n### 13.2.4、方式4：import导入时也可以起别名\n\n- 定义Utils.js文件定义要导出的变量/常量\n\n  ```javascript\n  let num1 = 12;\n  let value = \"Hello\";\n  const num3 = 780;\n\n  export {\n      num1,\n      value,\n      num3\n  }\n  ```\n\n- 新建test.html文件导入\n\n  ```javascript\n  <script type=\"module\">\n\n      import {num1 as aa,value as bb,num3 as cc} from \"./Utils.js\"\n\n      console.info(aa);\n      console.info(bb);\n      console.info(cc);\n\n  </script>\n  ```\n\n### 13.2.5、方式5：支持星号方式\n\n- 定义Utils.js文件定义要导出的变量/常量\n\n  ```javascript\n  let num1 = 12;\n  let value = \"Hello\";\n  const num3 = 780;\n\n  export {\n      num1,\n      value,\n      num3\n  }\n  ```\n\n- 新建test.html文件导入\n\n  ```javascript\n  <script type=\"module\">\n\n      import * as obj from \"./Utils.js\"\n\n      console.info(obj.num1);\n      console.info(obj.value);\n      console.info(obj.num3);\n\n  </script>\n  ```\n\n## 13.3、导出类\n\n- 定义Utils.js文件定义要导出的类\n\n  ```javascript\n  class Person {\n      constructor(username,age){\n          this.username = username;\n          this.age = age;\n      }\n\n      info(){\n          console.info(this.username + \",\" + this.age);\n      }\n  }\n\n  export {\n      Person\n  }\n  ```\n\n- 新建test.html文件导入\n\n  ```html\n  <script type=\"module\">\n\n      import {Person} from \"./Utils.js\"\n\n      let p1 = new Person(\"HelloWorld\",12);\n      p1.info();\n\n  </script>\n  ```\n\n## 13.4、导出函数\n\n- 定义Utils.js文件定义要导出的函数\n\n  ```javascript\n  const fn = ()=>{\n      console.info(\"这个是函数\")\n  }\n\n  export{\n  \tfn\n  }\n  ```\n\n\n\n- 新建test.html文件导入\n\n  ```html\n    <script type=\"module\">\n\n       import {fn} from \"./Utils.js\"\n\n       fn();\n\n    </script>\n  ```\n\n## 13.5、default的用法\n\n​\t使用`import`命令的时候，用户需要知道所要加载的变量名或函数名，否则无法加载。这就产生一个问题，使用模块者不愿阅读文档，不想知道变量名。此时就要用到`export default`命令，==为模块指定默认输出。==\n\n### 13.5.1、导出具体的值\n\n- 定义Utils.js文件\n\n  ```javascript\n  export default 23;\n  ```\n\n- 新建test.html文件导入\n\n  ```html\n  <script type=\"module\">\n          import b from \"./Utils.js\";\n          console.info(b);\n  </script>\n  ```\n\n### 13.5.2、导出函数\n\n- 定义Utils.js文件\n\n  ```javascript\n  export default function fn(){\n      console.log(\"Hello\");\n  };\n  ```\n\n- 新建test.html文件\n\n  ```html\n  <script type=\"module\">\n          import func from \"./Utils.js\";\n          func();\n  </script>\n  ```\n\n### 13.5.3、导出类\n\n- 定义Utils.js文件\n\n  ```javascript\n  class Person {\n      info(){\n          console.log(\"info\");\n      }\n  }\n\n  export default Person;\n  ```\n\n- 新建test.html文件\n\n  ```html\n  <script type=\"module\">\n      import Person from \"./Utils.js\";\n      new Person().info();\n  </script>\n  ```\n\n### 13.5.4、混合使用\n\n- Utils.js\n\n  ```javascript\n  export default 23;\n  export let a = 12;\n  ```\n\n- test.html\n\n  ```html\n  <script type=\"module\">\n       import num1,{a} from \"./Utils.js\";\n       console.info(num1,a);\n  </script>\n  ```\n\n### 13.5.5、总结\n\n- export default 向外暴露的成员，可以使用任意变量名来import\n- 在一个模块中，export default 只允许向外暴露一次。\n- 在一个模块中，可以同时使用export default 和export 向外暴露成员\n- export可以向外暴露多个成员，同时，如果某些成员，在import导入时不需要，可以在import时不写。\n- 使用export导出的成员，必须严格按照导出时候的名称，来使用{ }按需接收\n\n## 13.6、多次引入模块只会被引入一次\n\n- utils.js\n\n  ```javascript\n  console.log(\"HelloWorld\");\n\n  export let a = 12;\n  export let b = 23;\n  ```\n\n- test.html\n\n  ```html\n  <script type=\"module\">\n      import {a} from \"./Utils.js\";\n      import {b} from \"./Utils.js\";\n\n      console.log(a);\n      console.log(b);\n  </script>\n  ```\n\n## 13.7、模块与模块也可以import\n\n- A.js\n\n  ```javascript\n  export let x = 12;\n  export let y = \"Hello\"\n  ```\n\n- B.js\n\n  ```javascript\n  import {x,y} from \"./A.js\";\n\n  export let info = ()=> {\n      console.log(x);\n      console.log(y);\n  }\n  ```\n\n- test.html\n\n  ```html\n  <script type=\"module\">\n      import {info} from \"./B.js\";\n\n      info();\n  </script>\n  ```\n\n## 13.8、import导入有提升效果\n\n- Utils.js\n\n  ```javascript\n  export let a = 12;\n  export let b = 23;\n  ```\n\n- test.html\n\n  ```html\n  <script type=\"module\">\n\n      console.log(a);\n      console.log(b);\n\n      import {a,b} from \"./Utils.js\";\n  </script>\n  ```\n\n## 13.9、动态引入模块\n\n### 13.9.1、需求\n\n​\t根据不同的条件引入不同的模块。\n\n- A.js\n\n  ```javascript\n  export let x = 12;\n  ```\n\n- B.js\n\n  ```javascript\n  export let y = 'Spring'\n  ```\n\n- test.html\n\n  ```html\n  <script type=\"module\">\n      let a = 1;\n      if (a == 1){\n          import {x}  from './A.js';\n      }else {\n          import {y} from './B.js';\n      }\n  </script>\n\n  // 报错\n  ```\n\n### 13.9.2、import()解决\n\n- A.js\n\n  ```javascript\n  export let x = 12;\n  ```\n\n- B.js\n\n  ```javascript\n  export let y = 'Spring'\n  ```\n\n- test.html\n\n  ```html\n  <script type=\"module\">\n      let a = 2;\n      if (a == 1){\n          import(\"./A.js\").then(function(respData){\n              console.info(respData.x);\n          })\n      }else {\n          import(\"./B.js\").then(function(respData){\n              console.info(respData.y);\n          })\n      }\n  </script>\n  ```\n\n### 13.9.3、优化\n\n- A.js\n\n  ```javascript\n  export let x = 12;\n  ```\n\n- B.js\n\n  ```javascript\n  export let y = 'Spring'\n  ```\n\n- test.html\n\n  ```html\n  <script type=\"module\">\n\n      let param = 11;\n      const config = () => {\n          if (param == 1){\n              return \"./A.js\";\n          }else{\n              return \"./B.js\";\n          }\n      }\n\n      import(config()).then(function(respData){\n          console.log(respData);\n      });\n  </script>\n  ```\n\n\n\n","tags":["JavaScript","学习笔记"],"categories":["JavaScript笔记"]},{"title":"JavaScript笔记-11正则表达式","url":"/2023/05/26/JavaScript笔记-11正则表达式/","content":"\n# 一、正则表达式\n\n## 1.1、概述\n\n​\t\t**正则表达式（ Regular Expression ）**是用于匹配字符串中字符组合的模式。在 JavaScript中，正则表达式也是对象。\n​\t\t正则表达式通常被用来检索、替换那些符合某个模式（规则）的文本，例如验证表单：用户名表单只能输入英文字母、数字或者下划线， 昵称输入框中可以输入中文(**匹配**)。此外，正则表达式还常用于过滤掉页面内容中的一些敏感词(**替换**)，或从字符串中获取我们想要的特定部分(**提取**)等 。\n\n​\t\t其他语言也会使用正则表达式，本阶段我们主要是利用 JavaScript 正则表达式完成表单验证。\n\n## 1.2、正则表达式的特点\n\n- 灵活性、逻辑性和功能性非常的强。\n- 可以迅速地用极简单的方式达到字符串的复杂控制。\n- 对于刚接触的人来说，比较晦涩难懂。比如： ^\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*$\n- 实际开发,一般都是直接复制写好的正则表达式。但是要求会使用正则表达式并且根据实际情况修改正则表达式.   比如用户名:    /^[a-z0-9_-]{3,16}$/\n\n# 二、正则表达式在 JS中的使用\n\n## 2.1、创建正则表达式\n\n### 2.1.1、说明\n\n​\t\t在 JavaScript 中，可以通过两种方式创建一个正则表达式。\n\n### 2.1.2、调用 RegExp 对象的构造函数创建\n\n```html\n<body>\n    <script>\n        var rege = new RegExp(/表达式/);\n    </script>\n</body>\n```\n\n### 2.1.3、通过字面量创建\n\n```html\n<body>\n    <script>\n        var rege = /表达式/;\n    </script>\n</body>\n\n```\n\n## 2.2、测试正则表达式\n\n### 2.2.1、说明\n\n​\t\ttest()是正则对象方法，用于检测字符串是否符合该规则，该对象会返回 true 或 false，其参数是测试字符串。\n\n```markdown\n# 语法\n\t regexObj.test(str) \n\t1. regexObj 是写的正则表达式\n\t2. str 我们要测试的文本\n\t3. 就是检测str文本是否符合我们写的正则表达式规范.\n```\n\n### 2.2.2、案例1\n\n```html\n<body>\n    <script>\n        // 正则表达式里面不需要加引号 不管是数字型还是字符串型\n        var reg1 = new RegExp(/123/);\n        console.log(reg1.test(123));\n        console.log(reg1.test(1234));\n        console.log(reg1.test(123));\n        \n        // 总结: 只要包含123就可以。\n    </script>\n</body>\n```\n\n### 2.2.3、案例2\n\n```html\n<body>\n    <script>\n        // 正则表达式里面不需要加引号 不管是数字型还是字符串型\n        var reg1 = /abc/;\n        console.log(reg1.test('abc'));\n        console.log(reg1.test('abcd'));\n        console.log(reg1.test('ab'));\n        \n        // 总结: 只要包含字符串abc就可以。\n    </script>\n</body>\n```\n\n# 三、正则表达式中的特殊字符\n\n## 3.1、正则表达式的组成\n\n### 3.1.1、概述\n\n​\t\t一个正则表达式可以由简单的字符构成，比如 /abc/，也可以是简单和特殊字符的组合，比如 /ab*c/ 。其中特殊字符也被称为元字符，在正则表达式中是具有特殊意义的专用符号，如 ^ 、$ 、+ 等。\n\n​\t\t特殊字符非常多，可以简单的划分为几类。\n\n## 3.2、边界符\n\n### 3.2.1、说明\n\n​\t\t正则表达式中的边界符（位置符）用来**提示字符所处的位置**，主要有两个字符。\n\n![0126](/assets/JavaScript笔记/0126.png)\n\n```markdown\n# 如果 ^ 和 $ 在一起，表示必须是精确匹配。\n```\n\n### 3.2.2、案例1\n\n```html\n<body>\n    <script>\n        // 边界符\n        // >> 以谁开头 ^\n        var reg1 = /^abc/;\n        console.log(reg1.test('abc'));\n        console.log(reg1.test('abcd'));\n        console.log(reg1.test('aabc'));\n\n        // 总结: 必须以abc字符串开头\n    </script>\n</body>\n```\n\n### 3.2.3、案例2\n\n```html\n<body>\n    <script>\n        // 边界符\n        // >> 以谁结尾 $\n        var reg1 = /abc$/;\n        console.log(reg1.test('abc'));\n        console.log(reg1.test('abcc'));\n        console.log(reg1.test('aabc'));\n\n        // 总结: 必须以abc字符串结尾，而不是仅仅的c结尾\n    </script>\n</body>\n```\n\n### 3.2.4、案例3\n\n```html\n<body>\n    <script>\n        // 边界符\n        // >> 混合使用\n        var reg1 = /^abc$/;\n        console.log(reg1.test('abc'));\n        console.log(reg1.test('abcabc'));\n        console.log(reg1.test('aabc'));\n\n        // 总结: 必须是字符串abc。如果 ^ 和 $ 在一起，表示必须是精确匹配。\n    </script>\n</body>\n```\n\n## 3.3、字符类\n\n### 3.3.1、说明\n\n​\t\t字符类表示有一系列字符可供选择，只要匹配其中一个就可以了。所有可供选择的字符都放在方括号内。\n\n### 3.3.2、[] 方括号\n\n```markdown\n# 语法\n\t/[abc]/.test('andy')     // true\n\t后面的字符串只要包含 abc 中任意一个字符，都返回 true 。\n```\n\n```html\n<body>\n    <script>\n        // [] 表示有一系列字符可供选择， 只要匹配其中一个就可以了。\n\n        // 只要包含有a 或者 包含有b 或者包含有c 都返回为true\n        var reg = /[abc]/;\n        console.log(reg.test('abc'));\n        console.log(reg.test('a'));\n        console.log(reg.test('aa'));\n        console.log(reg.test('green'));\n    </script>\n</body>\n```\n\n```html\n<body>\n    <script>\n        // [] 表示有一系列字符可供选择， 只要匹配其中一个就可以了。\n\n        // 只要包含有a 或者 包含有b 或者包含有c，但是必须以a或者b或者c开头的字符串 都返回为true\n        var reg = /^[abc]/;\n        console.log(reg.test('aaHello'));\n        console.log(reg.test('cJava'));\n        console.log(reg.test('dada'));\n    </script>\n</body>\n```\n\n```html\n<body>\n    <script>\n        // [] 表示有一系列字符可供选择， 只要匹配其中一个就可以了。\n\n        // 三选一 只有是a 或者是 b  或者是c 这三个字母才返回 true\n        var reg = /^[abc]$/;\n        console.log(reg.test('abc'));\n        console.log(reg.test('aa'));\n        console.log(reg.test('b'));\n    </script>\n</body>\n```\n\n### 3.3.3、[-]  方括号内部 范围符- \n\n```markdown\n# 语法\n\t/[a-z]/;\n\t方括号内部加上 - 表示范围，这里表示 a 到 z 26个英文字母都可以。\n```\n\n```html\n<body>\n    <script>\n        // [] 表示有一系列字符可供选择， 只要匹配其中一个就可以了。\n\n        // 测试的字符串只要包含26个英文字母范围内选取任何一个字母就返回true\n        var reg = /[a-z]/;\n        console.log(reg.test('abc'));\n        console.log(reg.test('ad'));\n        console.log(reg.test('red'));\n    </script>\n</body>\n```\n\n```html\n<body>\n    <script>\n        // [] 表示有一系列字符可供选择， 只要匹配其中一个就可以了。\n\n        // 26个英文字母任何一个字母返回 true  - 表示的是a 到z 的范围 \n        var reg = /^[a-z]$/;\n        console.log(reg.test('abc'));\n        console.log(reg.test('a'));\n        console.log(reg.test('red'));\n    </script>\n</body>\n```\n\n### 3.3.4、[^]  方括号内部 取反符^ \n\n```markdown\n# 语法\n\t/[^a-z]/\n\t方括号内部加上 ^ 表示取反，只要包含方括号内的字符，都返回 false 。\n# 注意\n\t注意和边界符 ^ 区别，边界符写到方括号外面。  \n```\n\n```html\n<body>\n    <script>\n        // [] 表示有一系列字符可供选择， 只要匹配其中一个就可以了。\n\n        // 如果中括号里面有^ 表示取反的意思\n        var reg = /[^a-z]/;\n        console.log(reg.test('abc'));\n        console.log(reg.test('a'));\n        console.log(reg.test('r2'));\n    </script>\n</body>\n```\n\n### 3.3.5、字符组合\n\n```markdown\n# 语法\n\t/[a-z1-9]/\n\t方括号内部可以使用字符组合，这里表示包含 a 到 z 的26个英文字母和 1 到 9 的数字都可以。\n```\n\n```html\n<body>\n    <script>\n        // [] 表示有一系列字符可供选择， 只要匹配其中一个就可以了。\n\n        var reg = /[a-zA-Z0-9]/;\n        console.log(reg.test('abc'));\n        console.log(reg.test('a'));\n        console.log(reg.test('r2'));\n        console.log(reg.test('_'));\n        console.log(reg.test('a_'));\n    </script>\n</body>\n```\n\n```html\n<body>\n    <script>\n        // [] 表示有一系列字符可供选择， 只要匹配其中一个就可以了。\n\n        // 如果中括号里面有^ 表示取反的意思\n        var reg = /^[a-zA-Z0-9]/;\n        console.log(reg.test('abc'));\n        console.log(reg.test('a'));\n        console.log(reg.test('a_'));\n        console.log(reg.test('_a'));\n    </script>\n</body>\n```\n\n```html\n<body>\n    <script>\n        // [] 表示有一系列字符可供选择， 只要匹配其中一个就可以了。\n\n        // 如果中括号里面有^ 表示取反的意思\n        var reg = /[^a-zA-Z0-9]/;\n        console.log(reg.test('abc'));\n        console.log(reg.test('a'));\n        console.log(reg.test('a_'));\n        console.log(reg.test('_a'));\n    </script>\n</body>\n```\n\n## 3.4、量词\n\n### 3.4.1、说明\n\n​\t\t量词符用来设定某个模式出现的次数。\n\n![0127](/assets/JavaScript笔记/0127.png)\n\n```javascript\n// 量词符: 用来设定某个模式出现的次数\n// 简单理解: 就是让下面的a这个字符重复多少次\n// var reg = /^a$/;\n```\n\n### 3.4.2、案例1\n\n```html\n<body>\n    <script>\n        // 量词符: 用来设定某个模式出现的次数\n        // 简单理解: 就是让下面的a这个字符重复多少次\n        // var reg = /^a$/;\n\n        // * 相当于 >= 0 可以出现0次或者很多次 \n        var reg = /^a*/;\n        console.log(reg.test(''));\n        console.log(reg.test('a'));\n        console.log(reg.test('ab'));\n        console.log(reg.test('_a'));\n    </script>\n</body>\n```\n\n### 3.4.3、案例2\n\n```html\n<body>\n    <script>\n        // 量词符: 用来设定某个模式出现的次数\n        // 简单理解: 就是让下面的a这个字符重复多少次\n        // var reg = /^a$/;\n\n        // + 相当于 >= 1 可以出现1次或者很多次 \n        var reg = /^a+/;\n        console.log(reg.test(''));\n        console.log(reg.test('a'));\n        console.log(reg.test('ab'));\n        console.log(reg.test('aab'));\n        console.log(reg.test('_a'));\n    </script>\n</body>\n```\n\n### 3.4.4、案例3\n\n```html\n<body>\n    <script>\n        // 量词符: 用来设定某个模式出现的次数\n        // 简单理解: 就是让下面的a这个字符重复多少次\n        // var reg = /^a$/;\n\n        // ?  相当于 1 || 0，要么1次，要么0次\n        var reg = /^a?$/;\n        console.log(reg.test(''));\n        console.log(reg.test('a'));\n        console.log(reg.test('aa'));\n        console.log(reg.test('_a'));\n        console.log(reg.test('aaa'));\n    </script>\n</body>\n```\n\n### 3.4.5、案例4\n\n```html\n<body>\n    <script>\n        // 量词符: 用来设定某个模式出现的次数\n        // 简单理解: 就是让下面的a这个字符重复多少次\n        // var reg = /^a$/;\n\n        // ?  {3} 就是重复3次\n        var reg = /^a{3}$/;\n        console.log(reg.test(''));\n        console.log(reg.test('a'));\n        console.log(reg.test('aa'));\n        console.log(reg.test('aaa'));\n        console.log(reg.test('_a'));\n        console.log(reg.test('aaaa'));\n    </script>\n</body>\n```\n\n### 3.4.6、案例5\n\n```html\n<body>\n    <script>\n        // 量词符: 用来设定某个模式出现的次数\n        // 简单理解: 就是让下面的a这个字符重复多少次\n        // var reg = /^a$/;\n\n        // {3, }  大于等于3\n        var reg = /^a{3,}$/;\n        console.log(reg.test(''));\n        console.log(reg.test('a'));\n        console.log(reg.test('aa'));\n        console.log(reg.test('aaa'));\n        console.log(reg.test('_a'));\n        console.log(reg.test('aaaa'));\n    </script>\n</body>\n```\n\n### 3.4.7、案例6\n\n```html\n<body>\n    <script>\n        // 量词符: 用来设定某个模式出现的次数\n        // 简单理解: 就是让下面的a这个字符重复多少次\n        // var reg = /^a$/;\n\n        //  {3,6}  大于等于3 并且 小于等于6\n        var reg = /^a{3,6}$/;\n        console.log(reg.test(''));\n        console.log(reg.test('a'));\n        console.log(reg.test('aa'));\n        console.log(reg.test('aaa'));\n        console.log(reg.test('_a'));\n        console.log(reg.test('aaaa'));\n    </script>\n</body>\n```\n\n## 3.5、案例\n\n### 3.5.1、需求\n\n​\t\t用户名验证。\n\n​\t\t功能需求:\n\n- 如果用户名输入合法, 则后面提示信息为 :  用户名合法,并且颜色为绿色\n- 如果用户名输入不合法, 则后面提示信息为:  用户名不符合规范, 并且颜色为绿色\n\n### 3.5.2、代码实现\n\n```html\n<head>\n    <style>\n        span {\n            color: #aaa;\n            font-size: 14px;\n        }\n        \n        .right {\n            color: green;\n        }\n        \n        .wrong {\n            color: red;\n        }\n    </style>\n</head>\n<body>\n    <input type=\"text\" class=\"uname\"> <span>请输入用户名</span>\n    <script>\n        // 这个模式用户只能输入英文字母 数字 下划线 短横线但是有边界符和[] 这就限定了只能多选1\n        var reg = /^[a-zA-Z0-9_-]{6,16}$/;\n\n        // 1、获取节点\n        var inputObj = document.querySelector('input');\n        var spanObj = document.querySelector('span');\n\n        inputObj.onblur = function() {\n            if (reg.test(this.value)) {\n                spanObj.className = 'right';\n                spanObj.innerHTML = '用户名格式输入正确';\n            } else {\n                spanObj.className = 'wrong';\n                spanObj.innerHTML = '用户名格式输入不正确';\n            }\n        }\n    </script>\n</body>\n```\n\n## 3.6、小括号总结\n\n### 3.6.1、说明\n\n- 大括号  量词符.   里面表示重复次数\n- 中括号 字符集合。匹配方括号中的任意字符. \n- 小括号 表示优先级\n\n### 3.6.2、案例1\n\n```html\n<body>\n    <script>\n        // 只是让c重复三次   abccc\n        var reg = /^abc{3}$/;\n        console.log(reg.test('abcabc'));\n        console.log(reg.test('abccc'));\n    </script>\n</body>\n```\n\n### 3.6.3、案例2\n\n```html\n<body>\n    <script>\n        // 只是让c重复三次   abccc\n        var reg = /^(abc){3}$/;\n        console.log(reg.test('abcabc'));\n        console.log(reg.test('abccc'));\n        console.log(reg.test('abcabcabc'));\n    </script>\n</body>\n```\n\n# 四、预定义类\n\n## 4.1、概述\n\n### 4.1.1、说明\n\n​\t\t预定义类指的是某些常见模式的简写方式。\n\n![0128](/assets/JavaScript笔记/0128.png)\n\n### 4.1.2、案例1\n\n```html\n<body>\n    <script>\n        var reg = /^\\d{3}-\\d{8}|\\d{4}-\\d{7}$/;\n        // var reg = /^\\d{3,4}-\\d{7,8}$/;\n        console.log(reg.test(\"010-11111111\"));\n        console.log(reg.test(\"0101-1111111\"));\n    </script>\n</body>\n```\n\n### 4.1.3、案例2\n\n```html\n<body>\n    <script>\n        var reg = /^\\d{3,4}-\\d{7,8}$/;\n        console.log(reg.test(\"010-11111111\"));\n        console.log(reg.test(\"0101-1111111\"));\n\n        console.log(reg.test(\"010-11111111\"));\n        console.log(reg.test(\"0101-11111111\"));\n    </script>\n</body>\n```\n\n# 五、替换\n\n## 5.1、replace 替换\n\n### 5.1.1、说明\n\n​\t\treplace() 方法可以实现替换字符串操作，用来替换的参数可以是一个字符串或是一个正则表达式。\n\n```markdown\n# 语法\n\tstringObject.replace(regexp/substr,replacement)\n# 说明\n\t1、第一个参数:   被替换的字符串 或者  正则表达式\n\t2、第二个参数:   替换为的字符串\n\t3、返回值是一个替换完毕的新字符串\n\n```\n\n### 5.1.2、案例1\n\n```html\n<body>\n    <script>\n        var str = \"HelloWorld\";\n        // 仅仅会把第一个o给替换掉\n        var result = str.replace(\"o\", 'A');\n        console.log(result);\n    </script>\n</body>\n```\n\n### 5.1.3、案例2\n\n```html\n<body>\n    <script>\n        var str = \"HelloWorld\";\n        // 仅仅会把第一个o给替换掉\n        var result = str.replace(/o/, 'B');\n        console.log(result);\n    </script>\n</body>\n```\n\n## 5.2、正则表达式参数\n\n### 5.2.1、说明\n\n```markdown\n# 语法\n\t/表达式/[switch]\n# 说明\n\tswitch(也称为修饰符) 按照什么样的模式来匹配. 有三种值：\n\tg：全局匹配 \n\ti：忽略大小写 \n\tgi：全局匹配 + 忽略大小写\n\n```\n\n### 5.2.2、案例1\n\n```html\n<body>\n    <script>\n        var str = \"HelloWorld\";\n        // 搜索全部的o，进行替换\n        var result = str.replace(/o/g, 'B');\n        console.log(result);\n    </script>\n</body>\n```\n\n### 5.2.3、案例2\n\n```html\n<body>\n    <script>\n        var str = \"HelloWOrld\";\n        // 不区分大小写。\n        var result = str.replace(/o/gi, 'B');\n        console.log(result);\n    </script>\n</body>\n```\n\n","tags":["JavaScript","学习笔记"],"categories":["JavaScript笔记"]},{"title":"JavaScript笔记-10闭包","url":"/2023/05/26/JavaScript笔记-10闭包/","content":"\n# 一、闭包\n\n## 1.1、说明\n\n​\t\t变量根据作用域的不同分为两种：全局变量和局部变量。\n\n- 函数内部可以使用全局变量。\n- 函数外部不可以使用局部变量。\n- 当函数执行完毕，本作用域内的局部变量会销毁。\n\n## 1.2、什么是闭包\n\n```markdown\n# 闭包（closure）\n\t指有权访问另一个函数作用域中变量的函数，闭包是一个函数。指的是可以访问另一个函数作用域中变量的函数。\n\t\n# 简单理解就是 \n\t一个作用域可以访问另外一个函数内部的局部变量。 \n```\n\n```html\n<body>\n    <script>\n        // fn1 就是闭包函数\n        function fn1() {\n            var num = 10;\n\n            function fn2() {\n                console.log(num);\n            };\n\n            fn2();\n        }\n        fn1();\n        \n        // 总结: fn2 这个函数作用域 访问了另外一个函数 fn1 里面的局部变量 num\n    </script>\n</body>\n```\n\n![0125](/assets/JavaScript笔记/0125.png)\n\n## 1.3、闭包的作用\n\n### 1.3.1、问题引入\n\n​\t我们怎么能在 `fn()` 函数外面访问 `fn()` 中的局部变量 `num` 呢 ？例如：\n\n```html\n<body>\n    <script>\n        function fn1() {\n            var num = 10;\n        }\n\n        // 在此处想访问到 fn1 函数中的 num变量？\n    </script>\n</body>\n```\n\n### 1.3.2、实现\n\n​\t\t我们可以返回一个函数，在这个函数中去访问num的数据。\n\n```html\n<body>\n    <script>\n        function fn1() {\n            var num = 10;\n\n            return function() {\n                console.log(num);\n            }\n        }\n\n        // 调用完 fn1 函数之后, 会得到一个结果，这个结果是一个函数\n        var func = fn1();\n\n        // 调用函数\n        func();\n        \n       \t// <===> 等同于\n\n        var func = function() {\n            console.log(num);\n        }\n\n        func();\n\n        // 总结: 在此处就访问到了 fn1 函数中的 num 的值。\n    </script>\n</body>\n```\n\n\n\n```markdown\n# 闭包作用：延伸变量的作用范围。\n```\n\n## 1.4、闭包案例\n\n### 1.4.1、案例1\n\n​\t\t点击li输出索引号。\n\n```html\n<body>\n    <ul>\n        <li>赵敏</li>\n        <li>张无忌</li>\n        <li>周芷若</li>\n        <li>金毛狮王</li>\n    </ul>\n    <script>\n        // 点击li输出当前li的索引号\n        // >> 方式一: 我们可以利用动态添加属性的方式\n\n        // 1、获取所有的li\n        var liObjs = document.querySelector(\"ul\").querySelectorAll(\"li\");\n        // 2、遍历li绑定事件\n        for (var i = 0; i < liObjs.length; i++) {\n\n            // 为当前节点动态添加属性\n            liObjs[i].index = i;\n            liObjs[i].onclick = function() {\n                console.log(this.index);\n            }\n        }\n    </script>\n</body>\n```\n\n```html\n<body>\n    <ul>\n        <li>赵敏</li>\n        <li>张无忌</li>\n        <li>周芷若</li>\n        <li>金毛狮王</li>\n    </ul>\n    <script>\n        // 点击li输出当前li的索引号\n        // >> 方式二: 闭包的方式得到当前li 的索引号\n\n        // 1、获取所有的li\n        var liObjs = document.querySelector(\"ul\").querySelectorAll(\"li\");\n        // 2、遍历li绑定事件\n        for (var i = 0; i < liObjs.length; i++) {\n            // >> 2.1 利用for循环创建了4个立即执行函数\n            // >>     立即执行函数也成为小闭包因为立即执行函数里面的任何一个函数都可以使用它的i这变量\n            (function(i) {\n                liObjs[i].onclick = function() {\n                    console.log(i);\n                }\n            })(i);\n        }\n    </script>\n</body>\n```\n\n### 1.4.2、案例2\n\n​\t\t定时器中的闭包。\n\n```html\n<body>\n    <ul>\n        <li>赵敏</li>\n        <li>张无忌</li>\n        <li>周芷若</li>\n        <li>金毛狮王</li>\n    </ul>\n    <script>\n        // 3秒钟之后,打印所有li元素的内容\n\n        // 1、获取所有的li\n        var liObjs = document.querySelector(\"ul\").querySelectorAll(\"li\");\n        // 2、遍历li绑定事件\n        for (var i = 0; i < liObjs.length; i++) {\n            // >> 2.1 利用for循环创建了4个立即执行函数\n            // >>     立即执行函数也成为小闭包因为立即执行函数里面的任何一个函数都可以使用它的i这变量\n            (function(i) {\n                setTimeout(function() {\n                    console.log(liObjs[i].innerHTML);\n                }, 3000)\n            })(i);\n        }\n    </script>\n</body>\n```\n\n### 1.4.3、案例3\n\n​\t\t计算打车价格。\n\n```html\n<body>\n    <script>\n        // 计算打车价格\n        /**\n         *  需求: \n         *      打车起步价13(3公里内),  之后每多一公里增加 5块钱.  用户输入公里数就可以计算打车价格\n         *      如果有拥堵情况,总价格多收取10块钱拥堵费\n         */\n        var car = (function() {\n            var start = 13; // 起步价  局部变量\n            var total = 0; // 总价  局部变量\n            return {\n                // 正常的总价\n                price: function(n) {\n                    if (n <= 3) {\n                        total = start;\n                    } else {\n                        total = start + (n - 3) * 5\n                    }\n                    return total;\n                },\n                // 拥堵之后的费用\n                yd: function(flag) {\n                    return flag ? total + 10 : total;\n                }\n            }\n        })();\n        console.log(car.price(5));\n        console.log(car.yd(true));\n    </script>\n</body>\n```\n\n\n\n","tags":["JavaScript","学习笔记"],"categories":["JavaScript笔记"]},{"title":"JavaScript笔记-09函数高级","url":"/2023/05/26/JavaScript笔记-09函数高级/","content":"\n# 一、对象方法\n\n## 1.1、Object.keys()\n\n### 1.1.1、概述\n\n```markdown\n# 语法\n\tObject.keys(obj)\n# 含义\n\t用于获取对象自身所有的属性\n\t1. 效果类似 for…in\n\t2. 返回一个由属性名组成的数组\n```\n\n### 1.1.2、案例\n\n```html\n<body>\n    <script>\n        var person = {\n            id: 1,\n            uname: 'HelloWorld',\n            age: 23\n        };\n\n        var keys = Object.keys(person);\n        console.log(keys); // ['id', 'uname', 'age']\n\n        // 遍历key的集合\n        for (var i = 0; i < keys.length; i++) {\n            var key = keys[i];\n            console.log(person[key]);\n        }\n    </script>\n</body>\n```\n\n## 1.2、Object.defineProperty()\n\n### 1.2.1、概述\n\n```markdown\n# 语法\n\tObject.defineProperty(obj, prop, descriptor)\n# 含义\n\t定义对象中新属性或修改原有的属性。\n\t1、参数一obj：\n\t\t必需。目标对象 \n\t\n\t2、参数二prop：必需。\n\t\t需定义或修改的属性的名字\n\t\n\t3、参数三descriptor：必需。目标属性所拥有的特性，该参数是一个对象的形式表示。\n\t\tvalue: 设置属性的值  默认为undefined\n \t\twritable: 值是否可以重写。true | false  默认为false\n \t\tenumerable: 目标属性是否可以被枚举。true | false 默认为 false\n \t\tconfigurable: 目标属性是否可以被删除或是否可以再次修改特性 true | false  默认为false\n```\n\n### 1.2.2、案例1\n\n​\t\t在原有对象身上添加新属性。\n\n```html\n<body>\n    <script>\n        var person = {\n            id: 1,\n            uname: 'HelloWorld',\n            age: 23\n        };\n\n        // \n        Object.defineProperty(person, 'address', {\n            value: '浙江省'\n        });\n\n        console.log(person); // {id: 1, uname: 'HelloWorld', age: 23, address: '浙江省'}\n    </script>\n</body>\n```\n\n### 1.2.3、案例2\n\n​\t\t修改原对象身上的`uname`属性。\n\n```html\n<body>\n    <script>\n        var person = {\n            id: 1,\n            uname: 'HelloWorld',\n            age: 23\n        };\n\n        Object.defineProperty(person, 'uname', {\n            value: 'JavaScript'\n        });\n\n        console.log(person); // {id: 1, uname: 'JavaScript', age: 23}\n    </script>\n</body>\n```\n\n### 1.2.4、案例3\n\n​\t\t设置属性不能修改。\n\n```html\n<body>\n    <script>\n        var person = {\n            id: 1,\n            uname: 'HelloWorld',\n            age: 23\n        };\n\n        // 设置 uname 属性不可修改\n        Object.defineProperty(person, 'uname', {\n            writable: false\n        });\n\n        // 发现 uname 是不能修改的\n        person.uname = 'HTML';\n\n        console.log(person); // {id: 1, uname: 'HelloWorld', age: 23}\n    </script>\n</body>\n```\n\n### 1.2.5、案例4\n\n​\t\t`enumerable` : 目标属性是否可以被枚举。\n\n```html\n<body>\n    <script>\n        var person = {\n            id: 1,\n            uname: 'HelloWorld',\n            age: 23\n        };\n\n        // 添加 address 属性\n        Object.defineProperty(person, 'address', {\n            value: '杭州市',\n            // 目标属性是否可以被枚举,false表示不可被枚举,默认是false\n            enumerable: false\n        });\n\n        console.log(Object.keys(person)); // ['id', 'uname', 'age']\n    </script>\n</body>\n```\n\n### 1.2.6、案例5\n\n​\t\t`configurable` 如果为false 则不允许删除这个属性 默认为false。\n\n```html\n<body>\n    <script>\n        var person = {\n            id: 1,\n            uname: 'HelloWorld',\n            age: 23\n        };\n\n        // configurable 如果为false 则不允许删除这个属性 默认为false\n        Object.defineProperty(person, 'uname', {\n            configurable: false\n        });\n\n        // 删除 uname 属性\n        delete person.uname;\n\n        // 发现并没有删除 uname 属性\n        console.log(Object.keys(person)); // ['id', 'uname', 'age']\n    </script>\n</body>\n```\n\n# 二、函数的定义和调用\n\n## 2.1、函数的定义方式\n\n### 2.1.1、自定义函数/命名函数\n\n```html\n<body>\n    <script>\n        // 函数的定义方式\n        // >> 自定义函数/命名函数\n        function fn() {\n            console.log('--fn--');\n        }\n    </script>\n</body>\n```\n\n### 2.1.2、函数表达式/匿名函数\n\n```html\n<body>\n    <script>\n        // 函数的定义方式\n        // >> 函数表达式 (匿名函数)\n        var fn = function() {\n            console.log('--fn--');\n        }\n    </script>\n</body>\n```\n\n### 2.1.3、利用 new Function\n\n```markdown\n# 语法\n\tnew Function('参数1','参数2', '函数体');\n\t1. Function 里面参数都必须是字符串格式\n```\n\n```html\n<body>\n    <script>\n        // 函数的定义方式\n        // >> new Function('参数1','参数2', '函数体');\n        var fn = new Function(\"console.info('HelloWorld')\");\n        fn();\n    </script>\n</body>\n```\n\n```html\n<body>\n    <script>\n        // 函数的定义方式\n        // >> new Function('参数1','参数2', '函数体');\n        var fn = new Function(\"a\", \"b\", \"console.info(a + b)\");\n        fn(10, 20);\n    </script>\n</body>\n```\n\n```html\n<body>\n    <script>\n        // 函数的定义方式\n        // >> new Function('参数1','参数2', '函数体');\n        var fn = new Function(\"a\", \"b\", \"console.info(a + b)\");\n        console.log(fn instanceof Object); // true\n    </script>\n</body>\n```\n\n```markdown\n# 说明\n\t1. 所有函数都是 Function 的实例(对象)\n\t2. 函数也属于对象\n```\n\n## 2.2、函数的调用方式\n\n### 2.2.1、普通函数\n\n```html\n<body>\n    <script>\n        // 函数的定义方式\n        // >> 普通函数调用\n        function fn() {\n            console.log('--fn--');\n        }\n        fn();\n    </script>\n</body>\n```\n\n```html\n<body>\n    <script>\n        // 函数的定义方式\n        // >> 普通函数调用\n        function fn() {\n            console.log('--fn--');\n        }\n        fn.call();\n    </script>\n</body>\n```\n\n### 2.2.2、对象的方法\n\n```html\n<body>\n    <script>\n        // 函数的定义方式\n        // >> 对象的方法\n        var person = {\n            run: function() {\n                console.log('--run--');\n            }\n        }\n\n        person.run();\n    </script>\n</body>\n```\n\n### 2.2.3、构造函数\n\n```html\n<body>\n    <script>\n        // 函数的定义方式\n        // >> 构造函数\n        function Person() {\n            console.log('---构造函数---');\n        }\n\n        new Person();\n    </script>\n</body>\n```\n\n### 2.2.4、绑定事件函数\n\n```html\n<body>\n    <button>注册</button>\n    <script>\n        // 函数的定义方式\n        // >> 绑定事件函数\n        var btnObj = document.querySelector('button');\n\n        btnObj.onclick = function() {\n            console.log('--注册--');\n        }\n    </script>\n</body>\n```\n\n### 2.2.5、定时器函数\n\n```html\n<body>\n    <script>\n        // 函数的定义方式\n        // >> 定时器函数\n        setTimeout(function() {\n            console.log('---定时器函数---');\n        }, 2000);\n    </script>\n</body>\n```\n\n### 2.2.6、立即执行函数\n\n```html\n<body>\n    <script>\n        // 函数的定义方式\n        // >> 立即执行函数\n        (function(num) {\n            console.log('--' + num);\n        })(30);\n    </script>\n</body>\n```\n\n### 2.2.7、总结\n\n```markdown\n# 函数的调用方式    \n    1. 普通函数\n    2. 对象的方法\n    3. 构造函数\n    4. 绑定事件函数\n    5. 定时器函数\n    6. 立即执行函数\n```\n\n# 三、this关键字\n\n## 3.1、函数内 this 的指向\n\n### 3.1.1、说明\n\n​\t\t这些 this 的指向，是当我们调用函数的时候确定的。 调用方式的不同决定了this 的指向不同。通常来说，一般指向我们的调用者。\n\n### 3.1.2、图示\n\n![0124](/assets/JavaScript笔记/0124.png)\n\n### 3.1.3、普通函数调用\n\n```html\n<body>\n    <script>\n        // 函数的调用,this 的指向问题 \n        // >> 普通函数调用\n        function fn() {\n            console.log('普通函数的this-->', this);\n        }\n        fn();\n    </script>\n</body>\n```\n\n```markdown\n# 普通函数 this 指向window\n```\n\n### 3.1.4、对象方法调用\n\n```html\n<body>\n    <script>\n        // 函数的调用,this 的指向问题 \n        // >> 对象方法调用\n        var person = {\n            run: function() {\n                console.log('对象方法的this', this);\n            }\n        };\n        person.run();\n    </script>\n</body>\n```\n\n```markdown\n#  对象的方法 this指向的是对象 person\n```\n\n### 3.1.5、构造函数调用\n\n```html\n<body>\n    <script>\n        // 函数的调用,this 的指向问题 \n        // >> 构造方法调用\n        function Star() {\n            console.log('构造方法的this-->', this);\n        }\n        var zhangsan = new Star();\n    </script>\n</body>\n```\n\n```html\n<body>\n    <script>\n        // 函数的调用,this 的指向问题 \n        // >> 构造方法调用\n        function Star() {\n            console.log('构造函数的this', this);\n        }\n        Star.prototype.run = function() {\n            console.log('方法', this);\n        }\n        var zhangsan = new Star();\n        zhangsan.run();\n    </script>\n</body>\n```\n\n```markdown\n# 构造函数 this 指向 zhangsan 这个实例对象 原型对象里面的this 指向的也是 zhangsan 这个实例对象。\n```\n\n### 3.1.6、绑定事件函数调用\n\n```html\n<body>\n    <button>注册</button>\n    <script>\n        // 函数的调用,this 的指向问题 \n        // >> 绑定事件函数调用\n        var btnObj = document.querySelector('button');\n        btnObj.onclick = function() {\n            console.log('注册事件处理函数的this', this);\n        }\n    </script>\n</body>\n```\n\n```markdown\n# 绑定事件函数 this 指向的是函数的调用者 button 这个按钮对象\n```\n\n### 3.1.7、定时器函数调用\n\n```html\n<body>\n    <script>\n        // 函数的调用,this 的指向问题 \n        // >> 定时器调用\n        setTimeout(function() {\n            console.log('定时器的this', this);\n        }, 3000);\n    </script>\n</body>\n```\n\n```markdown\n# 定时器函数 this 指向的也是window\n```\n\n### 3.1.8、立即执行函数调用\n\n```html\n<body>\n    <script>\n        // 函数的调用,this 的指向问题 \n        // >> 立即执行函数\n        (function() {\n            console.log('立即函数的this', this);\n        })();\n    </script>\n</body>\n```\n\n```markdown\n# 立即执行函数 this还是指向window\n```\n\n## 3.2、改变函数内部 this 指向\n\n### 3.2.1、说明\n\n​\t\tJavaScript 为我们专门提供了一些函数方法来帮我们更优雅的处理函数内部 this 的指向问题，常用的有 bind()、call()、apply() 三种方法。\n\n### 3.2.2、call方法\n\n#### 3.2.2.1、说明\n\n```markdown\n# 语法\n\tfun.call(thisArg, arg1, arg2, ...) \n# 说明\n\t1、thisArg：在 fun 函数运行时指定的 this 值\n \t2、arg1，arg2：传递的其他参数\n \t3、返回值就是函数的返回值，因为它就是调用函数\n \t4、因此当我们想改变 this 指向，同时想调用这个函数的时候，可以使用 call，比如继承。\n \t\n# 作用\n\t1、可以调用函数\n\t2、实现继承\n```\n\n#### 3.2.2.2、案例1\n\n```html\n<body>\n    <script>\n        // 改变函数内部 this 指向\n        // >> call方法\n\n        // 1、定义对象\n        var person = {\n            uname: 'HelloWorld'\n        };\n\n        // 2、定义函数\n        function fn(a, b) {\n            console.log(this); // {uname: 'HelloWorld'}\n            console.log(a + b);\n        }\n\n        fn.call(person, 10, 20);\n    </script>\n</body>\n```\n\n#### 3.2.2.3、案例2\n\n```html\n<body>\n    <script>\n        // 改变函数内部 this 指向\n        // >> call方法\n\n        // 1、定义父类\n        function Father(uname, age) {\n            this.name = name;\n            this.age = age;\n        }\n        // 2、定义子类\n        function Child(uname, age, address) {\n            Father.call(this, uname, age);\n            this.address = address;\n        }\n\n        var zhangsan = new Child('张三', 20, '河南省');\n        console.log(zhangsan.uname);\n        console.log(zhangsan.age);\n        console.log(zhangsan.address);\n    </script>\n</body>\n```\n\n### 3.2.3、apply 方法\n\n#### 3.2.3.1、说明\n\n```markdown\n# 语法\n\tfun.apply(thisArg, [argsArray])\n# 说明\n\t1. thisArg：在fun函数运行时指定的 this 值\n\t2. argsArray：传递的值，必须包含在【数组】里面\n\t3. 返回值就是函数的返回值，因为它就是调用函数\n\t4. apply 主要跟数组有关系，比如使用 Math.max() 求数组的最大值\n```\n\n#### 3.2.3.2、案例1\n\n```html\n<body>\n    <script>\n        // 改变函数内部 this 指向\n        // >> apply方法\n\n        // 1、定义对象\n        var person = {\n            uname: 'HelloWorld'\n        }\n\n        // 2、定义函数\n        function fn(a, b) {\n            console.log(this);\n            console.log('a + b = ' + (a + b));\n        }\n\n        // 3、调用fn函数，fn函数需要的参数，使用apply调用的话，参数需要用数组的形式传递\n        fn.apply(person, [10, 20]);\n    </script>\n</body>\n```\n\n#### 3.2.3.3、案例2\n\n​\t\t`apply` 的主要应用 比如说我们可以利用 apply 借助于数学内置对象求数组最大值。\n\n```html\n<body>\n    <script>\n        // 改变函数内部 this 指向\n        // >> apply方法\n\n        // 1、定义数组\n        var arrs = [10, 21, 18, 34, 23];\n\n        // 2、求最大值\n        var result = Math.max.apply(Math, arrs);\n        console.log(result);\n    </script>\n</body>\n```\n\n### 3.2.4、bind 方法\n\n#### 3.2.4.1、说明\n\n```markdown\n# 语法\n\tfun.bind(thisArg, arg1, arg2, ...) \n\t方法不会调用，但是也会改变函数this的指向。\n\t\n# 说明\n\t 1. thisArg：在 fun 函数运行时指定的 this 值\n \t 2. arg1，arg2：传递的其他参数\n\t 3. 返回由指定的 this 值和初始化参数改造的原函数拷贝，也就是说返回的是一个函数，一个原函数的一个拷贝。\n \t 4. 因此当我们只是想改变 this 指向，并且不想调用这个函数的时候，可以使用 bind\n```\n\n#### 3.2.4.2、案例1\n\n```html\n<body>\n    <script>\n        // 改变函数内部 this 指向\n        // >> bind方法\n\n        // 1、定义对象\n        var person = {\n            uname: 'HelloWorld'\n        };\n\n        // 2、定义函数\n        function fn(a, b) {\n            console.log(this);\n            console.log(\"a + b = \" + (a + b));\n        }\n\n        // 3、绑定,返回的是原函数改变this之后产生的新函数,新函数并不调用\n        var f = fn.bind(person, 10, 30);\n\n        // 4、调用\n        f();\n    </script>\n    \n</body>\n```\n\n#### 3.2.4.3、案例2\n\n​\t\t如果有的函数我们不需要立即调用，但是又想改变这个函数内部的this指向此时用bind。\n\n​\t\t我们有一个按钮，当我们点击了之后，就禁用这个按钮，3秒钟之后开启这个按钮。\n\n​\t\t错误的代码实现：\n\n```html\n<body>\n    <button>注册</button>\n    <script>\n        // 改变函数内部 this 指向\n        // >> bind方法\n\n        // 1、获取button按钮\n        var btnObj = document.querySelector('button');\n\n        // 2、绑定点击事件\n        btnObj.onclick = function() {\n            // >> 2.1 将按钮禁用,this就是当前的button按钮\n            this.disabled = true;\n            // >> 2.2 开启定时器，3秒之后还原\n            setTimeout(function() {\n                // >> 2.3 不能用this,因为定时器中的this指的是window对象,不是按钮\n                this.disabled = false;\n            }, 3000);\n        }\n    </script>\n</body>\n```\n\n​\t\t正确的代码实现：\n\n```html\n<body>\n    <button>注册</button>\n    <script>\n        // 改变函数内部 this 指向\n        // >> bind方法\n\n        // 1、获取button按钮\n        var btnObj = document.querySelector('button');\n\n        // 2、绑定点击事件\n        btnObj.onclick = function() {\n            // >> 2.1 将按钮禁用,this就是当前的button按钮\n            this.disabled = true;\n            // >> 2.2 开启定时器，3秒之后还原\n            // >> 2.2.1 定义全局变量，保存this\n            var that = this;\n            setTimeout(function() {\n                // >> 2.3 用定义好的that变量\n                that.disabled = false;\n            }, 3000);\n        }\n    </script>\n</body>\n```\n\n#### 3.2.4.4、案例3\n\n```html\n<body>\n    <button>注册</button>\n    <script>\n        // 改变函数内部 this 指向\n        // >> bind方法\n\n        // 1、获取button按钮\n        var btnObj = document.querySelector('button');\n\n        // 2、绑定点击事件\n        btnObj.onclick = function() {\n                // >> 2.1 将按钮禁用,this就是当前的button按钮\n                this.disabled = true;\n                // >> 2.2 开启定时器，3秒之后还原\n                setTimeout(function() {\n                    this.disabled = false; // 使用bind之后,该函数内部的this也就指向了按钮\n                }.bind(this), 3000); // 此处的this指向的是button按钮\n            }\n            //通过使用bind,改变函数this指向,返回的函数并不会立即调用,而是过了3秒再去调用。使用bind正好\n    </script>\n</body>\n```\n\n#### 3.2.4.5、案例4\n\n```html\n<body>\n    <button>注册</button>\n    <button>注册</button>\n    <button>注册</button>\n    <script>\n        // 改变函数内部 this 指向\n        // >> bind方法\n\n        // 1、获取button按钮\n        var btnObjs = document.querySelectorAll(\"button\");\n\n        // 2、绑定点击事件\n        for (var i = 0; i < btnObjs.length; i++) {\n            btnObjs[i].onclick = function() {\n                // >> 将当前点击的按钮设置为禁用\n                this.disabled = true;\n                // >> 启用定时器,3秒启用\n                setTimeout(function() {\n                    this.disabled = false;\n                }.bind(this), 3000);\n            }\n        }\n    </script>\n</body>\n```\n\n## 3.3、call 、apply、bind 总结\n\n```markdown\n# 相同点\n\t都可以改变函数内部的this指向。\n# 区别点\n\t1. call 和 apply 会调用函数, 并且改变函数内部this指向.\n\t2. call 和 apply 传递的参数不一样, call 传递参数 arg1, arg2..形式  apply 必须数组形式[arg]\n\t3. bind 不会调用函数, 可以改变函数内部this指向.\n# 主要应用场景\n\t1. call 经常做继承. \n\t2. apply 经常跟数组有关系.  比如借助于数学对象实现数组最大值最小值\n\t3. bind  不调用函数,但是还想改变this指向. 比如改变定时器内部的this指向.\n```\n\n# 四、严格模式\n\n## 4.1、什么是严格模式\n\n​\t\tJavaScript 除了提供正常模式外，还提供了严格模式（strict mode）。ES5 的严格模式是采用具有限制性 JavaScript 变体的一种方式，即在严格的条件下运行 JS 代码。\n\n​\t\t严格模式在 IE10 以上版本的浏览器中才会被支持，旧版本浏览器中会被忽略。\n\n​\t\t严格模式对正常的 JavaScript 语义做了一些更改： \n\n- 消除了 Javascript 语法的一些不合理、不严谨之处，减少了一些怪异行为。\n- 消除代码运行的一些不安全之处，保证代码运行的安全。\n- 提高编译器效率，增加运行速度。\n- 禁用了在 ECMAScript 的未来版本中可能会定义的一些语法，为未来新版本的 Javascript 做好铺垫。比如一些保留字如：class, enum, export, extends, import, super 不能做变量名。\n\n## 4.2、开启严格模式\n\n### 4.2.1、说明\n\n​\t\t严格模式可以应用到整个脚本或个别函数中。因此在使用时，我们可以将严格模式分为脚本开启严格模式和为函数开启严格模式两种情况。\n\n### 4.2.2、为脚本开启严格模式\n\n​\t\t为整个脚本文件开启严格模式，需要在所有语句之前放一个特定语句“use strict”;（或‘use strict’;）。\n\n```html\n<body>\n    <script>\n        'use strict';\n        console.log('这是严格模式...');\n        \n        // 说明：为\"use strict\"加了引号，所以老版本的浏览器会把它当作一行普通字符串而忽略。\n    </script>\n</body>\n```\n\n​\t\t有的 script 基本是严格模式，有的 script 脚本是正常模式，这样不利于文件合并，所以可以将整个脚本文件放在一个立即执行的匿名函数之中。这样独立创建一个作用域而不影响其他 script 脚本文件。\n\n```html\n<body>\n    <script>\n        (function() {\n            'use strict';\n            var num = 20;\n            console.log(num);\n\n            // 该函数也是严格模式下的函数\n            function run() {\n\n            }\n        })();\n    </script>\n</body>\n```\n\n### 4.2.3、为函数开启严格模式\n\n​\t\t要给某个函数开启严格模式，需要把“use strict”;  (或 'use strict'; ) 声明放在函数体所有语句之前。\n\n​\t\t将 \"use strict\" 放在函数体的第一行，则整个函数以 \"严格模式\" 运行。\n\n```html\n<body>\n    <script>\n        // 此时只是给run函数开启严格模式\n        function run() {\n            'use strict';\n            console.log('该函数在严格模式下运行');\n        }\n        \n        // 这个函数里面的还是按照普通模式执行\n        function sing(){\n            \n        }\n    </script>\n</body>\n```\n\n## 4.3、严格模式中的变化\n\n### 4.3.1、说明\n\n​\t\t严格模式对 Javascript 的语法和行为，都做了一些改变。\n\n### 4.3.2、变量规定\n\n- 在正常模式中，如果一个变量没有声明就赋值，默认是全局变量。严格模式禁止这种用法，变量都必须先用var 命令声明，然后再使用。\n- 严禁删除已经声明变量。例如，delete x; 语法是错误的。\n\n```html\n<body>\n    <script>\n        'use strict';\n        num = 20;\n        console.log(num); // 报错，Uncaught ReferenceError: num is not defined\n        \n        // 总结： 变量名必须先声明再使用\n    </script>\n</body>\n```\n\n```html\n<body>\n    <script>\n        'use strict';\n        var num = 20;\n        // 删除变量\n        delete num; // 报错：Delete of an unqualified identifier in strict mode\n        \n        // 总结： 不能随意删除已经声明好的变量\n    </script>\n</body>\n```\n\n### 4.3.3、严格模式下 this 指向问题\n\n- 以前在全局作用域函数中的 this 指向 window 对象。\n- ==**严格模式下全局作用域中函数中的 this 是 undefined**。==\n- 以前构造函数时不加 new也可以 调用，当普通函数，this 指向全局对象。但是在严格模式下，如果 构造函数不加new调用, this 指向的是undefined 如果给他赋值则 会报错\n- new 实例化的构造函数指向创建的对象实例。\n- 定时器 this 还是指向 window 。\n- 事件、对象还是指向调用者。\n\n```html\n<body>\n    <script>\n        'use strict';\n\n        function fn() {\n            console.log(this); // undefined\n        }\n        fn();\n        \n        // 总结：严格模式下全局作用域中函数中的 this 是 undefined。\n    </script>\n</body>\n```\n\n```html\n<body>\n    <script>\n        'use strict';\n\n        function Star() {\n            this.uname = '张三';\n        }\n        Star();\t\t// 报错,Cannot set properties of undefined (setting 'uname')\n        \n        // 总结：严格模式下，构造函数如果不加new调用,则是普通函数调用，那么函数的this是undefined\n    </script>\n</body>\n```\n\n```html\n<body>\n    <script>\n        'use strict';\n\n        setTimeout(function() {\n            console.log(this);\n        }, 3000);\n        \n        // 总结：定时器 this 还是指向 window 。\n    </script>\n</body>\n```\n\n### 4.3.4、函数变化\n\n- 函数不能有重名的参数。\n- 函数必须声明在顶层。新版本的 JavaScript 会引入“块级作用域”（ ES6 中已引入）。为了与新版本接轨，不允许在非函数的代码块内声明函数。\n\n```html\n<body>\n    <script>\n        'use strict';\n\n        function sum(a, a) {\n            console.log(a + a);\n        }\n\n        sum(10, 20); // 报错,Duplicate parameter name not allowed in this context\n        \n        // 总结：严格模式下函数里面的参数不允许有重名\n    </script>\n</body>\n```\n\n```html\n<body>\n    <script>\n        'use strict';\n\n        if (true) {\n            function run() {\n                console.log('helloworld');\n            }\n        }\n        run(); // 报错,在严格模式下会报错,在普通模式下是不会报错的。原因是严格模式要和块级作用域接轨。\n    </script>\n</body>\n```\n\n","tags":["JavaScript","学习笔记"],"categories":["JavaScript笔记"]},{"title":"JavaScript笔记-08构造函数_原型_原型链_继承","url":"/2023/05/26/JavaScript笔记-08构造函数-原型-原型链-继承/","content":"\n# 一、构造函数\n\n## 1.1、概述\n\n​\t\t在面向对象编程语言中，比如说Java语言，是有类的概念的，类就是对象的模板，对象就是类的实例。但是在ES6之前，JavaScript并没有类的概念。\n\n```markdown\n# 在 ES6 之前 ，对象不是基于类创建的，而是用一种称为【构造函数】的特殊函数来定义对象和它们的特征。换句话说，使用 构造函数 来去模拟类。\n```\n\n## 1.2、创建对象的方式\n\n​\t\t在JavaScript中，创建对象的方式有三种：\n\n- 字面量对象\n- new Object()\n- 自定义构造函数\n\n## 1.3、构造函数\n\n### 1.3.1、概述\n\n​\t\t**构造函数**是一种特殊的函数，**主要用来初始化对象**，即为对象成员变量赋初始值，它总与 new 一起使用。我们可以把对象中一些公共的属性和方法抽取出来，然后封装到这个函数里面。\n\n​\t\t在 JS 中，使用构造函数时要注意以下两点：\n\n- 构造函数用于创建某一类对象，其**首字母要大写**\n- 构造函数要和 new 一起使用才有意义\n\n### 1.3.2、new 的含义\n\n​\t\tnew 在执行时会做四件事情：\n\n- 在内存中创建一个新的空对象。\n- 让 this 指向这个新的对象。\n- 执行构造函数里面的代码，给这个新对象添加属性和方法。\n- 返回这个新对象（所以构造函数里面不需要 return ）。\n\n```html\n<body>\n    <script>\n        // 1、定义构造函数\n        function Star(uname, age) {\n            this.uname = uname;\n            this.age = age;\n            this.sing = function() {\n                console.log(\"我会唱歌\");\n            }\n        }\n        // 2、通过构造函数创建对象、\n        var ldh = new Star('刘德华', 20);\n        var zxy = new Star('张学友', 21);\n        ldh.sing();\n        zxy.sing();\n    </script>\n</body>\n```\n\n### 1.3.3、静态成员/实例成员\n\n​\t\tJavaScript 的构造函数中可以添加一些成员，可以在构造函数本身上添加，也可以在构造函数内部的 this 上添加。通过这两种方式添加的成员，就分别称为**静态成员**和**实例成员**。\n\n- 静态成员：在构造函数本上添加的成员称为==**静态成员，只能由构造函数本身来访问。**==\n- 实例成员：在构造函数内部创建的对象成员称为==**实例成员，只能由实例化的对象来访问。**==\n\n```html\n<body>\n    <script>\n        // 构造函数中的属性和方法我们称为成员, 成员可以添加\n\n        // 1、定义构造函数\n        function Star(uname, age) {\n            // >> \n            this.uname = uname;\n            this.age = age;\n            this.sing = function() {\n                console.log(\"我会唱歌\");\n            }\n        }\n        // 1.实例成员就是构造函数内部通过this添加的成员 uname age sing 就是实例成员\n        // 实例成员只能通过实例化的对象来访问\n        var ldh = new Star('刘德华', 23);\n        console.log(ldh.uname);\n        ldh.sing();\n        console.log(Star.uname);\n    </script>\n</body>\n```\n\n```html\n<body>\n    <script>\n        // 构造函数中的属性和方法我们称为成员, 成员可以添加\n\n        // 1、定义构造函数\n        function Star(uname, age) {\n            // >> \n            this.uname = uname;\n            this.age = age;\n            this.sing = function() {\n                console.log(\"我会唱歌\");\n            }\n        }\n        // 2. 静态成员 在构造函数本身上添加的成员  sex 就是静态成员\n        // 静态成员只能通过构造函数来访问\n        Star.sex = '男';\n        console.log(Star.sex);\n    </script>\n</body>\n```\n\n# 二、原型\n\n## 2.1、构造函数创建对象的问题\n\n​\t\t构造函数创建对象该方法很好用，但是存在**浪费内存**的问题，更好的方式是：属性属于对象的，方法是共享的。\n\n![0111](/assets/JavaScript笔记/0111.png)\n\n```markdown\n1. 我们希望所有的对象使用同一个函数，这样就比较节省内存，那么我们要怎样做呢？\n```\n\n## 2.2、构造函数原型prototype\n\n### 2.2.1、说明\n\n```markdown\n# 明确的说明：构造函数通过原型prototype分配的函数是所有对象所共享的。\n```\n\n### 2.2.2、概述\n\n```markdown\n1. JavaScript 规定，每一个构造函数都有一个 prototype 属性，指向另一个对象。注意这个 prototype 就是一个对象，这个对象的所有属性和方法，都会被构造函数所拥有。\n\n# 我们可以把那些不变的方法，直接定义在 prototype 对象上，这样所有对象的实例就可以共享这些方法。\n\n# 简单来说：原型的作用就是用来共享方法的。\n```\n\n### 2.2.3、代码\n\n```html\n<body>\n    <script>\n        // 1、定义构造函数\n        function Star(uname, age) {\n            // >> \n            this.uname = uname;\n            this.age = age;\n        }\n        // 2、向原型对象身上添加sing方法\n        Star.prototype.sing = function() {\n            console.log(\"我会唱歌\");\n        }\n\n        var ldh = new Star('刘德华', 20);\n        var zxy = new Star('张学友s', 21);\n\n        ldh.sing();\n        zxy.sing();\n\n        // 细节\n        // >> 1、查看对象是否共享了sing方法\n        console.log(ldh.sing == zxy.sing); // true\n        console.dir(Star); // 打印的结果看图\n    </script>\n</body>\n```\n\n![0112](/assets/JavaScript笔记/0112.png)\n\n```markdown\n# 总结：我们的公共属性定义到构造函数里面, 公共的方法我们放到原型对象身上。\n```\n\n## 2.3、对象原型proto\n\n### 2.3.1、问题分析\n\n​\t\t通过刚才`2.2.3`案例，可以发现，我们只是向构造函数的原型对象身上添加了`sing`方法，但是呢，对于通过构造函数所创建出来的实例对象`ldh` 、 `zxy` 也能够使用`sing`方法，这个是为什么呢？\n\n​\t\t原因就是在于每个实例对象身上都会有一个`__proto__`的属性。 \n\n### 2.3.2、说明\n\n```markdown\n# 实例对象都会有一个属性 __proto__ 指向构造函数的 prototype 原型对象，之所以我们对象可以使用构造函数 prototype 原型对象的属性和方法，就是因为对象有 __proto__ 原型的存在。\n```\n\n- __proto__对象原型和原型对象 prototype 是等价的。\n- __proto__对象原型的意义就在于为对象的查找机制提供一个方向，或者说一条路线，但是它是一个非标准属性，因此实际开发中，不可以使用这个属性，它只是内部指向原型对象 prototype\n\n![0113](/assets/JavaScript笔记/0113.png)\n\n### 2.3.3、代码\n\n```html\n<body>\n    <script>\n        // 1、定义构造函数\n        function Star(uname, age) {\n            this.uname = uname;\n            this.age = age;\n        }\n        // 2、向原型对象身上添加sing方法\n        Star.prototype.sing = function() {\n            console.log(\"我会唱歌\");\n        }\n\n        var ldh = new Star('刘德华', 20);\n        var zxy = new Star('张学友s', 21);\n\n        ldh.sing();\n        zxy.sing();\n\n        // 细节\n        // >> 1、查看对象身上的__proto__属性\n        console.log(ldh); //对象身上系统自己添加一个 __proto__ 指向我们构造函数的原型对象 prototype\n        console.log(ldh.__proto__ === Star.prototype); // true\n\n        /*\n            方法的查找规则: \n                1、首先先看ldh 对象身上是否有 sing 方法,如果有就执行这个对象上的sing\n                2、如果没有sing 这个方法,因为有__proto__的存在,就去构造函数原型对象prototype身上去查\t\t\t\t\t  找sing这个方法\n        */\n    </script>\n</body>\n```\n\n## 2.4、constructor 构造函数\n\n### 2.4.1、说明\n\n​\t\t**对象原型（proto）**和**构造函数（prototype）原型对象**里面都有一个属性 **constructor 属性** ，constructor 我们称为构造函数，因为它指回构造函数本身。\n\n​\t\tconstructor 主要用于记录该对象引用于哪个构造函数，它可以让原型对象重新指向原来的构造函数。\n\n​\t\t**一般情况下，对象的方法都在构造函数的原型对象中设置**。如果有多个对象的方法，我们可以给原型对象采取对象形式赋值，但是这样就会覆盖构造函数原型对象原来的内容，这样修改后的原型对象 constructor  就不再指向当前构造函数了。此时，我们可以在修改后的原型对象中，添加一个 constructor 指向原来的构造函数。\n\n### 2.4.2、案例1\n\n```html\n<body>\n    <script>\n        // 1、定义构造函数\n        function Star(uname, age) {\n            this.uname = uname;\n            this.age = age;\n        }\n        // 2、向原型对象身上添加方法\n        // >> 2.1 添加sing方法\n        Star.prototype.sing = function() {\n            console.log(\"我会唱歌\");\n        };\n        // >> 2.2 添加movie方法\n        Star.prototype.movie = function() {\n            console.log(\"我会拍电影\");\n        };\n\n        var ldh = new Star('刘德华', 20);\n        ldh.sing();\n        ldh.movie();\n\n        // 细节\n        // >> 1、查看构造函数身上的原型对象信息\n        console.log(Star.prototype); // {sing: ƒ, movie: ƒ, constructor: ƒ}\n        // >> 2、查看实例对象身上的对象原型信息\n        console.log(ldh.__proto__); //  {sing: ƒ, movie: ƒ, constructor: ƒ}\n        // >> 3、查询原型对象所引用的是哪个构造函数\n        console.log(Star.prototype.constructor); // Star(uname, age) {}\n        // >> 4、查询对象原型所引用的是哪个构造函数\n        console.log(ldh.__proto__.constructor); // Star(uname, age) {}\n    </script>\n</body>\n```\n\n### 2.4.3、案例2\n\n​\t\t`2.4.2案例1`属于很标准的代码，但是可以有改进的地方，如果我们需要往原型对象身上添加多个方法，那么每次都需要`Star.prototype.方法`这种方式来去添加。显然很麻烦的，那么更好的做法是这样的，将这些方法封装起来，以对象的形式赋值给原型对象。伪代码如下：\n\n```javascript\nStar.prototype = {\n     sing: function() {\n\n     },\n     movie: function() {\n\n     }\n}\n```\n\n```markdown\n# 注意：这种方式并不是向原型对象身上添加sing方法和movie方法，而是将原型对象重新赋值给了一个新的对象。\n```\n\n```html\n<body>\n    <script>\n        // 1、定义构造函数\n        function Star(uname, age) {\n            this.uname = uname;\n            this.age = age;\n        }\n        // 2、给原型对象赋值为一个新的对象，对象中有sing方法和movie方法\n        // >> 这种方式并不是向原型对象身上添加sing和movie方法，而是将原型对象重新赋值给了一个新的对象。\n        Star.prototype = {\n            sing: function() {\n                console.log(\"我会唱歌\");\n            },\n            movie: function() {\n                console.log(\"我会拍电影\");\n            }\n        }\n\n        var ldh = new Star('刘德华', 20);\n        ldh.sing();\n        ldh.movie();\n\n        // 细节\n        // >> 1、查看构造函数身上的原型对象信息\n        console.log(Star.prototype); // {sing: ƒ, movie: ƒ}\n        // >> 2、查看实例对象身上的对象原型信息\n        console.log(ldh.__proto__); //  {sing: ƒ, movie: ƒ}\n        // >> 3、查询原型对象所引用的是哪个构造函数\n        console.log(Star.prototype.constructor); // Object();\n        // >> 4、查询对象原型所引用的是哪个构造函数\n        console.log(ldh.__proto__.constructor); // Object();\n    </script>\n</body>\n```\n\n### 2.4.4、案例3\n\n​\t\t`2.4.3案例2`发现，查询构造函数身上的原型对象的信息再也找不到`constructor`属性了，即不知道这个原型对象所引用的构造函数是哪个了，那该怎么解决呢？\n\n```html\n<body>\n    <script>\n        // 1、定义构造函数\n        function Star(uname, age) {\n            this.uname = uname;\n            this.age = age;\n        }\n        // 2、给原型对象赋值为一个新的对象，对象中有sing方法和movie方法\n        // >> 这种方式并不是向原型对象身上添加sing和movie方法，而是将原型对象重新赋值给了一个新的对象。\n        Star.prototype = {\n\n            // >> 很多情况下,我们需要手动的利用constructor 这个属性指回 原来的构造函数\n            // >> 如果我们修改了原来的原型对象,给原型对象赋值的是一个对象,则必须手动的利用constructor指\t\t\t\t\t 回原来的构造函数\n            constructor: Star,\n\n            sing: function() {\n                console.log(\"我会唱歌\");\n            },\n            movie: function() {\n                console.log(\"我会拍电影\");\n            }\n        }\n\n        var ldh = new Star('刘德华', 20);\n        ldh.sing();\n        ldh.movie();\n\n        // 细节\n        // >> 1、查看构造函数身上的原型对象信息\n        console.log(Star.prototype); // {sing: ƒ, movie: ƒ, constructor: ƒ}\n        // >> 2、查看实例对象身上的对象原型信息\n        console.log(ldh.__proto__); //  {sing: ƒ, movie: ƒ, constructor: ƒ}\n        // >> 3、查询原型对象所引用的是哪个构造函数\n        console.log(Star.prototype.constructor); // Star(uname, age) {}\n        // >> 4、查询对象原型所引用的是哪个构造函数\n        console.log(ldh.__proto__.constructor); // Star(uname, age) {}\n    </script>\n</body>\n```\n\n## 2.5、构造函数、实例对象、原型对象三者之间的关系\n\n### 2.5.1、图示\n\n![0114](/assets/JavaScript笔记/0114.png)\n\n# 三、原型链\n\n## 3.1、引入\n\n​\t\t刚才讲解了构造函数原型对象至此已经完毕了，现在再思考一个问题，构造函数原型对象，它本身也是一个对象，既然是对象，那么也应该有一个`__proto__`属性，那么这个属性又指向的是哪个原型对象呢？\n\n​\t\t答案：指向的是Object原型对象。\n\n![0115](/assets/JavaScript笔记/0115.png)\n\n```markdown\n# 注意\n\t1. 只要是对象，就有__proto__ 原型, 指向原型对象\n\t2. 我们Star原型对象里面的__proto__原型指向的是 Object.prototype\n\t3. 我们Object.prototype原型对象里面的__proto__原型  指向为 null\n```\n\n### 3.1.1、代码\n\n```html\n<body>\n    <script>\n        // 1、定义构造函数\n        function Star(uname, age) {\n            this.uname = uname;\n            this.age = age;\n        }\n        // 2、给原型对象添加sing方法\n        Star.prototype.sing = function() {\n            console.log(\"我会唱歌\");\n        }\n\n        var ldh = new Star('刘德华', 20);\n        ldh.sing();\n\n        // 细节\n        // >> 1、只要是对象，就有__proto__属性，指向原型对象\n        // >>    我们Star原型对象里面的__proto__原型指向的是 Object.prototype\n        console.log(Star.prototype.__proto__ == Object.prototype); // true\n        // >> 2、我们Object.prototype原型对象里面的__proto__原型  指向为 null\n        console.log(Object.prototype.__proto__); // null\n    </script>\n</body>\n```\n\n## 3.2、对象成员查找机制(规则)\n\n### 3.2.1、说明\n\n- 当访问一个对象的属性（包括方法）时，首先查找这个对象自身有没有该属性。\n- 如果没有就查找它的原型（也就是 __proto__指向的 prototype 原型对象）。\n- 如果还没有就查找原型对象的原型（Object的原型对象）。\n- 依此类推一直找到 Object 为止（null）。\n- __proto__对象原型的意义就在于为对象成员查找机制提供一个方向，或者说一条路线。\n\n### 3.2.2、案例1\n\n```html\n<body>\n    <script>\n        // 1、定义构造函数\n        function Star(uname, age) {\n            this.uname = uname;\n            this.age = age;\n        }\n        // 2、给原型对象添加sex属性\n        Star.prototype.sex = '男';\n\n        var ldh = new Star('刘德华', 20);\n        console.log(ldh.sex);\n\n        /**\n         *  总结: \n         *      ldh这实例对象身上并没有sex属性,按道理来说是不能调用的,但是发现居然可以打印\n         *      出来值,原因在于自己对象本身身上没有,但是我指向的原型对象身上有，那么就会去\n         *      找原型对象身上的sex.\n         */\n    </script>\n</body>\n```\n\n### 3.2.3、案例2\n\n```html\n<body>\n    <script>\n        // 1、定义构造函数\n        function Star(uname, age) {\n            this.uname = uname;\n            this.age = age;\n        }\n        // 2、给原型对象添加sex属性\n        Star.prototype.sex = '男';\n\n        var ldh = new Star('刘德华', 20);\n        ldh.sex = '女';\n        console.log(ldh.sex);\n\n        /**\n         *  总结: \n         *      ldh这实例对象身上有sex属性,并且所指向的原型对象身上也有sex属性，那么当去\n         *      ldh.sex去使用实例对象身上的sex属性的时候，优先看自己有没有，自己有就使用\n         *      自己身上的。\n         */\n    </script>\n</body>\n```\n\n### 3.2.4、案例3\n\n```html\n<body>\n    <script>\n        // 1、定义构造函数\n        function Star(uname, age) {\n            this.uname = uname;\n            this.age = age;\n        }\n        // 2、给原型对象添加sex属性\n        Star.prototype.sex = '男';\n\n        var ldh = new Star('刘德华', 20);\n        console.log(ldh.toString());\n\n        /**\n         *  总结: \n         *      ldh这实例对象身上没有toString()方法，实例对象的__proto__所指向的原型对象身上\n         *      也没有toString()方法,但是__proto__原型对象的原型对象(也就是Object的原型对象)\n         *      身上是有toString()方法的。\n         */\n    </script>\n</body>\n```\n\n## 3.3、原型对象this指向\n\n### 3.3.1、说明\n\n```markdown\n1. 构造函数中的 this 指向我们实例对象。\n2. 原型对象里面放的是方法,  这个方法里面的this 指向的是 这个方法的调用者, 也就是这个实例对象。\n```\n\n### 3.3.2、案例1\n\n```html\n<body>\n    <script>\n        // 0、定义局部变量\n        var that = null;\n\n        // 1、定义构造函数\n        function Star(uname, age) {\n            this.uname = uname;\n            this.age = age;\n            that = this;\n        }\n        var ldh = new Star('刘德华', 20);\n        console.log(ldh === that);\n\n        /**\n         *  总结: \n         *      在构造函数中,里面this指向的是对象实例 ldh\n         */\n    </script>\n</body>\n```\n\n### 3.3.3、案例2\n\n```html\n<body>\n    <script>\n        // 0、定义局部变量\n        var that = null;\n\n        // 1、定义构造函数\n        function Star(uname, age) {\n            this.uname = uname;\n            this.age = age;\n        }\n\n        // 2、向原型对象添加sing方法\n        Star.prototype.sing = function() {\n            console.log('我会唱歌');\n            that = this;\n        }\n\n        var ldh = new Star('刘德华', 20);\n        ldh.sing();\n        console.log(ldh === that);\n\n        /**\n         *  总结: \n         *     原型对象方法里面的this 指向的是 实例对象 ldh(谁调用了sing方法,那么方法中的this就指向谁)\n         */\n    </script>\n</body>\n```\n\n## 3.4、扩展内置对象\n\n### 3.4.1、说明\n\n​\t\t可以通过原型对象，对原来的内置对象进行扩展自定义的方法。比如给数组增加自定义求和的功能。这样的话，通过给数组的原型对象添加方法，那么当我们去创建数组对象的时候，也就拥有了该方法。\n\n​\t\t比如：我对数组`Array`的原型对象添加`sum`求和的方法，那么`new Array()`创建数组实例对象的时候，也会拥有该`sum`方法。\n\n​\t\t伪代码如下：\n\n```html\n<body>\n    <script>\n        Array.prototype.sum = function() {\n\n        }\n\n        var arrs = new Array();\n        arrs.sum();\n    </script>\n</body>\n```\n\n### 3.4.2、代码\n\n```html\n<body>\n    <script>\n        Array.prototype.sum = function() {\n            var result = 0;\n            for (var i = 0; i < this.length; i++) {\n                result = result + this[i];\n            }\n            return result;\n        }\n\n        var arrs = new Array(1, 2, 3, 4, 5);\n        console.log(arrs.sum());\n    </script>\n</body>\n```\n\n### 3.4.3、注意问题\n\n​\t\t刚刚讲到，向原型对象中添加方法，其实可以将添加的方法用对象的形式封装起来，那么将这个对象赋值给原型对象，如果要这样做，该怎么写呢？\n\n```html\n<body>\n    <script>\n        Array.prototype = {\n            sum: function() {\n                var result = 0;\n                for (var i = 0; i < this.length; i++) {\n                    result = result + this[i];\n                }\n                return result;\n            }\n        };\n\n        var arrs = new Array(1, 2, 3, 4, 5);\n        console.log(Array.prototype); // 结果并不是我们赋值的对象\n        console.log(arrs.sum()); // 报错\n    </script>\n</body>\n```\n\n![0116](/assets/JavaScript笔记/0116.png)\n\n### 3.4.4、总结\n\n​\t\t会发现，即使我们为内置对象`Array`的原型对象重新赋值了一个新的对象，发现，还是没有的，就说明：\n\n```markdown\n# 注意：数组和字符串内置对象不能给原型对象覆盖操作 Array.prototype = {} ，只能是 Array.prototype.xxx = function(){} 的方式。\n```\n\n# 四、继承\n\n## 4.1、学习准备\n\n### 4.1.1、注意点\n\n​\t\tES6之前并没有给我们提供 extends 关键字实现继承。我们可以通过**构造函数+原型对象**模拟实现继承，被称为**组合继承**。\n\n### 4.1.2、call方法\n\n​\t\t`call()`方法的学习。该方法的作用是可以改变一个函数内部this的指向。\n\n```markdown\n# 语法\n\tfun.call(thisArg, arg1, arg2, ...) \n\t\n\t1. thisArg ：当前调用函数 this 的指向对象\n\t2. arg1，arg2：传递的其他参数\n```\n\n### 4.1.3、案例1\n\n```html\n<body>\n    <script>\n        function fn(x, y) {\n            console.log(\"x + y =\" + (x + y));\n            console.log(this);\t\t// window\n        }\n\n        // 普通函数调用，函数的内部this默认指向的是Window。\n        fn(10, 20);\t\t\n    </script>\n</body>\n```\n\n### 4.1.4、案例2\n\n```html\n<body>\n    <script>\n        function fn(x, y) {\n            console.log(\"x + y = \" + (x + y));\n            console.log(this);\n        }\n\n        var person = {\n            name: 'HelloWorld'\n        }\n\n        // call() 可以改变这个 fn 函数的this指向 此时这个函数的this 就指向了person这个对象\n        fn.call(person, 1, 3);\n    </script>\n</body>\n```\n\n![0117](/assets/JavaScript笔记/0117.png)\n\n## 4.2、借用构造函数继承父类型属性\n\n### 4.2.1、核心原理\n\n```markdown\n# 通过 call() 把父类型的 this 指向子类型的 this ，这样就可以实现子类型继承父类型的属性。\n```\n\n### 4.2.2、案例\n\n```html\n<body>\n    <script>\n        // 定义父类型\n        function Father(uname, age) {\n            // >> this 指向父构造函数的对象实例\n            this.uname = uname;\n            this.age = age;\n        }\n        // 定义子类型\n        function Child(uname, age, password) {\n            // 此代码表示调用Father构造函数并且将Father构造函数中的this修改为当前的this(Child实例)\n            Father.call(this, uname, age);\n            this.password = password;\n        }\n        var child = new Child('HelloWorld', 20, '123456');\n        console.log(child.uname);\n        console.log(child.age);\n        console.log(child.password);\n    </script>\n</body>\n```\n\n## 4.3、借用构造函数继承父类型方法\n\n### 4.3.1、说明\n\n```markdown\n# 一般情况下，对象的方法都在构造函数的原型对象中设置，通过构造函数无法继承父类方法。  \n```\n\n### 4.3.2、代码错误实现1\n\n```html\n<body>\n    <script>\n        // 定义父类型\n        function Father(uname, age) {\n            // >> this 指向父构造函数的对象实例\n            this.uname = uname;\n            this.age = age;\n        }\n        // 向父构造函数的原型对象添加sing方法\n        Father.prototype.sing = function() {\n            console.log('---我会唱歌---');\n        };\n        // 定义子类型\n        function Child(uname, age, password) {\n            // 此代码表示调用Father构造函数,将Father构造函数中的this修改为当前的this(Child实例对象)\n            Father.call(this, uname, age);\n            this.password = password;\n        }\n        var child = new Child('HelloWorld', 20, '123456');\n        child.sing();\n    </script>\n</body>\n```\n\n![0118](/assets/JavaScript笔记/0118.png)\n\n```markdown\n1. 说明: 仅仅向父构造函数的原型对象上添加方法，子类是不能继承的。\n```\n\n### 4.3.3、代码实现2\n\n​\t\t`4.3.2代码错误实现1`会发现，单纯的向父构造函数的原型对象添加方法是不行的，所以我们自然的可以想到，那么将父构造函数的原型对象再赋值给子构造函数的原型对象，不就可以了嘛，形如这样的：\n\n```javascript\nChild.prototype = Father.prototype\n```\n\n```html\n<body>\n    <script>\n        // 定义父类型\n        function Father(uname, age) {\n            // >> this 指向父构造函数的对象实例\n            this.uname = uname;\n            this.age = age;\n        }\n        // 向父构造函数的原型对象添加sing方法\n        Father.prototype.sing = function() {\n            console.log('---我会唱歌---');\n        };\n        // 定义子类型\n        function Child(uname, age, password) {\n            // 此代码表示调用Father构造函数,将Father构造函数中的this修改为当前的this(子构造函数的实例对象)\n            Father.call(this, uname, age);\n            this.password = password;\n        }\n        // 将父构造函数的原型对象赋值给子构造函数的原型对象!!!!\n        Child.prototype = Father.prototype;\n\n        var child = new Child('HelloWorld', 20, '123456');\n        child.sing();\n    </script>\n</body>\n```\n\n![0119](/assets/JavaScript笔记/0119.png)\n\n![0120](/assets/JavaScript笔记/0120.png)\n\n### 4.3.4、代码实现3\n\n​\t\t`4.3.3代码实现2`发现，确实解决了问题，但是有一个不好的地方，就是如果子构造函数的原型对象身上本身也有方法呢？\n\n```html\n<body>\n    <script>\n        // 定义父类型\n        function Father(uname, age) {\n            // >> this 指向父构造函数的对象实例\n            this.uname = uname;\n            this.age = age;\n        }\n        // 向父构造函数的原型对象添加sing方法\n        Father.prototype.sing = function() {\n            console.log('---我会唱歌---');\n        };\n        // 定义子类型\n        function Child(uname, age, password) {\n            // 此代码表示调用Father构造函数,将Father构造函数中的this修改为当前的this(Child实例对象)\n            Father.call(this, uname, age);\n            this.password = password;\n        }\n        // 将父构造函数的原型对象赋值给子构造函数的原型对象!!!!\n        Child.prototype = Father.prototype;\n        // >> 向子构造中添加自己的方法\n        Child.prototype.run = function() {\n            console.log('跑步');\n        };\n        var child = new Child('HelloWorld', 20, '123456');\n        child.sing();\n        child.run();\n        console.log(Father.prototype);\n    </script>\n</body>\n```\n\n![0121](/assets/JavaScript笔记/0121.png)\n\n![0122](/assets/JavaScript笔记/0122.png)\n\n​\t\t总结：本身`run`方法是属于子类身上的，但是现在由于子构造函数的原型对象指向了父构造函数的原型对象，所以导致父原型对象身上也有`run`方法，这个是不太合适的。\n\n### 4.3.5、正确代码实现1\n\n```markdown\n# 思路\n\t1. 将子类所共享的方法提取出来，让子类的 prototype 原型对象 = new 父类()  \n\t\n\t2. 本质：子类原型对象等于是实例化父类，因为父类实例化之后另外开辟空间，就不会影响原来父类原型对象\n\n\t3. 将子类的 constructor 从新指向子类的构造函数\n```\n\n```html\n<body>\n    <script>\n        // 定义父类型\n        function Father(uname, age) {\n            // >> this 指向父构造函数的对象实例\n            this.uname = uname;\n            this.age = age;\n        }\n        // 向父构造函数的原型对象添加sing方法\n        Father.prototype.sing = function() {\n            console.log('---我会唱歌---');\n        };\n        // 定义子类型\n        function Child(uname, age, password) {\n            // 此代码表示调用Father构造函数,将Father构造函数中的this修改为当前的this(Child实例对象)\n            Father.call(this, uname, age);\n            this.password = password;\n        }\n        // 创建Father构造函数的实例对象赋值给子构造函数的原型对象!!!!\n        Child.prototype = new Father();\n        // >> 向子构造中添加自己的方法\n        Child.prototype.run = function() {\n            console.log('跑步');\n        };\n        var child = new Child('HelloWorld', 20, '123456');\n        child.sing();\n        child.run();\n    </script>\n</body>\n```\n\n![0123](/assets/JavaScript笔记/0123.png)\n\n### 4.3.6、正确代码实现1改进\n\n​\t\t`4.3.5正确代码实现1`确实解决了父构造函数的原型对象身上不会再有子类所特有的方法了，但是以前说过，如果把一个新的对象直接复制给构造函数的原型对象，那么这个构造函数的原型对象的`constructor`属性就不再指向原来的构造函数了，而是指向新创建的对象了，可以尝试看看：\n\n```html\n<body>\n    <script>\n        // 定义父类型\n        function Father(uname, age) {\n            // >> this 指向父构造函数的对象实例\n            this.uname = uname;\n            this.age = age;\n        }\n        // 向父构造函数的原型对象添加sing方法\n        Father.prototype.sing = function() {\n            console.log('---我会唱歌---');\n        };\n        // 定义子类型\n        function Child(uname, age, password) {\n            // 此代码表示调用Father构造函数,将Father构造函数中的this修改为当前的this(Child实例对象)\n            Father.call(this, uname, age);\n            this.password = password;\n        }\n        // 创建Father构造函数的实例对象赋值给子构造函数的原型对象!!!!\n        Child.prototype = new Father();\n        // >> 向子构造中添加自己的方法\n        Child.prototype.run = function() {\n            console.log('跑步');\n        };\n        var child = new Child('HelloWorld', 20, '123456');\n        console.log(Child.prototype.constructor);\t\t// Father(uname,age)\n    </script>\n</body>\n```\n\n​\t\t正确的方式如下：\n\n```html\n<body>\n    <script>\n        // 定义父类型\n        function Father(uname, age) {\n            // >> this 指向父构造函数的对象实例\n            this.uname = uname;\n            this.age = age;\n        }\n        // 向父构造函数的原型对象添加sing方法\n        Father.prototype.sing = function() {\n            console.log('---我会唱歌---');\n        };\n        // 定义子类型\n        function Child(uname, age, password) {\n            // 此代码表示调用Father构造函数,将Father构造函数中的this修改为当前的this(Child实例对象)\n            Father.call(this, uname, age);\n            this.password = password;\n        }\n        // 创建Father构造函数的实例对象赋值给子构造函数的原型对象!!!!\n        Child.prototype = new Father();\n        // 如果利用对象的形式修改了原型对象,别忘了利用constructor 指回原来的构造函数！！！！！\n        Child.prototype.constructor = Child;\n        // >> 向子构造中添加自己的方法\n        Child.prototype.run = function() {\n            console.log('跑步');\n        };\n        var child = new Child('HelloWorld', 20, '123456');\n        console.log(Child.prototype.constructor); // Child(uname, age, password) {}\n    </script>\n</body>\n```\n\n","tags":["JavaScript","学习笔记"],"categories":["JavaScript笔记"]},{"title":"JavaScript笔记-07BOM","url":"/2023/05/26/JavaScript笔记-07BOM/","content":"\n\n# 一、概述\n\n## 1.1、什么是BOM\n\n​\t\tBOM（Browser Object Model）即**浏览器对象模型**，它提供了独立于内容而与浏览器窗口进行交互的对象，其核心对象是 window。\n\n​\t\tBOM 由一系列相关的对象构成，并且每个对象都提供了很多方法与属性。\n\n​\t\tBOM 缺乏标准，JavaScript 语法的标准化组织是 ECMA，DOM 的标准化组织是 W3C，BOM 最初是Netscape 浏览器标准的一部分。\n\n![0099](/assets/JavaScript笔记/0099.png)\n\n## 1.2、BOM的构成\n\n​\t\tBOM 比 DOM 更大，它包含 DOM。\n\n![0100](/assets/JavaScript笔记/0100.png)\n\n​\t\t**window 对象是浏览器的顶级对象，**它具有双重角色。\n\n- 它是 JS 访问浏览器窗口的一个接口。\n- **它是一个全局对象。定义在全局作用域中的变量、函数都会变成 window 对象的属性和方法。**\n- 在调用的时候可以省略 window，前面学习的对话框都属于 window 对象方法，如 alert()、prompt() 等。\n- **注意：**window下的一个特殊属性 window.name，定义变量名最好要避开 name 这个变量名。\n\n```html\n<body>\n    <script>\n        // 定义全局变量\n        var a = 10;\n        console.log(a);\n        console.log(window.a);\n\n        // 定义全局函数\n        function aFn() {\n            console.log('全局函数');\n        }\n        aFn();\n        window.aFn();\n    </script>\n</body>\n```\n\n![0101](/assets/JavaScript笔记/0101.png)\n\n# 二、window 对象的常见事件\n\n## 2.1、窗口加载事件\n\n### 2.1.1、概述\n\n```html\n<script>\n    window.onload = function() {\n\n    };\n\t// 或者\n    window.addEventListener('load', function() {\n\n    });\n</script>\n```\n\n​\t\t`window.onload` 是窗口 (页面）加载事件，当文档内容完全加载完成才会触发该事件(包括图像、脚本文件、CSS 文件等)，从而完成对事件处理函数的调用。\n\n​\t\t**注意：**\n\n- 有了 `window.onload` 就可以把 JS 代码写到页面元素的上方，因为 onload 是等页面内容全部加载完毕， \n\n  再去执行处理函数。\n\n- `window.onload` 传统注册事件方式 只能写一次，如果有多个，会以最后一个 `window.onload` 为准。\n\n- 如果使用 `addEventListener` 则没有限制\n\n### 2.1.2、案例1\n\n```html\n<body>\n    <script>\n        window.onload = function() {\n            console.log('页面加载完毕');\n        };\n        window.onload = function() {\n            console.log('页面加载完毕....');\n        };\n\n        // 传统方式只能写一次,如果多次,后面的覆盖前面的\n    </script>\n</body>\n```\n\n### 2.1.3、案例2\n\n```html\n<body>\n    <script>\n        window.addEventListener('load', function() {\n            console.log(\"页面加载完毕\");\n        });\n\n        window.addEventListener('load', function() {\n            console.log(\"页面加载完毕...\");\n        });\n\n        // addEventListener 可以写多次\n    </script>\n</body>\n```\n\n### 2.1.4、DOMContentLoaded\n\n```java\nwindow.addEventListener('DOMContentLoaded', function() {});\n```\n\n​\t\t`DOMContentLoaded` 事件触发时，仅当DOM加载完成，不包括样式表，图片，flash等等。\n\n​\t\tIe9以上才支持。\n\n​\t\t如果页面的图片很多的话, 从用户访问到onload触发可能需要较长的时间, 交互效果就不能实现，必然影响用\n\n户的体验，此时用 DOMContentLoaded 事件比较合适。\n\n## 2.2、调整窗口大小事件\n\n### 2.2.1、概述\n\n```html\n<body>\n    <script>\n        window.onresize = function() {\n\n        }\n\t\t// 或者\n        window.addEventListener('resize', function() {\n\n        });\n    </script>\n</body>\n```\n\n​\t\t`window.onresize` 是调整窗口大小加载事件, 当触发时就调用的处理函数。\n\n​\t\t**注意：**\n\n- 只要窗口大小发生像素变化，就会触发这个事件。\n- 我们经常利用这个事件完成响应式布局。 window.innerWidth 当前屏幕的宽度。\n\n### 2.2.2、案例\n\n​\t\t需求：实现响应式。\n\n```html\n<head>\n    <style>\n        div {\n            width: 300px;\n            height: 300px;\n            background-color: blue;\n        }\n    </style>\n</head>\n<body>\n    <div></div>\n    <script>\n        // 1、获取div\n        var divObj = document.querySelector('div');\n\n        // 2、监听事件\n        window.addEventListener('resize', function() {\n            if (window.innerWidth < 800) {\n                divObj.style.display = 'none';\n            } else {\n                divObj.style.display = 'block';\n            }\n        });\n    </script>\n</body>\n```\n\n# 三、定时器\n\n## 3.1、概述\n\n​\t\twindow 对象给我们提供了 2 个非常好用的方法-定时器。\n\n-  setTimeout() \n-  setInterval() \n\n## 3.2、setTimeout() 定时器\n\n### 3.2.1、说明\n\n```markdown\n# 语法\n\t window.setTimeout(调用函数, [延迟的毫秒数]);\n# 含义\n\t1. 用于设置一个定时器，该定时器在定时器到期后执行调用函数。\n\t2. setTimeout() 这个调用函数我们也称为回调函数 callback，这个函数，需要等待时间，时间到了才去调用这个函数，因此称为回调函数。简单的说：回调，就是回头调用的意思。上一件事干完，再回头再调用这个函数。\n# 注意\n\t1. window 可以省略。\n\t2. 这个调用函数可以直接写函数，或者写函数名或者采取字符串‘函数名()'三种形式。第三种不推荐\n\t3. 延迟的毫秒数省略默认是 0，如果写，必须是毫秒。\n\t4. 因为定时器可能有很多，所以我们经常给定时器赋值一个标识符。\n```\n\n```html\n<body>\n    <script>\n        window.setTimeout(function() {\n            console.log('爆炸了...');\n        }, 2000);\n    </script>\n</body\n```\n\n```html\n<body>\n    <script>\n        function fn() {\n            console.log('要爆炸了....');\n        }\n\n        setTimeout(fn, 2000);\t// 函数名方式调用\n    </script>\n</body>\n```\n\n```html\n<body>\n    <script>\n        function fn() {\n            console.log('要爆炸了....');\n        }\n\n        setTimeout(\"fn()\", 2000);\t\t// 字符串形式调用\n    </script>\n</body>\n```\n\n```html\n<body>\n    <script>\n        function fn() {\n            console.log('要爆炸了....');\n        }\n\n        var timer1 = setTimeout(fn, 2000);\n        var timer2 = setTimeout(fn, 5000);\t\t// 设置一个标识\n    </script>\n</body>\n```\n\n### 3.2.2、案例\n\n​\t\t需求：5秒后关闭广告\n\n```html\n<head>\n    <style>\n        div {\n            width: 300px;\n            height: 300px;\n            background-color: blue;\n        }\n    </style>\n</head>\n<body>\n    <div>这个是一个广告,5秒后关闭</div>\n    <script>\n        // 获取div元素\n        var divObj = document.querySelector('div');\n        // 启动定时器5秒关闭\n        setTimeout(function() {\n            divObj.style.display = 'none';\n        }, 5000);\n    </script>\n</body>\n```\n\n### 3.2.3、停止setTimeout()定时器\n\n```markdown\n# 语法\n \twindow.clearTimeout(timeoutID)\t\n\n# 说明\n\t1. window可以省略\n\t2. 参数就是定时器的标识符 。\n```\n\n```html\n<body>\n    <button>停止定时器</button>\n    <script>\n        var btn = document.querySelector('button');\n        var timer = setTimeout(function() {\n            console.log('爆炸了');\n\n        }, 5000);\n        btn.addEventListener('click', function() {\n            clearTimeout(timer);\n        })\n    </script>\n</body>\n```\n\n## 3.3、 setInterval() 定时器\n\n### 3.3.1、说明\n\n```markdown\n# 语法\n\t window.setInterval(回调函数, [间隔的毫秒数]);\n\t \n# 含义\n\t重复调用回调函数，每隔指定时间，就去调用一次回调函数。\n\t\n# 注意：\n注意：\n\t1. window 可以省略。\n\t2. 这个调用函数可以直接写函数，或者写函数名或者采取字符串 '函数名()' 三种形式。\n\t3. 间隔的毫秒数省略默认是 0，如果写，必须是毫秒，表示每隔多少毫秒就自动调用这个函数。\n\t4. 因为定时器可能有很多，所以我们经常给定时器赋值一个标识符。 \n\t5. 第一次执行也是间隔毫秒数之后执行，之后每隔毫秒数就执行一次。\n```\n\n```html\n<body>\n    <script>\n        setInterval(function() {\n            console.log('爆炸...');\n        }, 2000);\n    </script>\n</body>\n```\n\n### 3.3.2、案例\n\n​\t\t需求：倒计时效果。\n\n![0102](/assets/JavaScript笔记/0102.png)\n\n```markdown\n# 思路\n\t1、这个倒计时是不断变化的，因此需要定时器来自动变化（setInterval） ② 三个黑色盒子里面分别存放时分秒\n\t2、三个黑色盒子利用innerHTML 放入计算的小时分钟秒数\n\t3、第一次执行也是间隔毫秒数，因此刚刷新页面会有空白\n\t4、最好采取封装函数的方式， 这样可以先调用一次这个函数，防止刚开始刷新页面有空白问题\n```\n\n```html\n<head>\n   \t<style>\n        span {\n            display: inline-block;\n            width: 40px;\n            height: 40px;\n            background-color: #333;\n            font-size: 20px;\n            color: #fff;\n            text-align: center;\n            line-height: 40px;\n        }\n    </style>\n</head>\n<body>\n    <div>\n        <span class=\"hour\">--</span>\n        <span class=\"minute\">--</span>\n        <span class=\"second\">--</span>\n    </div>\n    <script>\n        // 1、分别获取时分秒元素节点\n        var hour = document.querySelector('.hour'); // 小时的黑色盒子\n        var minute = document.querySelector('.minute'); // 分钟的黑色盒子\n        var second = document.querySelector('.second'); // 秒数的黑色盒子\n\n        var inputTime = +new Date('2021-10-17 16:00:00'); // 返回的是用户输入时间总的毫秒数\n        // 2、开启定时器\n        setInterval(countDown, 1000);\n\n        // 计算\n        function countDown() {\n            var nowTime = +new Date(); // 返回的是当前时间总的毫秒数\n            var times = (inputTime - nowTime) / 1000; // times是剩余时间总的秒数 \n            var h = parseInt(times / 60 / 60 % 24); //时\n            h = h < 10 ? '0' + h : h;\n            hour.innerHTML = h; // 把剩余的小时给 小时黑色盒子\n            var m = parseInt(times / 60 % 60); // 分\n            m = m < 10 ? '0' + m : m;\n            minute.innerHTML = m;\n            var s = parseInt(times % 60); // 当前的秒\n            s = s < 10 ? '0' + s : s;\n            second.innerHTML = s;\n        }\n    </script>\n</body>\n```\n\n### 3.3.3、停止 setInterval() 定时器\n\n```markdown\n# 语法\n\t window.clearInterval(intervalID);\n\t\n# 注意：\n\t1. window 可以省略。\n\t2. 里面的参数就是定时器的标识符 。\n```\n\n```html\n<body>\n    <button id=\"begin\">开启定时器</button>\n    <button id=\"stop\">结束定时器</button>\n    <script>\n        // 获取两个按钮\n        var beginObj = document.querySelector(\"#begin\");\n        var stopObj = document.querySelector(\"#stop\");\n\n        // 定义定时器标识符\n        var timer = null;\n\n        // 为开启定时器按钮绑定事件\n        beginObj.addEventListener('click', function() {\n            timer = setInterval(function() {\n                console.log('爆炸了....');\n            }, 2000);\n        });\n\n        // 为结束定时器绑定事件\n        stopObj.addEventListener('click', function() {\n            clearInterval(timer);\n        });\n    </script>\n</body>\n```\n\n## 3.4、案例2\n\n​\t\t需求：点击按钮后，该按钮60秒之内不能再次点击，防止重复发送短信\n\n```html\n<body>\n    手机号码： <input type=\"number\"><br/> <button>发送</button>\n    <script>\n        /**\n             思路:\n                  1、按钮点击之后，会禁用 disabled 为true \n                  2、同时按钮里面的内容会变化， 注意 button 里面的内容通过 innerHTML修改\n                  3、里面秒数是有变化的，因此需要用到定时器\n           \t      4、定义一个变量，在定时器里面，不断递减\n                  5、如果变量为0 说明到了时间，我们需要停止定时器，并且复原按钮初始状态\n        */\n        \n        // 0、定义倒计时总描述\n        var time = 5;\n        // 1、获取button\n        var btnObj = document.querySelector(\"button\");\n        // 2、绑定单机事件\n        btnObj.addEventListener('click', function() {\n            // >> 把按钮禁用\n            this.disabled = true;\n            // >> 启动定时器\n            var timer = setInterval(function() {\n                if (time == 0) {\n                    // 清除定时器\n                    clearInterval(timer);\n                    // 时间复原\n                    time = 5;\n                    // 按钮内容复原\n                    btnObj.innerHTML = \"发送\";\n                } else {\n                    btnObj.innerHTML = '还剩下' + time + '秒';\n                    time--;\n                }\n            }, 1000);\n        });\n    </script>\n</body>\n```\n\n## 3.5、总结\n\n```markdown\n1. setTimeout  延时时间到了，就去调用这个回调函数，只调用一次 就结束了这个定时器\n2. setInterval  每隔这个延时时间，就去调用这个回调函数，会调用很多次，重复调用这个函数\n```\n\n# 四、this的指向问题\n\n## 4.1、概述\n\n​\t\tthis的指向在函数定义的时候是确定不了的，只有函数执行的时候才能确定this到底指向谁，一般情况下this\n\n的最终指向的是那个调用它的对象。\n\n​\t\t现阶段，我们先了解一下几个this指向：\n\n- 情况一：全局作用域或者普通函数中this指向全局对象window（注意定时器里面的this指向window）\n- 情况二：方法调用中谁调用this指向谁\n- 情况三：构造函数中this指向构造函数的实例\n\n## 4.2、情况一\n\n```html\n<body>\n    <script>\n        // this的指向问题，情况一\n        // >> 全局作用域或者普通函数中this指向全局对象window（ 注意定时器里面的this指向window）\n\n        // >> 1、\n        console.log(this); // Window\n\n        // >> 2、\n        function fn() {\n            console.log(this);\n        }\n        window.fn(); // fn()函数是由window对象调用的,当然fn函数中的this就是window\n\n        // >> 3、\n        setTimeout(function() {\n            console.log(this);\n        }, 2000);\n    </script>\n</body>\n```\n\n## 4.3、情况二\n\n```html\n<body>\n    <button>点击我</button>\n    <script>\n        // this的指向问题，情况二\n        // >> 方法调用中谁调用this指向谁\n\n        // >> 1、\n        var person = {\n            run: function() {\n                console.log(this);\n            }\n        };\n        person.run();\n\n        // >> 2、\n        var btnObj = document.querySelector('button');\n        btnObj.addEventListener('click', function() {\n            console.log(this);\n        });\n    </script>\n</body>\n```\n\n## 4.4、情况三\n\n```html\n<body>\n    <script>\n        // this的指向问题，情况二\n        // >> 构造函数中this指向构造函数的实例\n\n        // >> 1、\n        function Person() {\n            console.log(this);\n        }\n        var p1 = new Person();\n    </script>\n</body>\n```\n\n## 4.5、总结\n\n```markdown\n# 目前阶段,this的指向就是：当前对象，即谁调用了我，我就指向谁。\n```\n\n# 五、js执行机制\n\n## 5.1、JS是单线程\n\n​\t\tJavaScript 语言的一大特点就是**单线程**，也就是说，同一个时间只能做一件事。这是因为 Javascript 这门脚\n\n本语言诞生的使命所致——JavaScript 是为处理页面中用户的交互，以及操作 DOM 而诞生的。比如我们对\n\n某个 DOM 元素进行添加和删除操作，不能同时进行。 应该先进行添加，之后再删除。\n\n​\t\t单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。这样所导致的问题是： 如果\n\nJS 执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞的感觉。\n\n## 5.2、同步和异步\n\n​\t\t为了解决这个问题，利用多核 CPU 的计算能力，HTML5 提出 Web Worker 标准，允许 JavaScript 脚本创\n\n建多个线程。于是，**JS 中出现了同步和异步**。\n\n- **同步**\n\n  ​\t\t前一个任务结束后再执行后一个任务，程序的执行顺序与任务的排列顺序是一致的、同步的。比如做饭的同步做法：我们要烧水煮饭，等水开了（10分钟之后），再去切菜，炒菜。\n\n- **异步**\n\n  ​\t\t你在做一件事情时，因为这件事情会花费很长时间，在做这件事的同时，你还可以去处理其他事情。比如做饭的异步做法，我们在烧水的同时，利用这10分钟，去切菜，炒菜。\n\n```markdown\n# 同步和异步的本质区别： 这条流水线上各个流程的执行顺序不同。\n```\n\n## 5.3、问题引入\n\n```html\n<body>\n    <script>\n        // 问题1: 执行顺序是什么\n        \n        console.log('1');\n\n        setTimeout(function() {\n            console.log('3');\n        }, 1000);\n\n        console.log('2');\n    </script>\n</body>\n```\n\n```html\n<body>\n    <script>\n        // 问题2: 执行顺序又是什么\n        \n        console.log('1');\n\n        setTimeout(function() {\n            console.log('3');\n        }, 0);\n\n        console.log('2');\n    </script>\n</body>\n```\n\n## 5.4、同步和异步深入\n\n### 5.4.1、同步任务\n\n​\t\t同步任务都在主线程上执行，形成一个**执行栈**。\n\n### 5.4.2、异步任务\n\n​\t\tJS 的异步是通过回调函数实现的。\n\n一般而言，异步任务有以下三种类型: \n\n1、普通事件，如 click、resize 等 \n\n2、资源加载，如 load、error 等 \n\n3、定时器，包括 setInterval、setTimeout 等\n\n异步任务相关回调函数添加到**任务队列**中（任务队列也称为消息队列）。\n\n### 5.4.3、图示\n\n![0103](/assets/JavaScript笔记/0103.png)\n\n### 5.4.4、案例解释\n\n![0104](/assets/JavaScript笔记/0104.png)\n\n## 5.5、执行机制\n\n1. 先执行执行栈中的同步任务。 \n\n2. 异步任务（回调函数）放入任务队列中。\n\n3. 一旦执行栈中的所有同步任务执行完毕，系统就会按次序读取任务队列中的异步任务，于是被读取的异步任\n\n务结束等待状态，进入执行栈，开始执行。\n\n![0105](/assets/JavaScript笔记/0105.png)\n\n## 5.6、案例\n\n```html\n<body>\n    <script>\n        // 多个异步任务\n        \n        console.log(1);\n        \n        document.onclick = function() {\n            console.log('click');\n        }\n        \n        console.log(2);\n        \n        setTimeout(function() {\n            console.log(3)\n        }, 5000)\n    </script>\n</body>\n```\n\n![0107](/assets/JavaScript笔记/0107.png)\n\n![0106](/assets/JavaScript笔记/0106.png)\n\n由于主线程不断的重复获得任务、执行任务、再获取任务、再执行，所以这种机制被称为事件循环（ event loop）。\n\n# 六、location 对象\n\n## 6.1、是什么\n\n​\t\twindow 对象给我们提供了一个 location 属性用于获取或设置窗体的 URL，并且可以用于解析 URL 。 因为\n\n这个属性返回的是一个对象，所以我们将这个属性也称为 location 对象。\n\n## 6.2、常用属性\n\n![0108](/assets/JavaScript笔记/0108.png)\n\n## 6.3、案例1\n\n​\t\t需求：5秒之后自动跳转到百度\n\n```html\n<body>\n    <div></div>\n    <script>\n        // 1、获取div\n        var divObj = document.querySelector(\"div\");\n\n        var time = 5;\n\n        setInterval(function() {\n            if (time == 0) {\n                window.location.href = \"https://www.baidu.com\";\n            } else {\n                divObj.innerHTML = \"将在\" + time + \"秒后自动跳转到百度...\";\n                time--;\n            }\n        }, 1000);\n    </script>\n</body>\n```\n\n## 6.4、常用方法\n\n![0109](/assets/JavaScript笔记/0109.png)\n\n```html\n<body>\n    <button>点击</button>\n    <script>\n        // 1、获取button\n        var buttonObj = document.querySelector(\"button\");\n\n        buttonObj.addEventListener('click', function() {\n            // 记录浏览历史，所以可以实现后退功能\n            window.location.assign('https://www.baidu.com');\\\n            // 不记录浏览历史，所以不可以实现后退功能\n            //window.location.replace('http://www.itcast.cn');\n\n            //location.reload(true);\n        });\n    </script>\n</body>\n```\n\n# 七、history 对象 \n\n## 7.1、是什么\n\n​\t\twindow 对象给我们提供了一个 history 对象，与浏览器历史记录进行交互。该对象包含用户（在浏览器窗口中）访问过的 URL。\n\n![0110](/assets/JavaScript笔记/0110.png)\n\n---\ntypora-root-url: images\n---\n\n# 一、概述\n\n## 1.1、什么是BOM\n\n​\t\tBOM（Browser Object Model）即**浏览器对象模型**，它提供了独立于内容而与浏览器窗口进行交互的对象，其核心对象是 window。\n\n​\t\tBOM 由一系列相关的对象构成，并且每个对象都提供了很多方法与属性。\n\n​\t\tBOM 缺乏标准，JavaScript 语法的标准化组织是 ECMA，DOM 的标准化组织是 W3C，BOM 最初是Netscape 浏览器标准的一部分。\n\n![0099](/assets/JavaScript笔记/0099.png)\n\n## 1.2、BOM的构成\n\n​\t\tBOM 比 DOM 更大，它包含 DOM。\n\n![0100](/assets/JavaScript笔记/0100.png)\n\n​\t\t**window 对象是浏览器的顶级对象，**它具有双重角色。\n\n- 它是 JS 访问浏览器窗口的一个接口。\n- **它是一个全局对象。定义在全局作用域中的变量、函数都会变成 window 对象的属性和方法。**\n- 在调用的时候可以省略 window，前面学习的对话框都属于 window 对象方法，如 alert()、prompt() 等。\n- **注意：**window下的一个特殊属性 window.name，定义变量名最好要避开 name 这个变量名。\n\n```html\n<body>\n    <script>\n        // 定义全局变量\n        var a = 10;\n        console.log(a);\n        console.log(window.a);\n\n        // 定义全局函数\n        function aFn() {\n            console.log('全局函数');\n        }\n        aFn();\n        window.aFn();\n    </script>\n</body>\n```\n\n![0101](/assets/JavaScript笔记/0101.png)\n\n# 二、window 对象的常见事件\n\n## 2.1、窗口加载事件\n\n### 2.1.1、概述\n\n```html\n<script>\n    window.onload = function() {\n\n    };\n\t// 或者\n    window.addEventListener('load', function() {\n\n    });\n</script>\n```\n\n​\t\t`window.onload` 是窗口 (页面）加载事件，当文档内容完全加载完成才会触发该事件(包括图像、脚本文件、CSS 文件等)，从而完成对事件处理函数的调用。\n\n​\t\t**注意：**\n\n- 有了 `window.onload` 就可以把 JS 代码写到页面元素的上方，因为 onload 是等页面内容全部加载完毕， \n\n  再去执行处理函数。\n\n- `window.onload` 传统注册事件方式 只能写一次，如果有多个，会以最后一个 `window.onload` 为准。\n\n- 如果使用 `addEventListener` 则没有限制\n\n### 2.1.2、案例1\n\n```html\n<body>\n    <script>\n        window.onload = function() {\n            console.log('页面加载完毕');\n        };\n        window.onload = function() {\n            console.log('页面加载完毕....');\n        };\n\n        // 传统方式只能写一次,如果多次,后面的覆盖前面的\n    </script>\n</body>\n```\n\n### 2.1.3、案例2\n\n```html\n<body>\n    <script>\n        window.addEventListener('load', function() {\n            console.log(\"页面加载完毕\");\n        });\n\n        window.addEventListener('load', function() {\n            console.log(\"页面加载完毕...\");\n        });\n\n        // addEventListener 可以写多次\n    </script>\n</body>\n```\n\n### 2.1.4、DOMContentLoaded\n\n```java\nwindow.addEventListener('DOMContentLoaded', function() {});\n```\n\n​\t\t`DOMContentLoaded` 事件触发时，仅当DOM加载完成，不包括样式表，图片，flash等等。\n\n​\t\tIe9以上才支持。\n\n​\t\t如果页面的图片很多的话, 从用户访问到onload触发可能需要较长的时间, 交互效果就不能实现，必然影响用\n\n户的体验，此时用 DOMContentLoaded 事件比较合适。\n\n## 2.2、调整窗口大小事件\n\n### 2.2.1、概述\n\n```html\n<body>\n    <script>\n        window.onresize = function() {\n\n        }\n\t\t// 或者\n        window.addEventListener('resize', function() {\n\n        });\n    </script>\n</body>\n```\n\n​\t\t`window.onresize` 是调整窗口大小加载事件, 当触发时就调用的处理函数。\n\n​\t\t**注意：**\n\n- 只要窗口大小发生像素变化，就会触发这个事件。\n- 我们经常利用这个事件完成响应式布局。 window.innerWidth 当前屏幕的宽度。\n\n### 2.2.2、案例\n\n​\t\t需求：实现响应式。\n\n```html\n<head>\n    <style>\n        div {\n            width: 300px;\n            height: 300px;\n            background-color: blue;\n        }\n    </style>\n</head>\n<body>\n    <div></div>\n    <script>\n        // 1、获取div\n        var divObj = document.querySelector('div');\n\n        // 2、监听事件\n        window.addEventListener('resize', function() {\n            if (window.innerWidth < 800) {\n                divObj.style.display = 'none';\n            } else {\n                divObj.style.display = 'block';\n            }\n        });\n    </script>\n</body>\n```\n\n# 三、定时器\n\n## 3.1、概述\n\n​\t\twindow 对象给我们提供了 2 个非常好用的方法-定时器。\n\n-  setTimeout() \n-  setInterval() \n\n## 3.2、setTimeout() 定时器\n\n### 3.2.1、说明\n\n```markdown\n# 语法\n\t window.setTimeout(调用函数, [延迟的毫秒数]);\n# 含义\n\t1. 用于设置一个定时器，该定时器在定时器到期后执行调用函数。\n\t2. setTimeout() 这个调用函数我们也称为回调函数 callback，这个函数，需要等待时间，时间到了才去调用这个函数，因此称为回调函数。简单的说：回调，就是回头调用的意思。上一件事干完，再回头再调用这个函数。\n# 注意\n\t1. window 可以省略。\n\t2. 这个调用函数可以直接写函数，或者写函数名或者采取字符串‘函数名()'三种形式。第三种不推荐\n\t3. 延迟的毫秒数省略默认是 0，如果写，必须是毫秒。\n\t4. 因为定时器可能有很多，所以我们经常给定时器赋值一个标识符。\n```\n\n```html\n<body>\n    <script>\n        window.setTimeout(function() {\n            console.log('爆炸了...');\n        }, 2000);\n    </script>\n</body\n```\n\n```html\n<body>\n    <script>\n        function fn() {\n            console.log('要爆炸了....');\n        }\n\n        setTimeout(fn, 2000);\t// 函数名方式调用\n    </script>\n</body>\n```\n\n```html\n<body>\n    <script>\n        function fn() {\n            console.log('要爆炸了....');\n        }\n\n        setTimeout(\"fn()\", 2000);\t\t// 字符串形式调用\n    </script>\n</body>\n```\n\n```html\n<body>\n    <script>\n        function fn() {\n            console.log('要爆炸了....');\n        }\n\n        var timer1 = setTimeout(fn, 2000);\n        var timer2 = setTimeout(fn, 5000);\t\t// 设置一个标识\n    </script>\n</body>\n```\n\n### 3.2.2、案例\n\n​\t\t需求：5秒后关闭广告\n\n```html\n<head>\n    <style>\n        div {\n            width: 300px;\n            height: 300px;\n            background-color: blue;\n        }\n    </style>\n</head>\n<body>\n    <div>这个是一个广告,5秒后关闭</div>\n    <script>\n        // 获取div元素\n        var divObj = document.querySelector('div');\n        // 启动定时器5秒关闭\n        setTimeout(function() {\n            divObj.style.display = 'none';\n        }, 5000);\n    </script>\n</body>\n```\n\n### 3.2.3、停止setTimeout()定时器\n\n```markdown\n# 语法\n \twindow.clearTimeout(timeoutID)\t\n\n# 说明\n\t1. window可以省略\n\t2. 参数就是定时器的标识符 。\n```\n\n```html\n<body>\n    <button>停止定时器</button>\n    <script>\n        var btn = document.querySelector('button');\n        var timer = setTimeout(function() {\n            console.log('爆炸了');\n\n        }, 5000);\n        btn.addEventListener('click', function() {\n            clearTimeout(timer);\n        })\n    </script>\n</body>\n```\n\n## 3.3、 setInterval() 定时器\n\n### 3.3.1、说明\n\n```markdown\n# 语法\n\t window.setInterval(回调函数, [间隔的毫秒数]);\n\t \n# 含义\n\t重复调用回调函数，每隔指定时间，就去调用一次回调函数。\n\t\n# 注意：\n注意：\n\t1. window 可以省略。\n\t2. 这个调用函数可以直接写函数，或者写函数名或者采取字符串 '函数名()' 三种形式。\n\t3. 间隔的毫秒数省略默认是 0，如果写，必须是毫秒，表示每隔多少毫秒就自动调用这个函数。\n\t4. 因为定时器可能有很多，所以我们经常给定时器赋值一个标识符。 \n\t5. 第一次执行也是间隔毫秒数之后执行，之后每隔毫秒数就执行一次。\n```\n\n```html\n<body>\n    <script>\n        setInterval(function() {\n            console.log('爆炸...');\n        }, 2000);\n    </script>\n</body>\n```\n\n### 3.3.2、案例\n\n​\t\t需求：倒计时效果。\n\n![0102](/assets/JavaScript笔记/0102.png)\n\n```markdown\n# 思路\n\t1、这个倒计时是不断变化的，因此需要定时器来自动变化（setInterval） ② 三个黑色盒子里面分别存放时分秒\n\t2、三个黑色盒子利用innerHTML 放入计算的小时分钟秒数\n\t3、第一次执行也是间隔毫秒数，因此刚刷新页面会有空白\n\t4、最好采取封装函数的方式， 这样可以先调用一次这个函数，防止刚开始刷新页面有空白问题\n```\n\n```html\n<head>\n   \t<style>\n        span {\n            display: inline-block;\n            width: 40px;\n            height: 40px;\n            background-color: #333;\n            font-size: 20px;\n            color: #fff;\n            text-align: center;\n            line-height: 40px;\n        }\n    </style>\n</head>\n<body>\n    <div>\n        <span class=\"hour\">--</span>\n        <span class=\"minute\">--</span>\n        <span class=\"second\">--</span>\n    </div>\n    <script>\n        // 1、分别获取时分秒元素节点\n        var hour = document.querySelector('.hour'); // 小时的黑色盒子\n        var minute = document.querySelector('.minute'); // 分钟的黑色盒子\n        var second = document.querySelector('.second'); // 秒数的黑色盒子\n\n        var inputTime = +new Date('2021-10-17 16:00:00'); // 返回的是用户输入时间总的毫秒数\n        // 2、开启定时器\n        setInterval(countDown, 1000);\n\n        // 计算\n        function countDown() {\n            var nowTime = +new Date(); // 返回的是当前时间总的毫秒数\n            var times = (inputTime - nowTime) / 1000; // times是剩余时间总的秒数 \n            var h = parseInt(times / 60 / 60 % 24); //时\n            h = h < 10 ? '0' + h : h;\n            hour.innerHTML = h; // 把剩余的小时给 小时黑色盒子\n            var m = parseInt(times / 60 % 60); // 分\n            m = m < 10 ? '0' + m : m;\n            minute.innerHTML = m;\n            var s = parseInt(times % 60); // 当前的秒\n            s = s < 10 ? '0' + s : s;\n            second.innerHTML = s;\n        }\n    </script>\n</body>\n```\n\n### 3.3.3、停止 setInterval() 定时器\n\n```markdown\n# 语法\n\t window.clearInterval(intervalID);\n\t\n# 注意：\n\t1. window 可以省略。\n\t2. 里面的参数就是定时器的标识符 。\n```\n\n```html\n<body>\n    <button id=\"begin\">开启定时器</button>\n    <button id=\"stop\">结束定时器</button>\n    <script>\n        // 获取两个按钮\n        var beginObj = document.querySelector(\"#begin\");\n        var stopObj = document.querySelector(\"#stop\");\n\n        // 定义定时器标识符\n        var timer = null;\n\n        // 为开启定时器按钮绑定事件\n        beginObj.addEventListener('click', function() {\n            timer = setInterval(function() {\n                console.log('爆炸了....');\n            }, 2000);\n        });\n\n        // 为结束定时器绑定事件\n        stopObj.addEventListener('click', function() {\n            clearInterval(timer);\n        });\n    </script>\n</body>\n```\n\n## 3.4、案例2\n\n​\t\t需求：点击按钮后，该按钮60秒之内不能再次点击，防止重复发送短信\n\n```html\n<body>\n    手机号码： <input type=\"number\"><br/> <button>发送</button>\n    <script>\n        /**\n             思路:\n                  1、按钮点击之后，会禁用 disabled 为true \n                  2、同时按钮里面的内容会变化， 注意 button 里面的内容通过 innerHTML修改\n                  3、里面秒数是有变化的，因此需要用到定时器\n           \t      4、定义一个变量，在定时器里面，不断递减\n                  5、如果变量为0 说明到了时间，我们需要停止定时器，并且复原按钮初始状态\n        */\n        \n        // 0、定义倒计时总描述\n        var time = 5;\n        // 1、获取button\n        var btnObj = document.querySelector(\"button\");\n        // 2、绑定单机事件\n        btnObj.addEventListener('click', function() {\n            // >> 把按钮禁用\n            this.disabled = true;\n            // >> 启动定时器\n            var timer = setInterval(function() {\n                if (time == 0) {\n                    // 清除定时器\n                    clearInterval(timer);\n                    // 时间复原\n                    time = 5;\n                    // 按钮内容复原\n                    btnObj.innerHTML = \"发送\";\n                } else {\n                    btnObj.innerHTML = '还剩下' + time + '秒';\n                    time--;\n                }\n            }, 1000);\n        });\n    </script>\n</body>\n```\n\n## 3.5、总结\n\n```markdown\n1. setTimeout  延时时间到了，就去调用这个回调函数，只调用一次 就结束了这个定时器\n2. setInterval  每隔这个延时时间，就去调用这个回调函数，会调用很多次，重复调用这个函数\n```\n\n# 四、this的指向问题\n\n## 4.1、概述\n\n​\t\tthis的指向在函数定义的时候是确定不了的，只有函数执行的时候才能确定this到底指向谁，一般情况下this\n\n的最终指向的是那个调用它的对象。\n\n​\t\t现阶段，我们先了解一下几个this指向：\n\n- 情况一：全局作用域或者普通函数中this指向全局对象window（注意定时器里面的this指向window）\n- 情况二：方法调用中谁调用this指向谁\n- 情况三：构造函数中this指向构造函数的实例\n\n## 4.2、情况一\n\n```html\n<body>\n    <script>\n        // this的指向问题，情况一\n        // >> 全局作用域或者普通函数中this指向全局对象window（ 注意定时器里面的this指向window）\n\n        // >> 1、\n        console.log(this); // Window\n\n        // >> 2、\n        function fn() {\n            console.log(this);\n        }\n        window.fn(); // fn()函数是由window对象调用的,当然fn函数中的this就是window\n\n        // >> 3、\n        setTimeout(function() {\n            console.log(this);\n        }, 2000);\n    </script>\n</body>\n```\n\n## 4.3、情况二\n\n```html\n<body>\n    <button>点击我</button>\n    <script>\n        // this的指向问题，情况二\n        // >> 方法调用中谁调用this指向谁\n\n        // >> 1、\n        var person = {\n            run: function() {\n                console.log(this);\n            }\n        };\n        person.run();\n\n        // >> 2、\n        var btnObj = document.querySelector('button');\n        btnObj.addEventListener('click', function() {\n            console.log(this);\n        });\n    </script>\n</body>\n```\n\n## 4.4、情况三\n\n```html\n<body>\n    <script>\n        // this的指向问题，情况二\n        // >> 构造函数中this指向构造函数的实例\n\n        // >> 1、\n        function Person() {\n            console.log(this);\n        }\n        var p1 = new Person();\n    </script>\n</body>\n```\n\n## 4.5、总结\n\n```markdown\n# 目前阶段,this的指向就是：当前对象，即谁调用了我，我就指向谁。\n```\n\n# 五、js执行机制\n\n## 5.1、JS是单线程\n\n​\t\tJavaScript 语言的一大特点就是**单线程**，也就是说，同一个时间只能做一件事。这是因为 Javascript 这门脚\n\n本语言诞生的使命所致——JavaScript 是为处理页面中用户的交互，以及操作 DOM 而诞生的。比如我们对\n\n某个 DOM 元素进行添加和删除操作，不能同时进行。 应该先进行添加，之后再删除。\n\n​\t\t单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。这样所导致的问题是： 如果\n\nJS 执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞的感觉。\n\n## 5.2、同步和异步\n\n​\t\t为了解决这个问题，利用多核 CPU 的计算能力，HTML5 提出 Web Worker 标准，允许 JavaScript 脚本创\n\n建多个线程。于是，**JS 中出现了同步和异步**。\n\n- **同步**\n\n  ​\t\t前一个任务结束后再执行后一个任务，程序的执行顺序与任务的排列顺序是一致的、同步的。比如做饭的同步做法：我们要烧水煮饭，等水开了（10分钟之后），再去切菜，炒菜。\n\n- **异步**\n\n  ​\t\t你在做一件事情时，因为这件事情会花费很长时间，在做这件事的同时，你还可以去处理其他事情。比如做饭的异步做法，我们在烧水的同时，利用这10分钟，去切菜，炒菜。\n\n```markdown\n# 同步和异步的本质区别： 这条流水线上各个流程的执行顺序不同。\n```\n\n## 5.3、问题引入\n\n```html\n<body>\n    <script>\n        // 问题1: 执行顺序是什么\n        \n        console.log('1');\n\n        setTimeout(function() {\n            console.log('3');\n        }, 1000);\n\n        console.log('2');\n    </script>\n</body>\n```\n\n```html\n<body>\n    <script>\n        // 问题2: 执行顺序又是什么\n        \n        console.log('1');\n\n        setTimeout(function() {\n            console.log('3');\n        }, 0);\n\n        console.log('2');\n    </script>\n</body>\n```\n\n## 5.4、同步和异步深入\n\n### 5.4.1、同步任务\n\n​\t\t同步任务都在主线程上执行，形成一个**执行栈**。\n\n### 5.4.2、异步任务\n\n​\t\tJS 的异步是通过回调函数实现的。\n\n一般而言，异步任务有以下三种类型: \n\n1、普通事件，如 click、resize 等 \n\n2、资源加载，如 load、error 等 \n\n3、定时器，包括 setInterval、setTimeout 等\n\n异步任务相关回调函数添加到**任务队列**中（任务队列也称为消息队列）。\n\n### 5.4.3、图示\n\n![0103](/assets/JavaScript笔记/0103.png)\n\n### 5.4.4、案例解释\n\n![0104](/assets/JavaScript笔记/0104.png)\n\n## 5.5、执行机制\n\n1. 先执行执行栈中的同步任务。 \n\n2. 异步任务（回调函数）放入任务队列中。\n\n3. 一旦执行栈中的所有同步任务执行完毕，系统就会按次序读取任务队列中的异步任务，于是被读取的异步任\n\n务结束等待状态，进入执行栈，开始执行。\n\n![0105](/assets/JavaScript笔记/0105.png)\n\n## 5.6、案例\n\n```html\n<body>\n    <script>\n        // 多个异步任务\n        \n        console.log(1);\n        \n        document.onclick = function() {\n            console.log('click');\n        }\n        \n        console.log(2);\n        \n        setTimeout(function() {\n            console.log(3)\n        }, 5000)\n    </script>\n</body>\n```\n\n![0107](/assets/JavaScript笔记/0107.png)\n\n![0106](/assets/JavaScript笔记/0106.png)\n\n由于主线程不断的重复获得任务、执行任务、再获取任务、再执行，所以这种机制被称为事件循环（ event loop）。\n\n# 六、location 对象\n\n## 6.1、是什么\n\n​\t\twindow 对象给我们提供了一个 location 属性用于获取或设置窗体的 URL，并且可以用于解析 URL 。 因为\n\n这个属性返回的是一个对象，所以我们将这个属性也称为 location 对象。\n\n## 6.2、常用属性\n\n![0108](/assets/JavaScript笔记/0108.png)\n\n## 6.3、案例1\n\n​\t\t需求：5秒之后自动跳转到百度\n\n```html\n<body>\n    <div></div>\n    <script>\n        // 1、获取div\n        var divObj = document.querySelector(\"div\");\n\n        var time = 5;\n\n        setInterval(function() {\n            if (time == 0) {\n                window.location.href = \"https://www.baidu.com\";\n            } else {\n                divObj.innerHTML = \"将在\" + time + \"秒后自动跳转到百度...\";\n                time--;\n            }\n        }, 1000);\n    </script>\n</body>\n```\n\n## 6.4、常用方法\n\n![0109](/assets/JavaScript笔记/0109.png)\n\n```html\n<body>\n    <button>点击</button>\n    <script>\n        // 1、获取button\n        var buttonObj = document.querySelector(\"button\");\n\n        buttonObj.addEventListener('click', function() {\n            // 记录浏览历史，所以可以实现后退功能\n            window.location.assign('https://www.baidu.com');\\\n            // 不记录浏览历史，所以不可以实现后退功能\n            //window.location.replace('http://www.itcast.cn');\n\n            //location.reload(true);\n        });\n    </script>\n</body>\n```\n\n# 七、history 对象 \n\n## 7.1、是什么\n\n​\t\twindow 对象给我们提供了一个 history 对象，与浏览器历史记录进行交互。该对象包含用户（在浏览器窗口中）访问过的 URL。\n\n![0110](/assets/JavaScript笔记/0110.png)\n\n","tags":["JavaScript","学习笔记"],"categories":["JavaScript笔记"]},{"title":"JavaScript笔记-06事件","url":"/2023/05/26/JavaScript笔记-06事件/","content":"\n\n\n# 一、事件高级内容\n\n## 1.1、注册事件/绑定事件\n\n### 1.1.1、概述\n\n```markdown\n1. 给元素添加事件，称为【注册事件】或者【绑定事件】。\n2. 注册事件有两种方式：【传统方式】和【方法监听注册方式】。\n```\n\n![0090](/assets/JavaScript笔记/0090.png)\n\n### 1.1.2、传统注册方式\n\n```html\n<body>\n    <button>点击</button>\n    <script>\n        // 1. 获取button按钮\n        var btnObj = document.querySelector(\"button\");\n\n        // 2、传统注册方式\n        btnObj.onclick = function() {\n            alert('HelloWorld');\n        }\n\n        btnObj.onclick = function() {\n            alert('JavaScript');\n        }\n\n        // 结论: 同一个元素节点同一个事件只能设置一个处理函数\n    </script>\n</body>\n```\n\n### 1.1.3、方法监听注册方式\n\n```markdown\n# 语法\n\teventTarget.addEventListener(type, listener[, useCapture])\n\t该方法将指定的监听器注册到 eventTarget（目标对象）上，当该对象触发指定的事件时，就会执行事件处理函数。\n\n# 说明\n\t1. type：事件类型字符串，比如 click 、mouseover ，注意这里不要带 on\n\t2. listener：事件处理函数，事件发生时，会调用该监听函数\n\t3. useCapture：可选参数，是一个布尔值，默认是 false。以后再说。\n```\n\n```html\n<body>\n    <button>点击</button>\n    <script>\n        // 1. 获取button按钮\n        var btnObj = document.querySelector(\"button\");\n\n        // 2、方法监听注册方式\n        btnObj.addEventListener('click', function() {\n            alert('HelloWorld');\n        });\n\n        btnObj.addEventListener('click', function() {\n            alert('JavaScript');\n        })\n\n        // 结论: 同一个元素节点同一个事件可以指定多个事件处理程序。\n    </script>\n</body>\n```\n\n### 1.1.4、attachEvent事件监听方式\n\n```markdown\n# 语法\n\teventTarget.attachEvent(eventNameWithOn, callback)\n\t该方法将指定的监听器注册到eventTarget（目标对象）上，当该对象触发指定的事件时，指定的回调函数就会被执行\n\t\n# 说明\n\t1. eventNameWithOn：事件类型字符串，比如 onclick 、onmouseover ，这里要带 on\n\t2. callback： 事件处理函数，当目标触发事件时回调函数被调用\n\t\n# 注意\n\t1. IE8 及早期版本支持，新版本不支持\n```\n\n```html\n<body>\n    <button>点击</button>\n    <script>\n        // 1. 获取button按钮\n        var btnObj = document.querySelector(\"button\");\n\n        // 2、方法监听注册方式\n        btnObj.attachEvent(\"onclick\", function() {\n            alert('HelloWorld');\n        });\n\n        btnObj.attachEvent(\"onclick\", function() {\n            alert('JavaScript');\n        });\n\n        // 结论: 同一个元素节点同一个事件可以指定多个事件处理程序。不过此种方式是IE8以前提供的方式。\n    </script>\n</body>\n```\n\n![0091](/assets/JavaScript笔记/0091.png)\n\n## 1.2、删除事件/解绑事件\n\n### 1.2.1、概述\n\n```markdown\n# 传统方式\n\teventTarget.onclick = null;\n\t\n# 方法监听注册方式\n\t1. eventTarget.removeEventListener(type, listener[, useCapture]);\n\t2. eventTarget.detachEvent(eventNameWithOn, callback); // 存在兼容性问题,I8及之前才有效。\n```\n\n### 1.2.2、传统方式\n\n```html\n<body>\n    <button id=\"btn1\">传统方式绑定事件</button>\n    <button id=\"btn2\">传统方式解绑事件</button>\n    <script>\n        // 1. 获取button按钮\n        var btn1Obj = document.querySelector(\"#btn1\");\n        btn1Obj.onclick = function() {\n            alert('HelloWorld');\n        }\n\n        // 2、解绑按钮\n        var btn2Obj = document.querySelector(\"#btn2\");\n        btn2Obj.onclick = function() {\n            btn1Obj.onclick = null;\n        }\n    </script>\n</body>\n```\n\n### 1.2.3、方法监听方式\n\n```html\n<body>\n    <button id=\"btn1\">方法监听方式绑定事件</button>\n    <button id=\"btn2\">方法监听方式解绑事件</button>\n    <script>\n        // 1. 获取button按钮\n        var btn1Obj = document.querySelector(\"#btn1\");\n        btn1Obj.addEventListener('click', fn1);\n\n        function fn1() {\n            alert('JavaScript');\n        }\n\n        // 2、解绑按钮\n        var btn2Obj = document.querySelector(\"#btn2\");\n        btn2Obj.onclick = function() {\n            btn1Obj.removeEventListener('click', fn1); // 需要指定事件处理函数名称\n        }\n    </script>\n</body>\n```\n\n# 二、DOM事件流\n\n## 2.1、概述\n\n​\t\t**事件流**描述的是从页面中接收事件的顺序。\n\n​\t\t**事件**发生时会在元素节点之间按照特定的顺序传播，这个**传播过程**即 DOM 事件流。\n\n​\t\t比如我们给一个div 注册了点击事件，那么这个传播过程是这样的：\n\n- 1. 捕获阶段\n- 2. 当前目标阶段\n- 3. 冒泡阶段\n\n![0092](/assets/JavaScript笔记/0092.png)\n\n```markdown\n1. 事件冒泡： IE 最早提出，事件开始时由最具体的元素接收，然后逐级向上传播到到 DOM 最顶层节点的过程。\n2. 事件捕获： 网景最早提出，由 DOM 最顶层节点开始，然后逐级向下传播到到最具体的元素接收的过程。\n```\n\n## 2.2、通俗理解\n\n​\t\t我们向水里面扔一块石头，首先它会有一个下降的过程，这个过程就可以理解为从最顶层向事件发生的最具\n\n体元素（目标点）的捕获过程；之后会产生泡泡，会在最低点（ 最具体元素）之后漂浮到水面上，这个过\n\n程相当于事件冒泡。\n\n![0093](/assets/JavaScript笔记/0093.png)\n\n## 2.3、注意点\n\n- JS 代码中只能执行捕获或者冒泡其中的一个阶段。\n- onclick 和 attachEvent 只能得到冒泡阶段。\n- addEventListener(type, listener[, useCapture])第三个参数如果是 true，表示在事件捕获阶段调用事件处理程序；如果是 false（不写默认就是false），表示在事件冒泡阶段调用事件处理程序。\n- ==**实际开发中我们很少使用事件捕获，我们更关注事件冒泡。**==\n- ==**有些事件是没有冒泡的，比如 onblur、onfocus、onmouseenter、onmouseleave**==\n- 事件冒泡有时候会带来麻烦，有时候又会帮助很巧妙的做某些事件，我们后面讲解。\n\n## 2.4、案例1\n\n```html\n<head>\n    <style>\n        #div1 {\n            width: 300px;\n            height: 300px;\n            background-color: red;\n        }\n        \n        #div2 {\n            width: 200px;\n            height: 200px;\n            background-color: blue;\n        }\n        \n        #div3 {\n            width: 100px;\n            height: 100px;\n            background-color: skyblue;\n        }\n    </style>\n</head>\n<body>\n    <div id=\"div1\">\n        <div id=\"div2\">\n            <div id=\"div3\"></div>\n        </div>\n    </div>\n    <script>\n        // 测试 onclick 只能是得到冒泡阶段\n        \n        // 1. 获取div1\n        var div1 = document.querySelector(\"#div1\");\n        div1.onclick = function() {\n            alert('div1');\n        }\n\n        // 2. 获取div2\n        var div2 = document.querySelector(\"#div2\");\n        div2.onclick = function() {\n            alert('div2');\n        }\n\n        // 3. 获取div3\n        var div3 = document.querySelector(\"#div3\");\n        div3.onclick = function() {\n            alert('div3');\n        }\n    </script>\n</body>\n```\n\n## 2.5、案例2\n\n```html\n<body>\n    <div id=\"div1\">\n        <div id=\"div2\">\n            <div id=\"div3\"></div>\n        </div>\n    </div>\n    <script>\n        // 测试 addEventListener ，第三个参数不写,或者为false，则是冒泡阶段\n        \n        // 1. 获取div1\n        var div1 = document.querySelector(\"#div1\");\n        div1.addEventListener('click', function() {\n            alert(\"div1\");\n        });\n\n        // 2. 获取div2\n        var div2 = document.querySelector(\"#div2\");\n        div2.addEventListener('click', function() {\n            alert(\"div2\");\n        });\n\n        // 3. 获取div3\n        var div3 = document.querySelector(\"#div3\");\n        div3.addEventListener('click', function() {\n            alert(\"div3\");\n        });\n    </script>\n</body>\n```\n\n## 2.6、案例3\n\n```html\n<body>\n    <div id=\"div1\">\n        <div id=\"div2\">\n            <div id=\"div3\"></div>\n        </div>\n    </div>\n    <script>\n        // 测试 addEventListener ，第三个参数为true，则是捕获阶段\n        \n        // 1. 获取div1\n        var div1 = document.querySelector(\"#div1\");\n        div1.addEventListener('click', function() {\n            alert(\"div1\");\n        }, true);\n\n        // 2. 获取div2\n        var div2 = document.querySelector(\"#div2\");\n        div2.addEventListener('click', function() {\n            alert(\"div2\");\n        }, true);\n\n        // 3. 获取div3\n        var div3 = document.querySelector(\"#div3\");\n        div3.addEventListener('click', function() {\n            alert(\"div3\");\n        }, true);\n    </script>\n</body>\n```\n\n# 三、事件对象\n\n## 3.1、什么是事件对象\n\n```javascript\neventTarget.onclick = function(event) {\n    // 这个 event 就是事件对象，我们还喜欢的写成 e 或者 evt\n}\n\neventTarget.addEventListener('click', function(event) {\n    // 这个 event 就是事件对象，我们还喜欢的写成 e 或者 evt\n})\n// 这个 event 就是事件对象，我们还喜欢的写成 e 或者 evt\n```\n\n```markdown\n# 官方解释\n\tevent 对象代表事件的状态，比如键盘按键的状态、鼠标的位置、鼠标按钮的状态。\n\t\n# 通俗理解\n\t事件发生后，跟事件相关的一系列信息数据的集合都放到这个对象里面，这个对象就是事件对象event，它有很多属性和方法。\n\t例如：\n\t1. 谁绑定了这个事件。\n\t2. 鼠标触发事件的话，会得到鼠标的相关信息，如鼠标位置。\n\t3. 键盘触发事件的话，会得到键盘的相关信息，如按了哪个键。\n\t\n# 注意点\n\t事件对象本身的获取存在兼容问题：\n\t1. 标准浏览器中是浏览器给方法传递的参数，只需要定义形参 event 就可以获取到。\n\t2. 在 IE6~8 中，浏览器不会给方法传递参数，如果需要的话，需要到 window.event 中获取查找。\n\t\n\t解决兼容性问题：\n\tevent = event || window.event;\n```\n\n```html\n<body>\n    <div>HelloWorld</div>\n    <script>\n        // 获取div\n        var divObj = document.querySelector('div');\n\n        // 传统方式绑定事件\n        divObj.onclick = function(event) {\n            event = event || window.event; // 兼容性的写法\n            console.log(event);\n        }\n\n        // 方法监听方式绑定事件\n        divObj.addEventListener('click', function(event) {\n            console.log(event);\n        });\n    </script>\n</body>\n```\n\n## 3.2、e.target 和 this 的区别\n\n### 3.2.1、案例1\n\n```html\n<body>\n    <div>HelloWorld</div>\n    <script>\n        // 常见事件对象的属性和方法\n        // >> e.target和this的区别\n\n        var divObj = document.querySelector(\"div\");\n\n        divObj.addEventListener('click', function(event) {\n            console.log(this);\n            console.log(event.target);\n        })\n        \n        // 总结：貌似没区别，在看案例2\n    </script>\n</body>\n```\n\n### 3.2.2、案例2\n\n```html\n<body>\n    <ul>\n        <li>高圆圆</li>\n        <li>贾静雯</li>\n        <li>赵敏</li>\n    </ul>\n    <script>\n        // 常见事件对象的属性和方法\n        // >> e.target和this的区别\n\n        var ulObj = document.querySelector(\"ul\");\n\n        // 给ul标签节点绑定单击事件\n        ulObj.addEventListener('click', function(event) {\n            console.log(this); // ul\n            console.log(event.target); // li\n        })\n        \n        // 总结\n        // >> e.target 指向我们点击的那个对象 谁触发了这个事件 我们点击的是li e.target 指向的就是li\n        // >> this : 我们给ul 绑定了事件  那么this 就指向ul  \n        \n        // 精髓总结\n        // >> e.target：点击了哪个元素，就返回哪个元素 \n        // >  this: 哪个元素绑定了这个点击事件，那么就返回谁\n    </script>\n</body>\n```\n\n### 3.2.3、案例3\n\n```html\n<body>\n    <ul>\n        <li>高圆圆</li>\n        <li>贾静雯</li>\n        <li>赵敏</li>\n    </ul>\n    <script>\n        // 常见事件对象的属性和方法\n        // >> e.target和this的区别\n\n        var ulObj = document.querySelector(\"ul\");\n\n        // 给ul标签节点绑定单击事件\n        ulObj.addEventListener('click', function(event) {\n            console.log(this); // ul\n            console.log(event.currentTarget); // ul\n        })\n        \n        // 总结\n        // >> this 有个非常相似的属性 currentTarget,但是ie678不认识，所以this更为通用。\n    </script>\n</body>\n```\n\n## 3.3、事件对象的常见属性和方法\n\n![0094](/assets/JavaScript笔记/0094.png)\n\n## 3.4、阻止事件默认行为\n\n### 3.4.1、说明\n\n```markdown\n# 所谓的阻止事件默认行为,比如说让超链接不跳转，让提交按钮本来要提交表单的事件不发生。\n```\n\n### 3.4.2、案例1\n\n```html\n<body>\n    <a href=\"https://www.baidu.com\">跳转到百度</a>\n    <script>\n        // 阻止超链接的默认行为\n\n        var aObj = document.querySelector(\"a\");\n\n        // 给ul标签节点绑定单击事件\n        aObj.addEventListener('click', function(event) {\n            alert(\"阻止超链接跳转哦\");\n            event.preventDefault(); // DOM的标准写法\n        })\n    </script>\n</body>\n```\n\n### 3.4.3、案例2\n\n```html\n<body>\n    <a href=\"https://www.baidu.com\">跳转到百度</a>\n    <script>\n        // 阻止超链接的默认行为\n\n        var aObj = document.querySelector(\"a\");\n\n        // 给ul标签节点绑定单击事件\n        aObj.onclick = function(event) {\n            alert(\"阻止超链接的默认行为哦\");\n            event.preventDefault(); // DOM标准写法\n        }\n    </script>\n</body>\n```\n\n### 3.4.3、案例3\n\n```html\n<body>\n    <a href=\"https://www.baidu.com\">跳转到百度</a>\n    <script>\n        // 阻止超链接的默认行为\n\n        var aObj = document.querySelector(\"a\");\n\n        // 给ul标签节点绑定单击事件\n        aObj.onclick = function(event) {\n            alert(\"阻止超链接的默认行为哦\");\n            event.returnValue;\t\t// 低版本浏览器 ie678  returnValue  属性可以阻止\n        }\n    </script>\n</body>\n```\n\n### 3.4.4、案例4\n\n```html\n<body>\n    <a href=\"https://www.baidu.com\">跳转到百度</a>\n    <script>\n        // 阻止超链接的默认行为\n\n        var aObj = document.querySelector(\"a\");\n\n        // 给ul标签节点绑定单击事件\n        aObj.onclick = function(event) {\n            alert(\"阻止超链接的默认行为哦\");\n            return false; // 没有兼容性问题，但是只限于传统的注册方式\n        }\n    </script>\n</body>\n```\n\n## 3.5、阻止事件冒泡\n\n### 3.5.1、说明\n\n```markdown\n1. 事件冒泡：开始时由最具体的元素接收，然后逐级向上传播到到 DOM 最顶层节点。\n2. 事件冒泡本身的特性，会带来的坏处，也会带来的好处，需要我们灵活掌握。\n```\n\n### 3.5.2、案例\n\n```html\n<head>\n    <style>\n        #div1 {\n            width: 300px;\n            height: 300px;\n            background-color: red;\n        }\n        \n        #div2 {\n            width: 200px;\n            height: 200px;\n            background-color: blue;\n        }\n        \n        #div3 {\n            width: 100px;\n            height: 100px;\n            background-color: skyblue;\n        }\n    </style>\n</head>\n<body>\n    <div id=\"div1\">\n        <div id=\"div2\">\n            <div id=\"div3\"></div>\n        </div>\n    </div>\n    <script>\n        // 1. 获取div1\n        var div1 = document.querySelector(\"#div1\");\n        div1.addEventListener('click', function() {\n            alert(\"div1\");\n        });\n\n        // 2. 获取div2\n        var div2 = document.querySelector(\"#div2\");\n        div2.addEventListener('click', function() {\n            alert(\"div2\");\n        });\n\n        // 3. 获取div3\n        var div3 = document.querySelector(\"#div3\");\n        div3.addEventListener('click', function(event) {\n            alert(\"div3\");\n            event.stopPropagation(); // 阻止事件冒泡,标准方式\n            // event.cancelBubble = true; // 也可以阻止事件冒泡\n        });\n    </script>\n</body>\n```\n\n# 四、事件委托/代理/委派\n\n## 4.1、理解\n\n​\t\t事件冒泡本身的特性，会带来的坏处，也会**带来的好处**，需要我们灵活掌握。生活中有如下场景：\n\n咱们班有100个学生， 快递员有100个快递， 如果一个个的送花费时间较长。同时每个学生领取的时候，也需\n\n要排队领取，也花费时间较长，何如办呢？\n\n​\t\t**解决方案：** 快递员把100个快递，**委托**给班主任，班主任把这些快递放到办公室，同学们下课自行领取即可。\n\n​\t\t**优势：** 快递员省事，委托给班主任就可以走了。 同学们领取也方便，因为相信班主任。\n\n## 4.2、需求\n\n```html\n<ul>\n   <li>高圆圆</li>\n   <li>贾静雯</li>\n   <li>赵敏</li>\n</ul>\n```\n\n​\t\t点击每个 li 都会弹出对话框弹出每个li里面的内容。\n\n​\t\t方案：给每个 li 注册点击事件，\n\n​\t\t问题：麻烦，效率低下。\n\n```html\n<body>\n    <ul>\n        <li>高圆圆</li>\n        <li>贾静雯</li>\n        <li>赵敏</li>\n    </ul>\n\n    <script>\n        var liObjs = document.querySelectorAll(\"li\");\n        for (var i = 0; i < liObjs.length; i++) {\n            liObjs[i].onclick = function() {\n                alert(this.innerHTML);\n            }\n        }\n    </script>\n</body>\n```\n\n## 4.3、概述\n\n```markdown\n# 事件委托\n\t也称为事件代理， 在 jQuery 里面称为事件委派。\n# 事件委托的原理\n\t不是每个子节点单独设置事件监听器，而是事件监听器设置在其父节点上，然后利用冒泡原理影响设置每个子节点。\n# 案例\n\t给ul注册点击事件，然后利用事件对象的 target 来找到当前点击的 li，因为点击 li，事件会冒泡到 ul 上，ul 有注册事件，就会触发事件监听器。\n# 事件委托的作用\n\t我们只操作了一次 DOM ，提高了程序的性能。\n```\n\n```html\n<body>\n    <ul>\n        <li>高圆圆</li>\n        <li>贾静雯</li>\n        <li>赵敏</li>\n    </ul>\n\n    <script>\n        // 获取ul\n        var ulObj = document.querySelector(\"ul\");\n        // 绑定事件\n        ulObj.addEventListener(\"click\", function(event) {\n            alert(event.target.innerHTML);\n        });\n    </script>\n</body>\n```\n\n# 五、鼠标事件\n\n## 5.1、常用的鼠标事件\n\n![0095](/assets/JavaScript笔记/0095.png)\n\n## 5.2、禁止鼠标右键菜单\n\n```html\n<body>\n    <div>我是一段文字</div>\n\n    <script>\n        // 禁用右键菜单\n        document.addEventListener('contextmenu', function(event) {\n            event.preventDefault();\n        })\n    </script>\n</body>\n```\n\n## 5.3、禁止鼠标选中\n\n```html\n<body>\n    <div>我是一段文字</div>\n\n    <script>\n        // 禁止选中文字 selectstart\n        document.addEventListener('selectstart', function(event) {\n            event.preventDefault();\n        })\n    </script>\n</body>\n```\n\n## 5.4、鼠标事件对象\n\n![0096](/assets/JavaScript笔记/0096.png)\n\n```html\n<head>\n   \t<style>\n        body {\n            height: 3000px;\n        }\n    </style>\n</head>\n<body>\n    <script>\n        // 禁用右键菜单\n        document.addEventListener('click', function(event) {\n            // 1. client 鼠标在可视区的x和y坐标\n            console.log(event.clientX);\n            console.log(event.clientY);\n            console.log('---------------------');\n\n            // 2. page 鼠标在页面文档的x和y坐标\n            console.log(event.pageX);\n            console.log(event.pageY);\n            console.log('---------------------');\n        })\n    </script>\n</body>\n```\n\n## 5.5、案例\n\n​\t\t需求：图片一直跟随鼠标移动。\n\n```html\n<head>\n    <style>\n        img {\n            position: absolute;\n            top: 2px;\n        }\n    </style>\n</head>\n<body>\n    <img src=\"img/angel.gif\" alt=\"\">\n    <script>\n        // 获取图片节点对象\n        var imgObj = document.querySelector(\"img\");\n        // 绑定鼠标在屏幕上移动的事件\n        document.addEventListener('mousemove', function(event) {\n            //每次鼠标移动，我们都会获得最新的鼠标坐标，把这个x和y坐标做为图片的top和left值就可以移动图片\n            var x = event.pageX;\n            var y = event.pageY;\n\n            // 设置图片的top和left\n            imgObj.style.left = x - 50 + 'px';\n            imgObj.style.top = y - 40 + 'px';\n        });\n    </script>\n</body>\n```\n\n# 六、键盘事件\n\n## 6.1、常用的键盘事件\n\n![0097](/assets/JavaScript笔记/0097.png)\n\n**注意：**\n\n- **如果使用addEventListener不需要加on**\n- onkeypress 和前面2个的区别是，它不识别功能键，比如左右箭头，shift 等\n- 三个事件的执行顺序是： keydown -- keypress --- keyup\n\n```html\n<body>\n    <script>\n        document.addEventListener('keyup', function() {\n            console.log('我弹起了...');\n        });\n    </script>\n</body>\n```\n\n```html\n<body>\n    <script>\n        // 不支持 不可打印字符的按键，比如说 shift,ctrl\n        document.addEventListener('keypress', function() {\n            console.log('keypress');\t\t\n        });\n    </script>\n</body>\n```\n\n```html\n<body>\n    <script>\n        // 按键按下的时候触发  能识别功能键 比如 ctrl shift 左右箭头等\n        document.addEventListener('keydown', function() {\n            console.log('keydown');\n        });\n    </script>\n</body>\n```\n\n```html\n\n<body>\n    <script>\n        document.addEventListener('keydown', function() {\n            console.log('keydown');\n        });\n        document.addEventListener('keyup', function() {\n            console.log('keyup');\n        });\n        document.addEventListener('keypress', function() {\n            console.log('keypress');\n        });\n        \n        // 总结： keydown -- keypress --- keyup\n    </script>\n</body>\n```\n\n## 6.2、键盘事件对象属性\n\n![0098](/assets/JavaScript笔记/0098.png)\n\n```markdown\n# 键盘事件对象中的keyCode属性可以得到相应键的ASCII码值\n```\n\n```html\n<body>\n    <script>\n        document.addEventListener('keyup', function(event) {\n            if (event.keyCode == 13) {\n                alert('回车用户提交表单');\n            }\n        });\n    </script>\n</body>\n```\n\n## 6.3、案例\n\n​\t\t需求：当我们按下 s 键， 光标就定位到搜索框\n\n```html\n<body>\n    搜索: <input type=\"text\" placeholder=\"请输入你要搜索的内容\">\n    <script>\n        // 当我们按下 s 键， 光标就定位到搜索框\n\n        // 1、获取input\n        var inputObj = document.querySelector('input');\n\n        // 2、绑定按键事件\n        document.addEventListener('keyup', function(event) {\n            if (event.keyCode == 83) {\n                inputObj.focus();\n            }\n        });\n    </script>\n</body>\n```\n\n","tags":["JavaScript","学习笔记"],"categories":["JavaScript笔记"]},{"title":"JavaScript笔记-05DOM","url":"/2023/05/26/JavaScript笔记-05DOM/","content":"\n\n# 一、概述\n\n## 1.1、什么是DOM\n\n​\t\t\t文档对象模型（Document Object Model，简称 DOM），是 W3C 组织推荐的处理可扩展标记语言（HTML或者XML）的**标准编程接口**。 \n\n​\t\t\tW3C 已经定义了一系列的 DOM 接口，通过这些 DOM 接口可以改变网页的内容、结构和样式。\n\n## 1.2、DOM 树\n\n![0082](/assets/JavaScript笔记/0082.png)\n\n- 文档：一个页面就是一个文档，DOM 中使用 document 表示\n- 元素：页面中的所有标签都是元素，DOM 中使用 element 表示\n- 节点：网页中的所有内容都是节点（标签、属性、文本、注释等），DOM 中使用 node 表示\n\n# 二、获取元素\n\n## 2.1、概述\n\n​\t\tDOM在我们实际开发中主要用来操作元素。我们如何来获取页面中的元素呢？\n\n​\t\t获取页面中的元素可以使用以下几种方式：\n\n- 根据 ID 获取\n- 根据标签名获取\n- 根据name名称获取\n- 通过 HTML5 新增的方法获取\n- 特殊元素获取\n\n## 2.2、根据ID获取\n\n​\t\t使用 `getElementById()` 方法可以获取带有 ID 的元素对象。\n\n```html\n<body>\n    <div id=\"myDiv\">HelloWorld</div>\n    <script>\n        var divObj = document.getElementById(\"myDiv\");\n        console.log(divObj);\n        console.log(typeof divObj); // 返回的结果是一个对象\n\n        // 使用 console.dir() 可以打印我们获取的元素对象，更好的查看对象里面的属性和方法\n        console.dir(divObj);\n    </script>\n</body>\n```\n\n## 2.3、根据标签名获取\n\n​\t\t使用`getElementsByTagName()` 方法可以返回带有指定标签名的对象的集合。\n\n```html\n<body>\n    <ul>\n        <li>HTML</li>\n        <li>JavaScript</li>\n        <li>CSS3</li>\n    </ul>\n\n    <script>\n        var liObjs = document.getElementsByTagName(\"li\");\n        console.log(liObjs); // 返回的是元素对象的集合 以伪数组的形式存储的\n\n        // 遍历\n        for (var i = 0; i < liObjs.length; i++) {\n            console.log(liObjs[i]);\n        }\n    </script>\n</body>\n```\n\n```html\n<body>\n    <ul>\n        <li>HTML</li>\n        <li>JavaScript</li>\n        <li>CSS3</li>\n    </ul>\n    <ol>\n        <li>Vue</li>\n        <li>React</li>\n    </ol>\n    <script>\n        // 需求：我想获取ol标签里面的li\n\n        // >> 第一步: 先获取ol, 注意返回过来的是一个数组\n        var olObjs = document.getElementsByTagName(\"ol\");\n\n        // >> 第二步：再根据获取的olObjs[0]获取里面的所有的li\n        var liObjs = olObjs[0].getElementsByTagName(\"li\");\n\n        // 遍历\n        for (var i = 0; i < liObjs.length; i++) {\n            console.log(liObjs[i]);\n        }\n    </script>\n</body>\n```\n\n## 2.4、根据name名称获取\n\n```html\n<body>\n    跳舞: <input type=\"checkbox\" name=\"hobby\"> \n    唱歌: <input type=\"checkbox\" name=\"hobby\"> \n    学习: <input type=\"checkbox\" name=\"hobby\">\n\n    <script>\n        var hobbyObjs = document.getElementsByName(\"hobby\");\n\n        // 遍历\n        for (var i = 0; i < hobbyObjs.length; i++) {\n            console.log(hobbyObjs[i]);\n        }\n    </script>\n</body>\n```\n\n## 2.5、通过 HTML5 新增的方法获取\n\n### 2.5.1、根据类名获得某些元素集合\n\n​\t\t方法：`getElementsByClassName `\n\n```html\n<body>\n    <div class=\"box\">盒子1</div>\n    <div class=\"box\">盒子2</div>\n    <script>\n        var boxObjs = document.getElementsByClassName(\"box\");\n        console.log(boxObjs);\n    </script>\n</body>\n```\n\n### 2.5.2、根据指定选择器返回第一个元素对象\n\n​\t\t方法：`querySelector`\n\n```html\n<body>\n    <div class=\"box\">盒子1</div>\n    <div class=\"box\">盒子2</div>\n    <div id=\"nav\">\n        <ul>\n            <li>首页</li>\n            <li>产品</li>\n        </ul>\n    </div>\n    <script>\n        // 页面上有两个类为box的div元素，但是只会获取第一个\n        var boxObj = document.querySelector(\".box\");\n        console.log(boxObj);\n\n        // 页面上有两个标签名为li的元素，但是只会获取第一个\n        var liObj = document.querySelector(\"li\");\n        console.log(liObj);\n    </script>\n</body>\n```\n\n### 2.5.3、根据指定选择器返回所有元素\n\n```html\n<body>\n    <div class=\"box\">盒子1</div>\n    <div class=\"box\">盒子2</div>\n    <div id=\"nav\">\n        <ul>\n            <li>首页</li>\n            <li>产品</li>\n        </ul>\n    </div>\n    <script>\n        // 获取页面上所有的类名为box的div元素\n        var boxObjs = document.querySelectorAll(\".box\");\n        console.log(boxObjs);\n\n        // 获取页面上所有的标签为li的元素\n        var liObjs = document.querySelectorAll(\"li\");\n        console.log(liObjs);\n    </script>\n</body>\n```\n\n## 2.6、特殊元素获取\n\n### 2.6.1、获取body 元素\n\n```html\n<body>\n    <script>\n        // 获取body元素\n\n        // >> 方式一, 简单\n        var bodyObj1 = document.body;\n        console.log(bodyObj1);\n\n        // >> 方式二\n        var bodyObj2 = document.getElementsByTagName(\"body\")[0];\n        console.log(bodyObj2);\n    </script>\n</body>\n```\n\n### 2.6.2、获取html 元素\n\n```html\n<body>\n    <script>\n        // 获取html元素\n\n        // >> 方式一, 简单\n        var htmlObj1 = document.documentElement;\n        console.log(htmlObj1);\n\n        // >> 方式二\n        var htmlObj2 = document.getElementsByTagName(\"html\")[0];\n        console.log(htmlObj2);\n    </script>\n</body>\n```\n\n# 三、事件基础\n\n## 3.1、概述\n\n​\t\t网页中的每个元素都可以产生某些可以触发 JavaScript 的事件，例如，我们可以在用户点击某按钮时产生一个事件，然后去执行某些操作。\n\n## 3.2、事件三要素\n\n1. 事件源 （谁，指的是事件被触发的对象 ）\n\n2. 事件类型 （什么事件，指的是鼠标点击、还是鼠标经过、还是键盘按下）\n\n3. 事件处理程序 （做啥， 通过一个函数赋值的方式完成一个功能）\n\n```html\n<body>\n    <button id=\"btn\">点我</button>\n    <script>\n        // 需求: 点击一个按钮,弹出一个对话框\n\n        // >> 第一步: 获取事件源\n        var btnObj = document.getElementById(\"btn\");\n        // >> 第二步: 绑定事件\n        // btnObj.onclick\n        // >> 第三步：添加事件处理程序\n        btnObj.onclick = function() {\n            alert(\"按钮被点击了...\");\n        }\n    </script>\n</body>\n```\n\n## 3.3、常见的鼠标事件\n\n![0083](/assets/JavaScript笔记/0083.png)\n\n# 四、操作元素\n\n## 4.1、概述\n\n​\t\tJavaScript 的 DOM 操作可以改变网页内容、结构和样式，我们可以利用 DOM 操作元素来改变元素里面的内\n\n容 、属性等。注意以下都是属性。\n\n## 4.2、改变/获取元素内容\n\n- innerHTML \n- innerText\n\n```html\n<body>\n    <div id=\"myDiv\">HelloWorld</div>\n    <script>\n        // 获取div的内容\n        var divObj = document.getElementById(\"myDiv\");\n        console.log(divObj.innerHTML);\n        console.log(divObj.innerText);\n    </script>\n</body>\n```\n\n```html\n<body>\n    <button id=\"btn1\">通过innertHTML改变div内容</button>\n    <button id=\"btn2\">通过innertText改变div内容</button>\n\n    <div id=\"myDiv\">HelloWorld</div>\n    <script>\n        // 获取div元素对象\n        var divObj = document.getElementById(\"myDiv\");\n\n        // 获取两个按钮\n        var btn1Obj = document.getElementById(\"btn1\");\n        var btn2Obj = document.getElementById(\"btn2\");\n\n        btn1Obj.onclick = function() {\n            divObj.innerHTML = \"<h1>JavaScript</h1>\"\n        }\n\n        btn2Obj.onclick = function() {\n            divObj.innerText = \"<h1>JavaScript</h1>\"\n        }\n    </script>\n</body>\n```\n\n## 4.3、常用元素的属性操作\n\n![0084](/assets/JavaScript笔记/0084.png)\n\n```html\n<body>\n    <button id=\"ldh\">刘德华</button>\n    <button id=\"zxy\">张学友</button> <br>\n    <img src=\"images/ldh.jpg\" alt=\"\" title=\"刘德华\">\n    <script>\n        // 获取两个按钮\n        var btn1Obj = document.getElementById(\"ldh\");\n        var btn2Obj = document.getElementById(\"zxy\");\n\n        // 获取img标签对象\n        var imgObj = document.querySelector(\"img\");\n\n        btn1Obj.onclick = function() {\n            imgObj.src = \"images/ldh.jpg\";\n        }\n\n        btn2Obj.onclick = function() {\n            imgObj.src = \"images/zxy.jpg\";\n        }\n    </script>\n</body>\n```\n\n## 4.4、表单元素的属性操作\n\n```html\n<body>\n    <button>按钮</button>\n    <input type=\"text\" value=\"用户名\">\n    <script>\n        // 点击按钮,修改输入框的值，并且将按钮禁用\n\n        // >> 获取按钮元素对象\n        var btnObj = document.querySelector(\"button\");\n        // >> 获取input元素对象\n        var inputObj = document.querySelector(\"input\");\n        // >> 按钮绑定事件\n        btnObj.onclick = function() {\n            // 修改文本框的内容\n            inputObj.value = '张三';\n            // 按钮禁用\n            this.disabled = true;\n        }\n    </script>\n</body>\n```\n\n## 4.5、样式属性操作\n\n### 4.5.1、说明\n\n​\t\t我们可以通过 JS 修改元素的大小、颜色、位置等样式。\n\n![0085](/assets/JavaScript笔记/0085.png)\n\n​\t\t**注意**：\n\n- JS 里面的样式采取驼峰命名法 比如 fontSize、 backgroundColor\n- JS 修改 style 样式操作，产生的是行内样式，CSS 权重比较高\n\n### 4.5.2、行内样式操作\n\n```html\n<head>\n    <style>\n        div {\n            width: 200px;\n            height: 200px;\n            background-color: pink;\n        }\n    </style>\n</head>\n<body>\n    <div></div>\n    <script>\n        // 点击div元素，背景颜色变为红色，宽度变大\n\n        // >> 1、获取div元素对象\n        var divObj = document.querySelector(\"div\");\n        // >> 2、绑定事件处理程序\n        divObj.onclick = function() {\n            this.style.backgroundColor = 'red';  // 采用驼峰命名法\n            this.style.width = '500px';\n        }\n    </script>\n</body>\n```\n\n```html\n<head>\n    <style>\n        div {\n            width: 200px;\n            height: 200px;\n            background-color: pink;\n        }\n    </style>\n</head>\n<body>\n    <div></div>\n    <button>隐藏</button>\n    <script>\n        // 点击按钮让div能够显示或者隐藏\n\n        // >> 1、获取div元素\n        var divObj = document.querySelector(\"div\");\n        // >> 2、获取button元素对象\n        var buttonObj = document.querySelector(\"button\");\n        // >> 3、绑定事件处理程序\n        var flag = true; // 表示div显示\n        buttonObj.onclick = function() {\n            if (flag) {\n                // true表示显示则隐藏\n                divObj.style.display = 'none';\n                flag = false;\n                this.innerHTML = '显示'\n            } else {\n                divObj.style.display = 'block';\n                flag = true;\n                this.innerHTML = '隐藏'\n            }\n        }\n    </script>\n</body>\n```\n\n```html\n<body>\n    <input type=\"text\" value=\"搜索你想要的内容呗\">\n    <script>\n        // 当鼠标点击文本框时，里面的默认文字隐藏，当鼠标离开文本框时，里面的文字显示。\n\n        // >> 1、获取input元素\n        var inputObj = document.querySelector(\"input\");\n        // >> 2、绑定事件处理程序\n        // >>>> 获得焦点事件 onfocus \n        inputObj.onfocus = function() {\n            if (this.value === '搜索你想要的内容呗') {\n                this.value = '';\n            }\n        };\n        // >>>> 失去焦点事件 onblur\n        inputObj.onblur = function() {\n            if (this.value === '') {\n                this.value = '搜索你想要的内容呗';\n            }\n        };\n    </script>\n</body>\n```\n\n### 4.5.3、类名样式操作\n\n```markdown\n# 使用场景\n\t1. 如果样式修改较多，可以采取操作类名方式更改元素样式。\n\t2. class因为是个保留字，需要使用className来操作元素类名属性\n\t3. className会直接更改元素的类名，会覆盖原先的类名。\n```\n\n```html\n<head>\n    <style>\n        .first {\n            width: 200px;\n            height: 200px;\n            background-color: pink;\n            margin-top: 100px;\n        }\n        \n        .newChangeStyle {\n            width: 300px;\n            height: 300px;\n            background-color: red;\n            color: blue;\n        }\n    </style>\n</head>\n<body>\n    <div class=\"first\">HelloWorld</div>\n    <script>\n        // 点击div,设置背景颜色,高度,宽度,字体颜色\n\n        // 1、获取div元素\n        var divObj = document.querySelector(\"div\");\n        // 2、注册事件\n        divObj.onclick = function() {\n            // 通过 修改元素的className更改元素的样式 适合于样式较多或者功能复杂的情况\n            // this.className = 'newChangeStyle';\n\n            // 注: 这种方式把原先的类名也给覆盖了,如果想保留，可以这样\n            this.className = 'first newChangeStyle';\n        };\n    </script>\n</body>\n```\n\n## 4.6、总结\n\n```markdown\n# 操作元素是DOM的核心内容\n```\n\n![0086](/assets/JavaScript笔记/0086.png)\n\n## 4.7、排他思想\n\n### 4.7.1、需求\n\n![0087](/assets/JavaScript笔记/0087.png)\n\n​\t\t如果有同一组元素，我们想要某一个元素实现某种样式， 需要用到循环的排他思想算法：\n\n- 所有元素全部清除样式（干掉其他人）\n- 给当前元素设置样式 （留下我自己）\n- 注意顺序不能颠倒，首先干掉其他人，再设置自己\n\n```html\n<body>\n    <button>按钮1</button>\n    <button>按钮2</button>\n    <button>按钮3</button>\n    <button>按钮4</button>\n    <button>按钮5</button>\n    <script>\n        // 点击某个button,设置被点击button的背景颜色\n\n        // 1、获取所有的button元素对象\n        var buttonObjs = document.querySelectorAll(\"button\");\n        // 2、循环遍历注册事件\n        for (var i = 0; i < buttonObjs.length; i++) {\n            buttonObjs[i].onclick = function() {\n                // 第一步：我们先把所有的按钮背景颜色去掉  干掉所有人\n                for (var j = 0; j < buttonObjs.length; j++) {\n                    buttonObjs[j].style.backgroundColor = '';\n                }\n                // 第二步：设置当前的元素背景颜色为红色 留下我自己\n                this.style.backgroundColor = 'red';\n            }\n        }\n    </script>\n</body>\n```\n\n### 4.7.2、案例1\n\n```html\n<body>\n    <table border=\"1px\">\n        <thead>\n            <tr>\n                <th>代码</th>\n                <th>名称</th>\n                <th>最新公布净值</th>\n                <th>累计净值</th>\n                <th>前单位净值</th>\n                <th>净值增长率</th>\n            </tr>\n        </thead>\n        <tbody>\n            <tr>\n                <td>003526</td>\n                <td>农银金穗3个月定期开放债券</td>\n                <td>1.075</td>\n                <td>1.079</td>\n                <td>1.074</td>\n                <td>+0.047%</td>\n            </tr>\n            <tr>\n                <td>003526</td>\n                <td>农银金穗3个月定期开放债券</td>\n                <td>1.075</td>\n                <td>1.079</td>\n                <td>1.074</td>\n                <td>+0.047%</td>\n            </tr>\n            <tr>\n                <td>003526</td>\n                <td>农银金穗3个月定期开放债券</td>\n                <td>1.075</td>\n                <td>1.079</td>\n                <td>1.074</td>\n                <td>+0.047%</td>\n            </tr>\n            <tr>\n                <td>003526</td>\n                <td>农银金穗3个月定期开放债券</td>\n                <td>1.075</td>\n                <td>1.079</td>\n                <td>1.074</td>\n                <td>+0.047%</td>\n            </tr>\n            <tr>\n                <td>003526</td>\n                <td>农银金穗3个月定期开放债券</td>\n                <td>1.075</td>\n                <td>1.079</td>\n                <td>1.074</td>\n                <td>+0.047%</td>\n            </tr>\n            <tr>\n                <td>003526</td>\n                <td>农银金穗3个月定期开放债券</td>\n                <td>1.075</td>\n                <td>1.079</td>\n                <td>1.074</td>\n                <td>+0.047%</td>\n            </tr>\n        </tbody>\n    </table>\n    <script>\n        // 鼠标移动到表格的某一行，修改该行的背景颜色\n\n        // 1、获取tbody里面所有的tr行\n        var trObjs = document.querySelector(\"tbody\").querySelectorAll(\"tr\");\n        // 2、为每一个行绑定事件\n        for (var i = 0; i < trObjs.length; i++) {\n            trObjs[i].onmouseover = function() {\n                // 第一步：我们先把所有的按钮背景颜色去掉  干掉所有人\n                for (var j = 0; j < trObjs.length; j++) {\n                    trObjs[j].style.backgroundColor = '';\n                }\n                // 第二步：设置当前的元素背景颜色为红色 留下我自己\n                this.style.backgroundColor = 'red';\n            }\n        }\n    </script>\n</body>\n```\n\n```html\n<body>\n    <table border=\"1px\">\n        <thead>\n            <tr>\n                <th>代码</th>\n                <th>名称</th>\n                <th>最新公布净值</th>\n                <th>累计净值</th>\n                <th>前单位净值</th>\n                <th>净值增长率</th>\n            </tr>\n        </thead>\n        <tbody>\n            <tr>\n                <td>003526</td>\n                <td>农银金穗3个月定期开放债券</td>\n                <td>1.075</td>\n                <td>1.079</td>\n                <td>1.074</td>\n                <td>+0.047%</td>\n            </tr>\n            <tr>\n                <td>003526</td>\n                <td>农银金穗3个月定期开放债券</td>\n                <td>1.075</td>\n                <td>1.079</td>\n                <td>1.074</td>\n                <td>+0.047%</td>\n            </tr>\n            <tr>\n                <td>003526</td>\n                <td>农银金穗3个月定期开放债券</td>\n                <td>1.075</td>\n                <td>1.079</td>\n                <td>1.074</td>\n                <td>+0.047%</td>\n            </tr>\n            <tr>\n                <td>003526</td>\n                <td>农银金穗3个月定期开放债券</td>\n                <td>1.075</td>\n                <td>1.079</td>\n                <td>1.074</td>\n                <td>+0.047%</td>\n            </tr>\n            <tr>\n                <td>003526</td>\n                <td>农银金穗3个月定期开放债券</td>\n                <td>1.075</td>\n                <td>1.079</td>\n                <td>1.074</td>\n                <td>+0.047%</td>\n            </tr>\n            <tr>\n                <td>003526</td>\n                <td>农银金穗3个月定期开放债券</td>\n                <td>1.075</td>\n                <td>1.079</td>\n                <td>1.074</td>\n                <td>+0.047%</td>\n            </tr>\n        </tbody>\n    </table>\n    <script>\n        // 鼠标移动到表格的某一行，修改该行的背景颜色\n\n        // 1、获取tbody里面所有的tr行\n        var trObjs = document.querySelector(\"tbody\").querySelectorAll(\"tr\");\n        // 2、为每一个行绑定事件\n        for (var i = 0; i < trObjs.length; i++) {\n            trObjs[i].onmouseover = function() {\n                this.style.backgroundColor = 'red';\n            }\n            trObjs[i].onmouseout = function() {\n                this.style.backgroundColor = '';\n            }\n        }\n    </script>\n</body>\n```\n\n### 4.7.3、案例2\n\n```html\n<body>\n    全选：<input type=\"checkbox\" id=\"checkAll\" /> <br/> \n    唱歌: <input type=\"checkbox\" name=\"hobby\" /> <br/> \n    跳舞: <input type=\"checkbox\" name=\"hobby\" /> <br/> \n    学习: <input type=\"checkbox\" name=\"hobby\" /> <br/> \n    打游戏: <input type=\"checkbox\" name=\"hobby\" /> <br/>\n\n    <script>\n        // >> 获取全选按钮\n        var checkAllObj = document.getElementById(\"checkAll\");\n        // >> 获取所有的爱好复选框\n        var hobbyObjs = document.getElementsByName(\"hobby\");\n\n        // 全选和取消全选做法：让下面所有复选框的checked属性（选中状态） 跟随 全选按钮即可\n        checkAllObj.onclick = function() {\n            for (var i = 0; i < hobbyObjs.length; i++) {\n                hobbyObjs[i].checked = this.checked;\n            }\n        }\n\n        // 下面复选框需要全部选中， 上面全选才能选中做法： 给下面所有复选框绑定点击事件，每次点击，都要循环\t\t   查看下面所有的复选框是否有没选中的，如果有一个没选中的， 上面全选就不选中。\n        for (var i = 0; i < hobbyObjs.length; i++) {\n            hobbyObjs[i].onclick = function() {\n                var flag = true; // 表示都选中了\n                // 每次点击下面的复选框都要循环检查者4个小按钮是否全被选中\n                for (var j = 0; j < hobbyObjs.length; j++) {\n                    if (!hobbyObjs[j].checked) {\n                        flag = false; // 一旦发现有没有选中的,则标记为false\n                        break;\n                    }\n                }\n                checkAllObj.checked = flag;\n            }\n        }\n    </script>\n</body>\n```\n\n## 4.8、自定义属性的操作\n\n### 4.8.1、获取属性值\n\n```html\n<body>\n    <div id=\"myDiv\"></div>\n    <script>\n        // 获取div元素对象\n        var divObj = document.querySelector(\"div\");\n\n        // >> 获取属性方式一: element.属性\n        console.log(divObj.id);\n\n        // >> 获取属性方式二: element.getAttribute('属性')\n        console.log(divObj.getAttribute(\"id\"));\n    </script>\n</body>\n```\n\n```html\n<body>\n    <div index=\"1\"></div>\n    <script>\n        // 获取div元素对象\n        var divObj = document.querySelector(\"div\");\n\n        // >> 获取属性方式一: element.属性\n        console.log(divObj.index); // undefined\n\n        // >> 获取属性方式二: element.getAttribute('属性')\n        console.log(divObj.getAttribute(\"index\"));\n    </script>\n</body>\n```\n\n```markdown\n# 总结\n\t1. element.属性 获取内置属性值（元素本身自带的属性）\n\t2. element.getAttribute(‘属性’); 主要获得自定义的属性 （标准） 我们程序员自定义的属性\n```\n\n### 4.8.2、设置属性值\n\n```html\n<body>\n    <div></div>\n    <script>\n        // 获取div元素对象\n        var divObj = document.querySelector(\"div\");\n\n        // >> 设置属性方式一: element.属性 = 值\n        divObj.id = 'myDiv';\n        divObj.className = 'content';\n\n        // >> 设置属性方式二: element.setAttribute('属性',值)\n        divObj.setAttribute('style', 'width:200px');\n    </script>\n</body>\n```\n\n```html\n<body>\n    <div></div>\n    <script>\n        // 获取div元素对象\n        var divObj = document.querySelector(\"div\");\n\n        // >> 设置属性方式一: element.属性 = 值\n        divObj.index = 1; // 不能添加index属性\n\n        // >> 设置属性方式二: element.setAttribute('属性',值)\n        divObj.setAttribute('index2', 2);\n    </script>\n</body>\n```\n\n```markdown\n# 总结\n\t1、element.属性 设置内置属性值 \n\t2、element.setAttribute(‘属性’); 主要设置自定义的属性 （标准）\n```\n\n### 4.8.3、移除属性\n\n```html\n<body>\n    <div index=\"1\">ss</div>\n    <script>\n        // 获取div元素对象\n        var divObj = document.querySelector(\"div\");\n\n        // >> 移除属性\n        divObj.removeAttribute(\"index\");\n    </script>\n</body>\n```\n\n## 4.9、H5自定义属性\n\n### 4.9.1、说明\n\n```markdown\n1. 自定义属性目的：是为了保存并使用数据。有些数据可以保存到页面中而不用保存到数据库中。\n2. 自定义属性获取是通过getAttribute(‘属性’) 获取。\n3. 但是有些自定义属性很容易引起歧义，不容易判断是元素的内置属性还是自定义属性。\n4. H5给我们新增了自定义属性：\n```\n\n### 4.9.2、设置H5自定义属性\n\n​\t\tH5规定自定义属性是这样的：`data-开头`做为属性名并且赋值。\n\n​\t\t比如 `<div data-index=\"1\"></div>` ，或者使用 JS 设置 `element.setAttribute(‘data-index’, 2)`\n\n```html\n<body>\n    <div></div>\n    <script>\n        // 获取div元素对象\n        var divObj = document.querySelector(\"div\");\n\n        // >> 设置属性\n        divObj.setAttribute(\"data-index\", 1);\n    </script>\n</body>\n```\n\n### 4.9.3、获取H5自定义属性\n\n```markdown\n# 两种方式\n\t1. 兼容性获取 element.getAttribute(‘data-index’);\n\t2. H5新增 element.dataset.index 或者 element.dataset[‘index’] ie 11才开始支持\n```\n\n```html\n<body>\n    <div></div>\n    <script>\n        // 获取div元素对象\n        var divObj = document.querySelector(\"div\");\n\n        // >> 设置属性\n        divObj.setAttribute(\"data-index\", 1);\n\n        // >> 获取属性值方式一\n        console.log(divObj.getAttribute(\"data-index\"));\n\n        // >> 获取属性方式二\n        console.log(divObj.dataset.index);\n        console.log(divObj.dataset['index']);\n    </script>\n</body>\n```\n\n# 五、节点操作\n\n## 5.1、说明\n\n​\t\t其实对于获取元素节点，一般来说有两种方式：\n\n![0088](/assets/JavaScript笔记/0088.png)\n\n## 5.2、概述\n\n​\t\t网页中的所有内容都是节点（标签、属性、文本、注释等），在DOM 中，节点使用 node 来表示。\n\n​\t\tHTML DOM 树中的所有节点均可通过 JavaScript 进行访问，所有 HTML 元素（节点）均可被修改，也可以\n\n创建或删除。\n\n![0089](/assets/JavaScript笔记/0089.png)\n\n​\t\t一般地，节点至少拥有nodeType（节点类型）、nodeName（节点名称）和nodeValue（节点值）这三个\n\n基本属性。 \n\n- 元素节点 nodeType 为 1 \n- 属性节点 nodeType 为 2 \n- 文本节点 nodeType 为 3 （文本节点包含文字、空格、换行等）\n\n​\t\t我们在实际开发中，节点操作主要操作的是**元素节点**\n\n```markdown\n1. 利用 DOM 树可以把节点划分为不同的层级关系，常见的是父子兄层级关系。\n```\n\n## 5.3、节点层级\n\n### 5.3.1、父级节点\n\n```markdown\n# 获取方式\n\t node.parentNode\n# 说明\n\t1. parentNode 属性可返回某节点的父节点，注意是最近的一个父节点\n\t2. 如果指定的节点没有父节点则返回 null\n```\n\n```html\n<body>\n    <div>\n        <div id=\"parent\">\n            <div id=\"child\">HelloWorld</div>\n        </div>\n    </div>\n    <script>\n        // 得到子节点\n        var childObj = document.querySelector(\"#child\");\n        // 获取父节点\n        console.log(childObj.parentNode.id);\n    </script>\n</body>\n```\n\n### 5.3.2、子级节点\n\n#### 5.3.2.1、方式一\n\n```markdown\n# 方式\n\tparentNode.childNodes（标准）\n# 说明\n\t1. 返回包含指定节点的子节点的集合\n\t2. 返回值里面包含了所有的子节点，包括元素节点，【文本节点】等\n\t3. 如果只想要获得里面的元素节点，则需要专门处理。 所以我们一般不提倡使用childNodes\n```\n\n```html\n<body>\n    <ul>\n        <li>我是li</li>\n        <li>我是li</li>\n        <li>我是li</li>\n        <li>我是li</li>\n\n    </ul>\n    <script>\n        // 得到父元素节点\n        var ulObj = document.querySelector(\"ul\");\n        // 获取ul节点下面所有的子节点li\n        console.log(ulObj.childNodes); // NodeList(9)\n    </script>\n</body>\n```\n\n```html\n<body>\n    <ul>\n        <li>我是li</li>\n        <li>我是li</li>\n        <li>我是li</li>\n        <li>我是li</li>\n\n    </ul>\n    <script>\n        // 得到父元素节点\n        var ulObj = document.querySelector(\"ul\");\n        // 获取ul节点下面所有的子节点li\n        for (var i = 0; i < ulObj.childNodes.length; i++) {\n            if (ulObj.childNodes[i].nodeType == 1) {\n                // 表示的是元素节点\n                console.log(ulObj.childNodes[i]);\n            }\n        }\n    </script>\n</body>\n```\n\n#### 5.3.2.2、方式二\n\n```markdown\n# 方式\n\tparentNode.children（非标准）\n# 说明\n\t1. parentNode.children是一个只读属性，返回所有的子元素节点。它只返回子元素节点，其余节点不返回。\n\t2. 虽然children 是一个非标准，但是得到了各个浏览器的支持，因此我们可以放心使用\n```\n\n```html\n<body>\n    <ul>\n        <li>我是li</li>\n        <li>我是li</li>\n        <li>我是li</li>\n        <li>我是li</li>\n\n    </ul>\n    <script>\n        // 得到父元素节点\n        var ulObj = document.querySelector(\"ul\");\n        // 获取ul节点下面所有的子节点li\n        console.log(ulObj.children);\n    </script>\n</body>\n```\n\n### 5.3.3、获取第一个和最后一个子节点\n\n```html\n<body>\n    <ol>\n        <li>我是li1</li>\n        <li>我是li2</li>\n        <li>我是li3</li>\n        <li>我是li4</li>\n        <li>我是li5</li>\n    </ol>\n    <script>\n        // 得到父元素节点\n        var olObj = document.querySelector(\"ol\");\n        // 获取ol节点的第一个子节点\n        console.log(olObj.firstChild); // #text\n        // 获取ol节点的最后一个子节点\n        console.log(olObj.lastChild); // #text\n        \n        /*\n        \t说明\n        \t\tfirstChild、lastChild 第一个子节点、最后一个节点 不管是文本节点还是元素节点\n        */\n    </script>\n</body>\n```\n\n```html\n<body>\n    <ol>\n        <li>我是li1</li>\n        <li>我是li2</li>\n        <li>我是li3</li>\n        <li>我是li4</li>\n        <li>我是li5</li>\n    </ol>\n    <script>\n        // 得到父元素节点\n        var olObj = document.querySelector(\"ol\");\n        // 获取ol节点的第一个元素子节点\n        console.log(olObj.firstElementChild); // <li>\n        // 获取ol节点的最后一个元素子节点\n        console.log(olObj.lastElementChild); // <li>\n        \n        // 有兼容性问题，IE9+ 以上才支持。\n    </script>\n</body>\n```\n\n​\t\t实际开发中，firstChild 和 lastChild 包含其他节点，操作不方便，而 firstElementChild 和 lastElementChild 又有兼容性问题，那么我们如何获取第一个子元素节点或最后一个子元素节点呢？\n\n​\t\t**解决方案：**\n\n1. 如果想要第一个子元素节点，可以使用 parentNode.chilren[0] \n\n2. 如果想要最后一个子元素节点，可以使用 parentNode.chilren[parentNode.chilren.length - 1] \n\n```html\n<body>\n    <ol>\n        <li>我是li1</li>\n        <li>我是li2</li>\n        <li>我是li3</li>\n        <li>我是li4</li>\n        <li>我是li5</li>\n    </ol>\n    <script>\n        // 得到父元素节点\n        var olObj = document.querySelector(\"ol\");\n        // 获取ol节点的第一个元素子节点\n        console.log(olObj.children[0]);\n        // 获取ol节点的最后一个元素子节点\n        console.log(olObj.children[olObj.children.length - 1]);\n    </script>\n</body>\n```\n\n### 5.3.4、兄弟节点\n\n```html\n<body>\n    <div>我是div1</div>\n    <div class=\"div2\">我是div2</div>\n    <span>我是span</span>\n    <script>\n        var divObj = document.querySelector(\".div2\");\n\n        // 获取上一个兄弟节点\n        var preObj1 = divObj.previousSibling; // 包含文本节点\n        console.log(preObj1);\n        var preObj2 = divObj.previousElementSibling; // 兄弟元素节点\n        console.log(preObj2);\n\n        // 获取下一个兄弟节点\n        var nextObj1 = divObj.nextSibling;\n        console.log(nextObj1);\n\n        var nextObj2 = divObj.nextElementSibling;\n        console.log(nextObj2);\n    </script>\n</body>\n```\n\n## 5.4、创建节点及添加节点\n\n### 5.4.1、语法\n\n```markdown\n# 1、创建节点\n\tdocument.createElement('标签名')\n\t创建由 标签名 指定的 HTML 元素，这些元素原先不存在，是根据我们的需求动态生成的，所以我们也称为动态创建元素节点。\n\n# 2、添加节点\n\ta. node.appendChild(child)\n\t\t该方法将一个节点添加到指定父节点的子节点列表末尾。\n\t\t\n\tb. node.insertBefore(child, 指定元素)\n\t\t 该方法将一个节点添加到父节点的指定子节点前面。\n```\n\n```html\n<body>\n    <ul>\n        <li>高圆圆</li>\n    </ul>\n    <script>\n        // 1、创建元素节点\n        var liObj = document.createElement(\"li\");\n        liObj.innerHTML = '贾静雯';\n\n        // >> 添加li节点到ul节点的末尾\n        var ulObj = document.querySelector(\"ul\");\n        ulObj.appendChild(liObj);\n\n        // 2、创建元素节点\n        var liObj2 = document.createElement(\"li\");\n        liObj2.innerHTML = '赵敏';\n\n        // >> 添加li节点到ul节点中的高圆圆节点的前面\n        ulObj.insertBefore(liObj2, ulObj.children[0])\n    </script>\n</body>\n```\n\n### 5.4.2、留言板案例\n\n```html\n<body>\n    <textarea name=\"\" id=\"\"></textarea>\n    <button>发布</button>\n    <ul>\n    </ul>\n    <script>\n        // 1、获取元素\n        var textAreaObj = document.querySelector(\"textarea\");\n        var btnObj = document.querySelector(\"button\");\n        var ulObj = document.querySelector(\"ul\");\n\n        // 2、绑定按钮事件\n        btnObj.onclick = function() {\n            // >> 获取内容\n            var content = textAreaObj.value;\n            if (content == null || content == '') {\n                alert(\"请输入内容\");\n                return false;\n            }\n            // >> 创建li节点\n            var liObj = document.createElement(\"li\");\n            liObj.innerHTML = content;\n\n            // >> 追加\n            ulObj.insertBefore(liObj, ulObj.children[0]);\n        }\n    </script>\n</body>\n```\n\n## 5.5、删除节点\n\n### 5.5.1、语法\n\n```markdown\n# 语法\n\tnode.removeChild(child)\n```\n\n```html\n<body>\n    <button>删除</button>\n    <ul>\n        <li>高圆圆</li>\n        <li>贾静雯</li>\n        <li>赵敏</li>\n    </ul>\n    <script>\n        // 1、获取元素\n        var btnObj = document.querySelector(\"button\");\n        var ulObj = document.querySelector(\"ul\");\n\n        // 2、绑定按钮事件\n        btnObj.onclick = function() {\n            // 依次删除每一个li孩子\n            if (ulObj.children.length == 0) {\n                btnObj.disabled = true;\n            } else {\n                ulObj.removeChild(ulObj.children[0]);\n            }\n        }\n    </script>\n</body>\n```\n\n### 5.5.2、留言板案例\n\n```html\n<body>\n    <textarea name=\"\" id=\"\"></textarea>\n    <button>发布</button>\n    <ul>\n    </ul>\n    <script>\n        // 1、获取元素\n        var textAreaObj = document.querySelector(\"textarea\");\n        var btnObj = document.querySelector(\"button\");\n        var ulObj = document.querySelector(\"ul\");\n\n        // 2、绑定按钮事件\n        btnObj.onclick = function() {\n            // >> 获取内容\n            var content = textAreaObj.value;\n            if (content == null || content == '') {\n                alert(\"请输入内容\");\n                return false;\n            }\n            // >> 创建li节点\n            var liObj = document.createElement(\"li\");\n            liObj.innerHTML = content;\n            // >> 创建a标签\n            var aObj = document.createElement(\"a\");\n            aObj.innerHTML = '删除';\n            aObj.setAttribute(\"href\", \"javascript:void(0)\");\n\n            // 绑定事件\n            aObj.onclick = function() {\n                this.parentNode.parentNode.removeChild(this.parentNode);\n            }\n\n            // >> 追加a节点\n            liObj.appendChild(aObj);\n\n            // >> 追加li节点\n            ulObj.insertBefore(liObj, ulObj.children[0]);\n        }\n    </script>\n</body>\n```\n\n## 5.6、复制节点/克隆节点\n\n### 5.6.1、语法\n\n```markdown\n# 语法\n\t node.cloneNode()\n\t 该方法返回调用该方法的节点的一个副本。 也称为克隆节点/拷贝节点\n\t \n# 注意点\n\t1. 如果括号参数为空或者为 false ，则是浅拷贝，即只克隆复制节点本身，不克隆里面的子节点。\n\t2. 如果括号参数为 true ，则是深度拷贝，会复制节点本身以及里面所有的子节点\n```\n\n```html\n<body>\n    <ul>\n        <li>高圆圆</li>\n        <li>贾静雯</li>\n        <li>赵敏</li>\n    </ul>\n    <script>\n        // 1、获取元素\n        var ulObj = document.querySelector(\"ul\");\n\n        // 2、>> node.cloneNode(); 括号为空或者里面是false 浅拷贝 只复制标签不复制里面的内容\n        var liObj1 = ulObj.children[0].cloneNode();\n        ulObj.appendChild(liObj1);\n\n        // 3、>> node.cloneNode(true); 括号为true 深拷贝 复制标签复制里面的内容\n        var liObj2 = ulObj.children[0].cloneNode(true);\n        ulObj.appendChild(liObj2);\n    </script>\n</body>\n```\n\n### 5.6.2、动态生成表格\n\n```html\n<body>\n    <table border=\"1px\">\n        <thead>\n            <tr>\n                <th>姓名</th>\n                <th>科目</th>\n                <th>成绩</th>\n                <th>操作</th>\n            </tr>\n        </thead>\n        <tbody>\n\n        </tbody>\n    </table>\n    <script>\n        // 1.先去准备好学生的数据\n        var datas = [{\n            name: '贾静雯',\n            subject: 'JavaScript',\n            score: 100\n        }, {\n            name: '赵敏',\n            subject: 'HTML',\n            score: 98\n        }, {\n            name: '贾静雯',\n            subject: 'CSS',\n            score: 99\n        }];\n        // 2、获取tbody元素节点对象\n        var tbodyObj = document.querySelector(\"tbody\");\n\n        // 3、数组中有多少个元素,就意味着有多少人,就意味着表格中有多少行\n        for (var i = 0; i < datas.length; i++) {\n            // >> 3.1 每循环一次就是创建一个tr\n            var trObj = document.createElement(\"tr\");\n            // >> 3.2 有几个单元格,是取决于数组中的元素对象中有几个属性\n            for (var key in datas[i]) {\n                // >> 3.3 创建单元格\n                var tdObj = document.createElement(\"td\");\n                // >> 3.4 向td单元格中添加内容\n                tdObj.innerHTML = datas[i][key];\n                // >> 3.5 将td追加到tr中\n                trObj.appendChild(tdObj);\n            }\n            // >> 3.6、创建由删除超链接的td\n            var delTdObj = document.createElement(\"td\");\n            delTdObj.innerHTML = '<a href=\"javascript:;\">删除 </a>';\n            trObj.appendChild(delTdObj);\n            // >> 3.7 追加到tbodyObj中\n            tbodyObj.appendChild(trObj);\n        }\n        // 超链接点击事件\n        var aObjs = document.querySelectorAll(\"a\");\n        for (var i = 0; i < aObjs.length; i++) {\n            aObjs[i].onclick = function() {\n                // 此处不能使用aObjs[i].parentNode.parentNode , i 有作用域的问题\n            \ttbodyObj.removeChild(this.parentNode.parentNode);\n            }\n        }\n    </script>\n</body>\n```\n\n","tags":["JavaScript","学习笔记"],"categories":["JavaScript笔记"]},{"title":"JavaScript笔记-04对象","url":"/2023/05/26/JavaScript笔记-04对象/","content":"\n\n# 一、概述\n\n## 1.1、什么是对象\n\n​\t\t现实生活中：万物皆对象，对象是一个具体的事物，看得见摸得着的实物。例如，一本书、一辆汽车、一个人都是“对象”。\n\n## 1.2、为什么需要对象\n\n​\t\t我们知道，JavaScript编程语言，程序开发就是要对现实生活进行模拟，那么在JavaScript中，该如何去描述现实生活中的对象呢？\n\n​\t\t在 JavaScript 中，对象是一组无序的相关**属性**和**方法**的集合，所有的事物都是对象，例如字符串、数值、数组、函数等。\n\n​\t\t对象是由属性和方法组成的。\n\n- 属性：事物的**特征，**在对象中用**属性**来表示（常用名词）\n- 方法：事物的**行为，**在对象中用**方法**来表示（常用动词）\n\n![0061](/assets/JavaScript笔记/0061.png)\n\n## 1.3、数组和对象的对比\n\n​\t\t保存一个值时，可以使用**变量，**保存多个值（一组值，比如说手机的大小，颜色等）时，可以使用**数组。**如果要保存一个人的完整信息呢？例如，将\"张三疯\"的个人的信息保存在数组中的方式为：\n\n![0062](/assets/JavaScript笔记/0062.png)\n\n​\t\tJS 中的对象表达结构更清晰，更强大。张三疯的个人信息在对象中的表达结构如下：\n\n![0063](/assets/JavaScript笔记/0063.png)\n\n# 二、创建对象的方式\n\n## 2.1、概述\n\n​\t\t在 JavaScript 中，现阶段我们可以采用三种方式创建对象（object）：\n\n- 字面量方式\n- 利用new Object方式\n- 构造函数方式\n\n## 2.2、字面量方式\n\n### 2.2.1、对象定义\n\n​\t\t对象字面量：就是花括号 `{ }` 里面包含了表达这个具体事物（对象）的属性和方法。`{ }` 里面采取键值对的形式表示。\n\n- 键：相当于属性名\n- 值：相当于属性值，可以是任意类型的值（数字类型、字符串类型、布尔类型，函数类型等）\n\n```html\n<script>\n        var obj = {\n            username: '张三',\n            age: 12,\n            sayHi: function() {\n                console.log(\"Hi......\");\n            }\n        }\n        // 多个属性或者方法中间用逗号隔开的\n        // 方法冒号后面跟的是一个匿名函数\n</script>\n```\n\n### 2.2.2、对象调用\n\n- 对象里面的属性调用 : 对象.属性名 ，这个小点 . 就理解为“ 的 **”** \n- 对象里面属性的另一种调用方式 : 对象[‘属性名’]**，**注意方括号里面的属性必须加引号，我们后面会用 \n- 对象里面的方法调用：对象.方法名() **，**注意这个方法名字后面一定加括号\n\n```html\n<script>\n        var obj = {\n            username: '张三',\n            age: 12,\n            sayHi: function() {\n                console.log(\"Hi......\");\n            }\n        }\n\n        // 对象的调用\n        // >> 1、对属性的调用\n        // >>>> 1.1 方式一： 对象.属性名\n        console.log(obj.username);\n\n        // >>>> 1.2 方式二： 对象['属性名']\n        console.log(obj['age']);\n\n\n        // >> 2、对方法的调用. 对象名.方法名()\n        obj.sayHi();\n</script>\n```\n\n## 2.3、new Object方式\n\n### 2.3.1、案例\n\n```html\n<script>\n        var obj = new Object();\n\n        // >> 添加属性\n        obj.username = \"张三丰\";\n        obj['age'] = 23;\n\n        // >> 添加方法\n        obj.sayHi = function() {\n            console.log(\"Hi\");\n        }\n\n        // 对象调用\n        // 属性\n        console.log(obj['username']);\n        console.log(obj.age);\n        // 方法\n        obj.sayHi();\n</script>\n```\n\n### 2.3.2、注意点\n\n- Object() ：第一个字母大写\n- new Object() ：需要 new 关键字\n- 使用的格式：对象.属性 = 值; \n\n## 2.4、构造函数方式\n\n### 2.4.1、为什么需要构造函数方式\n\n```markdown\n# 原因: 就是因为我们前面两种创建对象的方式一次只能创建一个对象\n```\n\n```html\n<script>\n   \t// 定义张三对象\n    var zhangsan = {\n        \tusername: '张三',\n            age: 34,\n            eat: function() {\n            \t   console.log('吃饭');\n            }\n    }\n    \n    // 定义李四对象\n    var lisi = {\n            username: 'lisi',\n            age: 23,\n            eat: function() {\n                console.log('吃饭');\n            }\n    }\n\n    /***\n      *   1、因为我们一次创建一个对象，里面很多的属性和方法是大量相同的 我们只能复制，存在冗余\n      *   2、我们可以利用函数的方式 重复这些相同的代码 我们就把这个函数称为 构造函数\n      *      (因为之前在讲函数的时候，函数的作用就是可以重复利用代码)\n      *   3、为什么又要叫构造函数呢？\n      *      因为此函数和之前学习的函数不一样，这里的函数里面封装的不是普通代码，而是对象(相同的属性和方法)\n      *   4、总结\n      *      构造函数 就是把我们对象里面一些相同的属性和方法抽象出来封装到函数里面  \n      * /\n</script>\n```\n\n### 2.4.2、利用构造函数创建对象\n\n```html\n<script>\n\t// 定义构造函数(是一类对象，都具有相同的属性和方法)\n    function Person(username, age, sex) {\n        this.username = username;\n        this.age = age;\n        this.sex = sex;\n        this.sayHi = function() {\n           alert('名字叫：' + this.username + '，年龄：' + this.age + '，性别：' + this.sex);\n        }\n    }\n\n    // 通过构造函数创建对象\n    // >> 创建张三\n    var zhangsan = new Person(\"张三\", 10, \"男\");\n    console.log(zhangsan.username);\n    console.log(zhangsan['sex']);\n    zhangsan.sayHi();\n\n    // >> 创建李四\n    var lisi = new Person(\"李四\", 20, \"女\");\n    console.log(lisi.username);\n    console.log(lisi['sex']);\n    lisi.sayHi();\n</script>\n```\n\n​\t\t**注意**\n\n1. 构造函数约定首字母大写。 \n\n2. 函数内的属性和方法前面需要添加 this ，表示当前对象的属性和方法。\n\n3. 构造函数中不需要 return 返回结果，其实当我们new的时候，函数已经将当前的this进行了return。\n\n4. 当我们创建对象的时候，必须用 new 来调用构造函数。\n\n### 2.4.3、总结\n\n​\t\t**构造函数 ：**是一种特殊的函数，主要用来初始化对象，即为对象成员变量赋初始值，它总与 new 运算符一起使用。我们可以把对象中一些公共的属性和方法抽取出来，然后封装到这个函数里面。 \n\n​\t\t在 js 中，使用构造函数要时要注意以下两点：\n\n- 构造函数用于创建某一类对象，其首字母要大写\n- 构造函数要和 new 一起使用才有意义\n\n### 2.4.5、构造函数和对象的区别\n\n- 构造函数，如 Person()，抽象了对象的公共部分，封装到了函数里面，它泛指某一大类（class） \n- 对象，如 new Person()，特指某一个，通过 new 关键字创建对象的过程我们也称为对象实例化\n\n![0064](/assets/JavaScript笔记/0064.png)\n\n### 2.4.6、new 关键字的执行过程\n\n```html\n<script>\n    // 定义构造函数(是一类对象，都具有相同的属性和方法)\n    function Person(username, age, sex) {\n        this.username = username;\n        this.age = age;\n        this.sex = sex;\n        this.sayHi = function() {\n         alert('我的名字叫：' + this.username + '，年龄：' + this.age + '，性别：' + this.sex);\n        }\n     }\n\n     // 通过构造函数创建对象\n     /**\n            new 关键字执行过程:\n            1、 首先 new 构造函数在内存中创建了一个空的对象\n            2、 this 就会指向刚才创建的空对象\n            3、 执行构造函数里面的代码 给这个空对象添加属性和方法\n            4、 返回这个对象\n            5、 将这个对象的内存地址赋值给var声明的变量\n     */\n     var zhangsan = new Person(\"张三\", 10, \"男\");\n     console.log(zhangsan.username);\n     console.log(zhangsan['sex']);\n     zhangsan.sayHi();\n</script>\n```\n\n## 2.5、遍历对象属性\n\n### 2.5.1、说明\n\n​\t\tfor...in 语句用于对数组或者对象的属性进行循环操作。\n\n​\t\t语法：\n\n![0065](/assets/JavaScript笔记/0065.png)\n\n### 2.5.2、案例\n\n```html\n<script>\n     // 定义对象\n     var person = {\n            username: 'HelloWorld',\n            age: 10,\n            sex: '男'\n     };\n\n     // 遍历对象\n     for (var key in person) {\n         console.log(key + \":\" + person[key]);\n     }\n</script>\n```\n\n## 2.6、小结\n\n1. 对象可以让代码结构更清晰\n\n2. 对象是复杂数据类型object。 \n\n3. 本质：对象就是一组无序的相关属性和方法的集合。 \n\n4. 构造函数泛指某一大类，比如苹果，不管是红色苹果还是绿色苹果，都统称为苹果。 \n\n5. 对象实例特指一个事物，比如这个苹果、正在路上飞奔的那辆红色轿车等。\n\n6. for...in 语句用于对对象的属性进行循环操作。\n\n# 三、内置对象\n\n## 3.1、说明\n\n- JavaScript 中的对象分为3种：自定义对象 、内置对象、 浏览器对象\n- 前面两种对象是JS 基础 内容，属于 ECMAScript； 第三个浏览器对象属于我们JS 独有的， 后面讲\n- **内置对象**就是指 JS 语言自带的一些对象，这些对象供开发者使用，并提供了一些常用的或是最基本而必要的功能（属性和方法）\n- 内置对象最大的优点就是帮助我们快速开发\n- JavaScript 提供了多个内置对象：Math、 Date 、Array、String等\n\n![0066](/assets/JavaScript笔记/0066.png)\n\n## 3.2、Math对象\n\n### 3.2.1、说明\n\n​\t\tMath 对象不是构造函数，所以不需要new来调用。它具有数学常数和函数的属性和方法。跟数学相关的运算（求绝对值，取整、最大值等）可以使用 Math 中的成员。\n\n### 3.2.2、最大值\n\n```html\n<script>\n     console.log(Math.PI);               // 3.1415926\n     console.log(Math.max(10, 23, 18));  // 23\n     console.log(Math.max(1, 2, 'abc')); // NaN\n</script>\n```\n\n### 3.2.3、绝对值\n\n```html\n<script>\n    console.log(Math.abs(-10)); // 10\n    console.log(Math.abs(10)); // 10\n    console.log(Math.abs('-20')); // 20,会把字符串'-20'隐式转换为数字类型\n    console.log(Math.abs('abc')); // NaN\n</script>\n```\n\n### 3.2.4、取整\n\n```html\n<script>\n        // 3个取整方法\n        // >> Math.floor() 向下取整,往最小了取值\n        console.log(Math.floor(1.1)); // 1\n        console.log(Math.floor(1.9)); // 1\n        console.log(Math.floor(-1.1)); // -2\n        console.log(Math.floor(-1.9)); // -2\n\n        // >> Math.ceil()  向上取整  往最大了取值\n        console.log(Math.ceil(1.1)); // 2\n        console.log(Math.ceil(1.9)); // 2\n        console.log(Math.ceil(-1.1)); // -1\n        console.log(Math.ceil(-1.9)); // -1 \n\n        // >> Math.round()   四舍五入\n        console.log(Math.round(1.1)); // 1\n        console.log(Math.round(1.9)); // 2\n        console.log(Math.round(-1.1)); // -1\n        console.log(Math.round(-1.9)); // -2\n\n        // 特殊: 其他数字都是四舍五入，但是 .5 特殊 它往大了取\n        console.log(Math.round(-1.5)); // 这个结果是 -1\n</script>\n```\n\n### 3.2.5、随机数\n\n​\t\trandom() 方法可以随机返回一个小数，其取值范围是 [0，1)，左闭右开 0 <= x < 1 \n\n​\t\t得到一个两数之间的随机整数，包括两个数在内：\n\n![0067](/assets/JavaScript笔记/0067.png)\n\n```html\n<script>\n    /*\n        两个数之间的随机整数 并且 包含这2个整数:\n           Math.floor(Math.random() * (max - min + 1)) + min;\n    */\n    function getRandom(min, max) {\n       \treturn Math.floor(Math.random() * (max - min + 1)) + min;\n    }\n\n    console.log(getRandom(2, 13));\n</script>\n```\n\n```html\n<script>\n   // 两个数之间的随机整数 并且 包含这2个整数:\n   function getRandom(min, max) {\n        return Math.floor(Math.random() * (max - min + 1)) + min;\n   }\n\n   // 随机点名\n   var arrs = ['张三', '李四', '王五', '赵六', '麻七'];\n   console.log(arrs[getRandom(0, arrs.length - 1)]);\n</script>\n```\n\n## 3.3、日期对象\n\n### 3.3.1、说明\n\n- Date 对象和 Math 对象不一样，是一个构造函数，必须使用new，所以我们需要实例化后才能使用\n-  Date 实例用来处理日期和时间\n\n### 3.3.2、方法的使用\n\n```html\n<script>\n    // 如果没有参数 返回当前系统的当前时间\n    var date = new Date();\n    console.log(date);\n</script>\n```\n\n```html\n<script>\n    // 数字型参数  2021, 10, 01  \n    var date = new Date(2021, 10, 8);\n    console.log(date); // 注意：返回的是11月\n</script>\n```\n\n```html\n<script>\n    // 数字型参数  2021, 10, 01  \n    var date = new Date('2021-10-08 12:12:12');\n    console.log(date); // 注意：返回的是11月\n</script>\n```\n\n- 如果Date()不写参数，就返回当前时间\n- 如果Date()里面写参数，就返回括号里面输入的时间\n\n### 3.3.3、日期格式化\n\n![0068](/assets/JavaScript笔记/0068.png)\n\n```html\n<script>\n    var date = new Date();\n    console.log(date.getFullYear()); // 返回当前的年\n    console.log(date.getMonth() + 1); // 月份 返回的月份小1个月,记得月份+1\n    console.log(date.getDate()); // 返回的是几号\n    console.log(date.getDay()); // 返回的是周几\n</script>\n```\n\n```html\n<script>\n   // 需求：格式化日期,得到 2021年10月09日 星期三\n   var date = new Date();\n   var year = date.getFullYear();\n   var month = date.getMonth() + 1;\n   var dates = date.getDate();\n   var day = date.getDay();\n   var arrs = ['星期日', '星期一', '星期二', '星期三', '星期四', '星期五', '星期六'];\n\n   // 拼接\n   var result = year + \"年 \" + month + \" 月 \" + dates + \" 日 \" + arrs[day];\n\n   console.log(result);\n</script>\n```\n\n```html\n<script>\n    // 获取时分秒\n    var date = new Date();\n    console.log(date.getHours()); // 小时\n    console.log(date.getMinutes()); // 分\n    console.log(date.getSeconds()); // 秒\n</script>\n```\n\n```html\n<script>\n   \t// 需求: 封装一个函数，返回当前的时分秒\n    function getTime() {\n        var date = new Date();\n        var h = date.getHours();\n        h = h < 10 ? '0' + h : h;\n        var m = date.getMinutes();\n        m = m < 10 ? '0' + m : m;\n        var s = date.getSeconds();\n        s = s < 10 ? '0' + s : s;\n\n        return h + \":\" + m + \":\" + s;\n    }\n\n    console.log(getTime());\n</script>\n```\n\n### 3.3.4、获取毫秒数\n\n```html\n<script>\n    // 获取距离1970年1月1日到现在为止总的毫秒数\n    var date = new Date();\n\n    // >> 方式一\n    console.log(date.valueOf());\n\n    // >> 方式二\n    console.log(date.getTime());\n\n    // >> 方式三\n    var date1 = +new Date();\n    console.log(date1);\n\n    // >> 方式四【H5新增的】\n    console.log(Date.now());\n</script>\n```\n\n### 3.3.5、案例\n\n​\t\t倒计时效果。\n\n![0069](/assets/JavaScript笔记/0069.png)\n\n```markdown\n# 思路\n  1. 输入的时间减去现在的时间就是剩余的时间，即倒计时 ，但是不能拿着时分秒相减，比如 05 分减去25分，结果会是负数的。\n  2. 用时间戳来做。用户输入时间总的毫秒数减去现在时间的总的毫秒数，得到的就是剩余时间的毫秒数。\n  3. 把剩余时间总的毫秒数转换为天、时、分、秒 （时间戳转换为时分秒）\n  4. 转换公式如下： \n      d = parseInt(总秒数/ 60/60 /24);    //  计算天数\n      h = parseInt(总秒数/ 60/60 %24)   //   计算小时\n      m = parseInt(总秒数 /60 %60 );     //   计算分数\n      s = parseInt(总秒数%60);            //   计算当前秒数\n```\n\n```html\n<script>\n    // 倒计时\n    function timeDown(time) {\n       \tvar nowTime = +new Date(); // 返回的是当前时间总的毫秒数\n        var inputTime = +new Date(time); // 返回的是用户输入时间总的毫秒数\n        var times = (inputTime - nowTime) / 1000; // 剩余时间总的秒数\n        var d = parseInt(times / 60 / 60 / 24); // 天\n        d = d < 10 ? '0' + d : d;\n        var h = parseInt(times / 60 / 60 % 24); //时\n        h = h < 10 ? '0' + h : h;\n        var m = parseInt(times / 60 % 60); // 分\n        m = m < 10 ? '0' + m : m;\n        var s = parseInt(times % 60); // 当前的秒\n        s = s < 10 ? '0' + s : s;\n        return d + '天' + h + '时' + m + '分' + s + '秒';\n    }\n    console.log(timeDown('2021-10-09 17:53:00'));\n</script>\n```\n\n## 3.4、数组对象\n\n### 3.4.1、检测一个对象是否是数组类型\n\n- instanceof 运算符，可以判断一个对象是否属于某种类型\n- Array.isArray()用于判断一个对象是否为数组，isArray() 是 HTML5 中提供的方法\n\n```html\n<script>\n   \t// 检测是否为数组\n    var arrs = [];\n    var obj = {};\n\n    // 方式一： instanceof 运算符\n    console.log(arrs instanceof Array); // true\n    console.log(obj instanceof Array); // false\n\n    // 方式二：Array.isArray(参数);  H5新增的方法  ie9以上版本支持\n    console.log(Array.isArray(arrs)); // true\n    console.log(Array.isArray(obj)); // false\n</script>\n```\n\n### 3.4.2、添加删除数组元素的方法\n\n![0070](/assets/JavaScript笔记/0070.png)\n\n```html\n <script>\n     // 添加删除数组元素的方法\n     var arrs = [1, 2, 3, 4];\n\n     // >> push() 在我们数组的末尾 添加一个或者多个数组元素，返回数组的长度\n     console.log(arrs.push(5, 'Hello'));\n     console.log(arrs);\n\n     // >> unshift() 在数组的开头 添加一个或者多个数组元素，返回数组的长度\n     console.log(arrs.unshift('javascript'));\n     console.log(arrs);\n\n     // >> pop() 删除数组的最后一个元素,一次只能删除一个元素,返回的是被删除的元素\n     console.log(arrs.pop());\n     console.log(arrs);\n\n     // >> shift() 删除数组的第一个元素,一次只能删除一个元素, 返回的是被删除的元素\n     console.log(arrs.shift());\n     console.log(arrs);\n</script>\n```\n\n### 3.4.3、数组排序的方法\n\n![0071](/assets/JavaScript笔记/0071.png)\n\n```html\n<script>\n    // 数组排序\n    // >> reverse() 翻转数组\n    var arrs = [1, 2, 3, 4, 5];\n    arrs.reverse();\n    console.log(arrs);\n\n    // >> sort() 排序\n    var arrs2 = [11, 3, 21, 16, 34, 1];\n    arrs2.sort(function(a, b) { // 自定义排序\n        return a - b;\n    });\n    console.log(arrs2);\n</script>\n```\n\n### 3.4.4、数组索引的方法\n\n![0072](/assets/JavaScript笔记/0072.png)\n\n```html\n<script>\n    // 返回数组元素索引号的方法\n    // >> indexOf(数组元素) 作用就是返回该数组元素的索引号 从前面开始查找\n    //          注1：它只返回第一个满足条件的索引号\n    //          注2：如果在该数组里面找不到元素，则返回的是 -1\n    var arrs = ['HTML', 'CSS', 'JavaScript', 'Hello', 'CSS'];\n    console.log(arrs.indexOf('CSS'));\n\n    // >> lastIndexOf(数组元素)  作用就是返回该数组元素的索引号 从后面开始查找\n    console.log(arrs.lastIndexOf('CSS'));\n</script>\n```\n\n```html\n<script>\n    // 数组去重 ['c', 'a', 'z', 'a', 'x', 'a', 'x', 'c', 'b'] 要求去除数组中重复的元素。\n    /**\n    *  目标：\n    *      把旧数组里面不重复的元素选取出来放到新数组中， 重复的元素只保留一个， 放到新数组中去重。\n    *  算法：\n    *      我们遍历旧数组， 然后拿着旧数组元素去查询新数组， 如果该元素在新数组里面没有出现过， 我们就添\t\t\t   加， 否则不添加。\n    *  我们怎么知道该元素没有存在？ \n    *      利用 新数组.indexOf(数组元素) 如果返回时 - 1 就说明 新数组里面没有改元素、\n    */\n\n    function getUnique(arrs) {\n    \tvar newArrs = [];\n        for (var i = 0; i < arrs.length; i++) {\n           if (newArrs.indexOf(arrs[i]) === -1) {\n              // 表示不存在\n              newArrs.push(arrs[i]);\n           }\n        }\n        return newArrs;\n     }\n     var arrs = ['c', 'a', 'z', 'a', 'x', 'a', 'x', 'c', 'b'];\n     var result = getUnique(arrs);\n     console.log(result);\n</script>\n```\n\n### 3.4.5、数组转换为字符串\n\n![0073](/assets/JavaScript笔记/0073.png)\n\n```html\n<script>\n   // 数组转换为字符串\n   // >> toString() 将数组转换为字符串,数组元素用逗号分隔\n   var arrs = [1, 2, 3];\n   console.log(arrs.toString());\n\n   // >> join(分隔符) 将数组元素按照指定的分隔符进行连接\n   var result = arrs.join('_');\n   console.log(result);\n</script>\n```\n\n### 3.4.6、数组的其他方法\n\n![0074](/assets/JavaScript笔记/0074.png)\n\n```html\n<script>\n    // 数组的其他方法： 连接\n    // >> concat() 连接两个或多个数组, 方法不会更改现有数组，而是返回一个新数组\n    var arrs1 = [1, 2, 3];\n    var arrs2 = [4, 5, 6];\n    var arrs3 = [7, 8, 9];\n    var result = arrs1.concat(arrs2, arrs3);\n    console.log(result);\n</script>\n```\n\n```html\n<script>\n    // 数组的其他方法: 截取\n    // >> slice(start,end) 从给定的start参数开始的元素，并在给定的end参数处结束(不包括end)\n    var arrs = [1, 2, 3, 'Java', 'Hello', 'js', 7, 9];\n    var result = arrs.slice(2, 5);\n    console.log(arrs);\n    console.log(result);\n</script>\n```\n\n```html\n<script>\n    // 数组的其他方法: 截取\n    // >> splice(index, howmany) 从数组指定位置删除指定个数的元素，并返回删除的元素。\n    var arrs = [1, 2, 3, 'Java', 'Hello', 'js', 7, 9];\n    var result = arrs.splice(2, 5);\n    console.log(arrs); // [1, 2, 9]  删除,会影响原数组\n    console.log(result); // [3, 'Java', 'Hello', 'js', 7]\n</script>\n```\n\n## 3.5、字符串对象\n\n### 3.5.1、根据字符返回位置\n\n​\t\t字符串所有的方法，都不会修改字符串本身(字符串是不可变的)，操作完成会返回一个新的字符串。\n\n![0075](/assets/JavaScript笔记/0075.png)\n\n```html\n<script>\n   \t// 字符串对象  根据字符返回位置  str.indexOf('要查找的字符', [起始的位置])\n    var str = '改革春风吹满地，春天来了';\n    console.log(str.indexOf('春'));\n    console.log(str.indexOf('春', 3)); // 从索引号是 3的位置开始往后查找\n</script>\n```\n\n### 3.5.2、根据位置返回字符\n\n![0076](/assets/JavaScript笔记/0076.png)\n\n```html\n<script>\n    // 根据位置返回字符\n    // 1. charAt(index) 根据位置返回字符\n    var str = 'JavaScript';\n    console.log(str.charAt(3));\n\n    // 2. charCodeAt(index)  返回相应索引号的字符ASCII值 目的： 判断用户按下了那个键\n    console.log(str.charCodeAt(1)); // 97\n\n    // 3. str[index] H5 新增的\n    console.log(str[6]);\n</script>\n```\n\n### 3.5.3、字符串的其他方法\n\n```html\n<script>\n    // 字符串的其他方法\n    // 1. substr('截取的起始位置', '截取几个字符');\n    var str = 'JavaScript';\n    console.log(str.substr(3, 6));\n\n    // 2. substring('截取的起始位置', '截取的结束位置');\n    console.log(str.substring(3, 6));\n\n    // 3. replace('被替换的字符', '替换为的字符')  它只会替换第一个字符,返回新的字符串\n    console.log(str.replace('a', 'A'));\n\n    // 4. split('分隔符') 返回的结果是一个数组\n    var str2 = 'Hello,java,Spring';\n    var arrs = str2.split(',')\n    console.log(arrs);\n</script>\n```\n\n# 四、简单类型与复杂类型\n\n## 4.1、概述\n\n​\t\t简单类型又叫做基本数据类型或者值类型，复杂类型又叫做引用类型。 \n\n- 值类型：简单数据类型/基本数据类型，在存储时变量中存储的是值本身，因此叫做值类型\n\n  ​\t\tstring ，number，boolean，undefined，null\n\n- 引用类型：复杂数据类型，在存储时变量中存储的仅仅是地址（引用），因此叫做引用数据类型\n\n  ​\t\t通过 new 关键字创建的对象（系统对象、自定义对象），如 Object、Array、Date等\n\n## 4.2、堆和栈\n\n​\t\t堆栈空间分配区别：\n\n　　1、栈：存储的是函数的参数值、局部变量的值等。其操作方式类似于数据结构中的栈；\n\n​\t\t\t \t\t**简单数据类型存放到栈里面**\n\n​\t\t2、堆：存储复杂类型(对象)，一般由程序员分配释放，若程序员不释放，由垃圾回收机制回收。\n\n​\t\t\t\t\t **复杂数据类型存放到堆里面**\n\n![0077](/assets/JavaScript笔记/0077.png)\n\n\n\n## 4.3、简单类型的内存分配\n\n- 值类型（简单数据类型）： string ，number，boolean，undefined，null\n- 值类型变量的数据直接存放在变量（栈空间）中\n\n![0078](/assets/JavaScript笔记/0078.png)\n\n## 4.4、复杂类型的内存分配\n\n- 引用类型（复杂数据类型）：通过 new 关键字创建的对象（系统对象、自定义对象），如 Object、Array、Date等 \n- 引用类型变量（栈空间）里存放的是地址，真正的对象实例存放在堆空间中\n\n![0079](/assets/JavaScript笔记/0079.png)\n\n## 4.5、简单数据类型传参\n\n​\t\t函数的形参也可以看做是一个变量，当我们把一个值类型变量作为参数传给函数的形参时，其实是把变量在栈空间里的值复制了一份给形参，那么在方法内部对形参做任何修改，都不会影响到的外部变量。\n\n```html\n<script>\n    var x = 10;\n\n    function fn(a) {\n        a++;\n        console.log(a); // 11\n    }\n\n    fn(x);\n    console.log(x); // 10\n</script>\n```\n\n![0080](/assets/JavaScript笔记/0080.png)\n\n## 4.6、复杂数据类型传参\n\n​\t\t函数的形参也可以看做是一个变量，当我们把引用类型变量传给形参时，其实是把变量在栈空间里保存的堆地址复制给了形参，形参和实参其实保存的是同一个堆地址，所以操作的是同一个对象。\n\n```html\n<script>\n   function Person(name) {\n        this.name = name;\n   }\n\n   function f1(x) {\n   \t    console.log(x.name);\n        x.name = \"张学友\";\n        console.log(x.name);\n   }\n\n   var p = new Person(\"刘德华\");\n   console.log(p.name);\n   f1(p);\n   console.log(p.name);\n</script>\n```\n\n![0081](/assets/JavaScript笔记/0081.png)\n\n","tags":["JavaScript","学习笔记"],"categories":["JavaScript笔记"]},{"title":"JavaScript笔记-03函数与作用域","url":"/2023/05/26/JavaScript笔记-03函数与作用域/","content":"\n\n# 一、概述\n\n## 1.1、定义\n\n```markdown\n# 函数：就是封装了一段可被重复调用执行的代码块。通过此代码块可以实现大量代码的重复使用。\n```\n\n## 1.2、函数的使用\n\n### 1.2.1、说明\n\n​\t\t函数在使用时分为两步：**声明函数**和**调用函数**。\n\n### 1.2.2、声明函数\n\n![0048](/assets/JavaScript笔记/0048.png)\n\n- function 是声明函数的关键字，必须小写\n- 函数表示的是做某件事情，函数名一般是动词形式\n- 函数必须经过调用之后，才能执行函数体代码\n\n```html\n<script>\n   \t// 声明函数\n    function sayHi() {\n        console.log(\"世界,你好！\");\n    }\n</script>\n```\n\n### 1.2.3、调用函数\n\n![0049](/assets/JavaScript笔记/0049.png)\n\n- 调用的时候千万**不要忘记添加小括号**\n- 口诀：函数不调用，自己不执行。\n- **注意：**声明函数本身并不会执行代码，只有调用函数时才会执行函数体代码\n\n```html\n<script>\n   \t// 声明函数\n    function sayHi() {\n        console.log(\"世界,你好！\");\n    }\n    \n    // 调用函数\n    sayHi();\n</script>\n```\n\n## 1.3、函数的封装\n\n### 1.3.1、概念\n\n- 函数的封装是把一个或者多个功能通过**函数的方式封装起来**，对外只提供一个简单的函数接口。\n- 简单理解：封装类似于将电脑配件整合组装到机箱中 ( 类似快递打包） \n\n![0050](/assets/JavaScript笔记/0050.png)\n\n### 1.3.2、案例\n\n​\t\t需求：利用函数计算1-100之间的累加和。\n\n```html\n<script>\n   \t// 声明函数\n    function getSum() {\n        var sum = 0;\n        for (var i = 1; i <= 100; i++) {\n            sum = sum + i;\n        }\n        console.log(\"1到100的和是:\" + sum);\n    }\n    // 调用函数\n    getSum();\n</script>\n```\n\n# 二、函数的参数\n\n## 2.1、形参和实参\n\n- 在**声明函数**时，可以在函数名称后面的小括号中添加一些参数，这些参数被称为**形参**\n- **调用该函数**时，同样也需要传递相应的参数，这些参数被称为**实参**。\n\n|   参数   |                             说明                             |\n| :------: | :----------------------------------------------------------: |\n| **形参** | **形**式上的**参**数 **函数定义**的时候 传递的参数 当前并不知道是什么 |\n| **实参** | **实**际上的**参**数 **函数调用**的时候 传递的参数 实参是传递给形参的 |\n\n==**参数的作用** : 在**函数内部**某些值不能固定，我们可以通过参数在**调用函数时传递**不同的值进去。==\n\n![0051](/assets/JavaScript笔记/0051.png)\n\n```html\n<script>\n    // 在声明函数的小括号里面是 形参 （形式上的参数）\n    function 函数名(形参1, 形参2, ...) {\n\n    }\n\n    // 在函数调用的小括号里面是实参（实际的参数）\n    函数名(实参1, 实参2, ...);\n</script>\n```\n\n```html\n<script>\n    // 利用函数求任意两个数之间的和\n    function getSum(start, end) {\n        var sum = 0;\n        for (var i = start; i <= end; i++) {\n            sum = sum + i;\n        }\n        console.log(start + \"到\" + end + \"之间的和是:\" + sum);\n    }\n    // 调用函数\n    getSum(1, 100);\n</script>\n```\n\n## 2.2、函数参数的传递过程\n\n![0052](/assets/JavaScript笔记/0052.png)\n\n- 调用的时候实参值是传递给形参的\n- 形参简单理解为：**不用声明的变量**\n- 实参和形参的多个参数之间用逗号（,）分隔\n\n## 2.3、函数形参和实参个数不匹配问题\n\n### 2.3.1、形参和实参个数相等\n\n```html\n<script>\n  \t// 利用函数求任意两个数的和\n    function getSum(num1, num2) {\n        console.log(num1);             //  1\n        console.log(num2);             // 100\n        console.log(num1 + num2);      // 101\n    }\n    // 调用函数\n    getSum(1, 100);\n</script>\n```\n\n```markdown\n# 如果实参的个数和形参的个数一致 则正常输出结果\n```\n\n### 2.3.2、实参个数多于形参\n\n```html\n<script>\n    // 利用函数求任意两个数的和\n    function getSum(num1, num2) {\n       \tconsole.log(num1);          //  20\n        console.log(num2);          //  30\n        console.log(num1 + num2);   //  50\n    }\n    // 调用函数\n    getSum(20, 30, 200, 300);\n</script>\n```\n\n```markdown\n# 实参个数多于形参，只取到形参的个数\n```\n\n### 2.3.3、实参个数少于形参\n\n```html\n<script>\n    // 利用函数求任意两个数的和\n    function getSum(num1, num2) {\n       \tconsole.log(num1);             //  20\n       \tconsole.log(num2);             //  undefined\n        console.log(num1 + num2);      //  NaN\n    }\n    // 调用函数\n    getSum(20);\n</script>\n```\n\n```markdown\n# 实参个数少于形参，多的形参定义为undefined，结果为NaN\n# 形参可以看做是不用声明的变量  num2 是一个变量但是没有接受值  结果就是undefined \n```\n\n### 2.3.4、总结\n\n- 建议 我们尽量让实参的个数和形参相匹配\n- 在JavaScript中，形参的默认值是**undefined**。\n\n## 2.4、小结\n\n- 函数可以带参数也可以不带参数\n- 声明函数的时候，函数名括号里面的是形参，形参的默认值为 undefined\n- 调用函数的时候，函数名括号里面的是实参\n- 多个参数中间用逗号分隔\n- 形参的个数可以和实参个数不匹配，但是结果不可预计，我们尽量要匹配\n\n# 三、函数的返回值\n\n## 3.1、return语句\n\n​\t\t有的时候，我们会希望函数将值返回给调用者，此时通过使用 return 语句就可以实现。\n\n​\t\t例如，声明了一个sum()函数，该函数的返回值为666，其代码如下：\n\n![0053](/assets/JavaScript笔记/0053.png)\n\n- 在使用 return 语句时，函数会停止执行，并返回指定的值\n- **如果函数没有 return ，返回的值是 undefined**\n\n```html\n<script>\n    // 利用函数求任意一个数组中的最大值\n    function getMax(arrs) {\n       \tvar max = arrs[0];\n        for (var i = 1; i <= arrs.length; i++) {\n            if (max < arrs[i]) {\n                max = arrs[i];\n            }\n        }\n        return max;\n    }\n    // 调用函数\n    var arrs = [10, 13, 56, 73, 48, 19];\n    var max = getMax(arrs);\n    console.log(\"最大值是:\" + max);\n</script>\n```\n\n## 3.2、return 终止函数\n\n​\t\treturn 语句之后的代码不被执行。\n\n```html\n<script>\n    function getSum(num1, num2) {\n        return num1 + num2;\n        alert(\"我不会被执行,前面有 return\");\n   \t}\n   \t// 调用函数\n    var sum = getSum(10, 20);\n    console.log(\"和是:\" + sum);\n</script>\n```\n\n## 3.3、return 的返回值\n\n```html\n<script>\n    function fn(num1, num2) {\n     \treturn num1, num2;\n    }\n    // 调用函数\n    var result = fn(10, 20);\n    console.log(\"结果是:\" + result);\n</script>\n```\n\n## 3.4、函数没有 return 返回 undefined\n\n```html\n<script>\n   \tfunction fn(num1, num2) {\n    \tconsole.log(num1 + num2);    // 30\n    }\n    // 调用函数\n    var result = fn(10, 20);\n    console.log(\"结果是:\" + result); // undefined\n</script>\n```\n\n​\t\t==**函数无论是否有return，函数都是有返回值的。**==\n\n- 如果有return 则返回 return 后面的值\n- 如果没有return 则返回 undefined\n\n## 3.5、break、continue、return 的区别\n\n- break ：结束当前的循环体（如 for、while） \n- continue ：跳出本次循环，继续执行下次循环（如 for、while） \n- return ：不仅可以退出循环，还能够返回 return 语句中的值，同时还可以结束当前的函数体内的代码\n\n## 3.6、类比\n\n![0054](/assets/JavaScript笔记/0054.png)\n\n# 四、arguments的使用\n\n## 4.1、概述\n\n​\t\t当我们不确定有多少个参数传递的时候，可以用 arguments 来获取。在 JavaScript 中，arguments 实际上它是当前函数的一个内置对象。所有函数都内置了一个 arguments 对象，arguments 对象中存储了传递的所有实参。 \n\n​\t\t**arguments展示形式是一个伪数组**，因此可以进行遍历。伪数组具有以下特点：\n\n- 具有 length 属性\n- 按索引方式储存数据\n- 不具有数组的 push , pop 等方法\n\n## 4.2、案例\n\n```html\n<script>\n    // 利用函数求任意个数的最大值\n    function getMax() {\n        var max = arguments[0];\n        for (var i = 1; i <= arguments.length; i++) {\n            if (max < arguments[i]) {\n                 max = arguments[i];\n            }\n   \t\t}\n        return max;\n    }\n    var result1 = getMax(10, 23, 17, 45);\n    console.log(\"最大值是:\" + result1);\n\n    var result2 = getMax(10, 18, 19, 23, 38, 35);\n    console.log(\"最大值是:\" + result2);\n</script>\n```\n\n```markdown\n# arguments 内置对象指的是函数中我实际接受到的参数。\n```\n\n# 五、length的使用\n\n## 5.1、概述\n\n​\t\tlength也是函数的内置对象，表达的含义是：函数期望接受到的参数个数，其实就是函数定义的是时候形参的个数。\n\n## 5.2、案例\n\n```html\n<script>\n    // 利用函数求任意个数的最大值\n    function getMax(num, num2) {\n        console.log(\"实际接收到参数的个数是:\" + arguments.length);\n    }\n    var result1 = getMax.length;\n    console.log(\"期望接受到的参数个数是:\" + result1);\n\n    getMax(10, 20, 30, 40);\n</script>\n```\n\n# 六、函数的两种声明方式\n\n## 6.1、自定义函数方式(命名函数)\n\n​\t\t利用函数关键字 function 自定义函数方式。\n\n![0055](/assets/JavaScript笔记/0055.png)\n\n- 因为有名字，所以也被称为**命名函数**\n- 调用函数的代码既可以放到声明函数的前面，也可以放在声明函数的后面\n\n```html\n<script>\n   \t// 调用函数,可以再定义函数之前进行调用\n    sum();\n\n    // 定义函数\n    function sum() {\n       console.log(\"求和\");\n    }\n</script>\n```\n\n## 6.2、函数表达式方式(匿名函数)\n\n​\t\t利用函数表达式方式的写法如下：\n\n![0056](/assets/JavaScript笔记/0056.png)\n\n- 因为函数没有名字，所以也被称为匿名函数，其实 fn 并不是函数名称，是变量名。\n- 函数表达式声明方式跟声明变量差不多，只不过变量里面存的是值 而 函数表达式里面存的是函数\n- 这个fn变量里面存储的是一个函数 \n- 函数表达式方式原理跟声明变量方式是一致的 \n- **函数调用的代码必须写到函数体后面**\n\n```html\n <script>\n    // 理解：定义了一个fn变量，该变量的值是一个函数\n    var fn = function() {\n        console.log(\"函数表达式的方式定义函数\");\n    }\n    fn();\n</script>\n```\n\n![0057](/assets/JavaScript笔记/0057.png)\n\n# 七、作用域\n\n## 7.1、概念\n\n​\t\t作用域 ： 就是变量在某个范围内起作用和效果。目的是为了提高程序的可靠性，更重要的是减少命名冲突。\n\n​\t\tJavaScript (ES6前) 中的作用域有两种：\n\n- 全局作用域\n- 局部作用域(函数作用域)\n\n## 7.2、全局作用域\n\n​\t\t**作用于所有代码执行的环境(整个 script 标签内部)或者一个独立的 js 文件。**\n\n```html\n<script>\n    // 定义的num变量就是全局作用域\n    \n    var num = 10;\n    var num = 30;\n    console.log(num);   // 30\n</script>\n```\n\n## 7.3、局部作用域/函数作用域\n\n​\t\t**作用于函数内的代码环境，就是局部作用域。 因为跟函数有关系，所以也称为函数作用域。**\n\n```html\n<script>\n    function fn() {\n        var num = 20;\n            console.log(\"num的值是:\" + num); // 20\n    }\n\n    fn();\n\n    console.log(num); // 报错,函数内部的num在函数外部是访问不到的\n</script>\n```\n\n## 7.4、变量的作用域\n\n### 7.4.1、概述\n\n​\t\t根据作用域的不同我们变量分为全局变量和局部变量。\n\n### 7.4.2、全局变量\n\n​\t\t在全局作用域下定义的变量，在全局下都可以使用。\n\n```html\n<script>\n    // 全局作用域下定义的变量是全局变量\n    var num = 10;\n\n    console.log(num);       // 10\n\n    function fn() {\n        console.log(\"在函数中访问num变量:\" + num);\n    }\n\n    fn();\n</script>\n```\n\n```html\n<script>\n    function fn() {\n       // 如果在函数内部 没有声明直接赋值的变量也属于全局变量\n       num = 40;\n    }\n\n    fn();\n    console.log(\"num的值是:\" + num); // 40\n</script>\n```\n\n```markdown\n# 如果在函数内部 没有声明直接赋值的变量也属于全局变量\n```\n\n### 7.4.3、局部变量\n\n​\t\t在局部作用域下定义的变量就是局部变量， 也就是说在函数中没有通过`var`关键字定义的变量就是局部变量。\n\n```markdown\n# 注： 函数的形参也可以看做是局部变量\n```\n\n```html\n<script>\n    function fn() {\n       var num = 30; // 局部变量,只能在此函数内部使用\n   \t}\n\n    fn();\n    console.log(\"num的值是:\" + num); // 报错\n</script>\n```\n\n## 7.5、JS 没有块级作用域\n\n### 7.5.1、概述\n\n​\t\t在ES6之前（即目前阶段），JavaScript中没有块级作用域，只有全局作用域和局部作用域。\n\n​\t\t关于块级作用域是在ES6版本才新增的，这个以后再讲。\n\n​\t\t块级作用域：\n\n- 由`{}`包裹起来的，比如说`if`、`while`这些语句。\n\n### 7.5.2、案例\n\n```html\n<script>\n   if (true) {\n       var num = 21;\n       console.log(\"num的值是:\" + num);\n   }\n\n   console.log(\"值是\" + num);\n</script>\n```\n\n## 7.6、作用域链\n\n### 7.6.1、概述\n\n- 内部函数访问外部函数的变量，采取的是链式查找的方式来决定取那个值 这种结构我们称为作用域链。\n- 采取**就近原则**的方式来查找变量最终的值。\n\n### 7.6.2、案例1\n\n```html\n<script>\n   var num = 456;\n\n   function f1() {\n      var num = 123;\n\n      function f2() {\n           var num = 0;\n           console.log(num); // 站在目标出发，一层一层的往外查找\n      }\n      f2();\n   }\n   f1();\n</script>\n```\n\n# 八、预解析\n\n## 8.1、问题引入\n\n### 8.1.1、案例1\n\n```html\n<script>\n    console.log(num); // 报错,  num is not defined\n</script>\n```\n\n### 8.1.2、案例2\n\n```html\n<script>\n    console.log(num); \t// undefined\n    var num = 20;\n</script>\n```\n\n### 8.1.3、案例3\n\n```html\n<script>\n   \t// 命名函数(自定义函数方式):我们把函数调用放在函数声明上面,发现也可以\n    fn();\n\n    function fn() {\n       console.log(\"1111\"); // 1111\n    }\n</script>\n```\n\n### 8.1.4、案例4\n\n```html\n<script>\n   \t// 匿名函数(函数表达式方式):我们把函数调用放在函数声明上面\n    fn();\n\n    var fn = function() {\n      \tconsole.log('22222');\n    }\n</script>\n```\n\n## 8.2、概念\n\n​\t\tJavaScript 代码是由浏览器中的 JavaScript 解析器（js引擎）来执行的。JavaScript 解析器在运行 JavaScript 代码的时候分为两步：**预解析和代码执行。**\n\n- **预解析**：js引擎会把js里面所有的 **var** 、 **function** 提升到**当前作用域**的最前面。\n- **代码执行**：从上到下执行JS语句\n\n​\t\t预解析只会发生在通过 var 定义的变量和 function 上。学习预解析能够让我们知道**为什么在变量声明之前访问变量的值是 undefined**，**为什么在函数声明之前就可以调用函数。**\n\n### 8.2.1、变量预解析(变量提升)\n\n​\t\t变量提升：变量的声明会被提升到**当前作用域**的最上面，变量的赋值不会提升。\n\n![0058](/assets/JavaScript笔记/0058.png)\n\n### 8.2.2、函数预解析(函数提升)\n\n​\t\t函数提升： 函数的声明会被提升到**当前作用域**的最上面，但是不会调用函数。\n\n![0059](/assets/JavaScript笔记/0059.png)\n\n### 8.2.3、解决函数表达式声明调用问题\n\n​\t\t对于函数表达式声明调用需要记住：**函数表达式调用必须写在函数声明的下面。**\n\n![0060](/assets/JavaScript笔记/0060.png)\n\n","tags":["JavaScript","学习笔记"],"categories":["JavaScript笔记"]},{"title":"JavaScript笔记-02数组","url":"/2023/05/26/JavaScript笔记-02数组/","content":"\n# 一、概述\n\n## 1.1、问题\n\n​\t\t思考：之前学习过变量，我们说变量的本质是计算机内存的一块空间，而我们定义的一个变量，一次只能存储一个值，比如说，张三的姓名存储起来，可以定义一个`username`这样的变量。但是问题是：如果我们想存储班级中所有学生的姓名，那么该如何存储呢？\n\n​\t\t答：可以使用数组（Array），数组可以把一组相关的数据一起存放，并提供非常方便的访问（获取）方式。\n\n## 1.2、简介\n\n```markdown\n# 1. 数组(Array)是指一组数据的集合，其中的每个数据被称作元素。\n# 2. 在数组中可以存放任意类型的元素。\n# 3. 存储一组具有“相同数据类型”的数据结构。\n```\n\n![0047](/assets/JavaScript笔记/0047.png)\n\n# 二、创建数组\n\n## 2.1、概述\n\n​\t\t在JavaScript中，创建数组有整体来说，有两种方式。\n\n- 利用 new 创建数组\n- 利用数组字面量创建数组\n\n## 2.2、利用 new 创建数组\n\n### 2.2.1、新建一个长度为0的数组\n\n```html\n<script>\n   // 新建一个长度为0的数组\n   var arr = new Array();\n</script>\n```\n\n### 2.2.2、新建长度为n的数组\n\n```html\n<script>\n   // 新建一个长度为3的数组\n   var arr = new Array(3);\n</script>\n```\n\n### 2.2.3、新建指定长度的数组，并赋值\n\n```html\n<script>\n   // 新建指定长度的数组，并赋值\n   var arr = new Array(1, 2, 3, 4, 5);\n</script>\n```\n\n## 2.3、利用数组字面量创建数组\n\n```html\n<script>\n   \t// 创建了一个空的数组\n   \tvar arr = [];\n    \n    // 创建了一个具有三个元素的数组\n  \tvar arr1 = [\"张三\", \"李四\", \"王五\"]; \n</script>\n```\n\n- 数组的字面量是方括号 `[]`\n- 声明数组并赋值称为数组的初始化\n- 这种字面量方式也是我们以后最多使用的方式\n\n# 三、数组的下标\n\n## 3.1、概述\n\n​\t\t索引 (下标) ：用来访问数组元素的序号（数组下标从 0 开始）。\n\n## 3.2、案例\n\n```html\n<script>\n   // 创建数组并初始化数据\n   var arr = [\"张三\", \"李四\", \"王五\"];\n\n   console.log(arr[0]); // 张三\n   console.log(arr[1]); // 李四\n   console.log(arr[2]); // 王五\n\n   console.log(arr[3]); // undefined,因为没有这个数组元素 所以输出的结果是 undefined\n</script>\n```\n\n# 四、数组的长度\n\n## 4.1、概述\n\n​\t\t使用“数组名.length”可以访问数组元素的数量（数组长度）。\n\n## 4.2、案例\n\n```html\n<script>\n   // 创建数组并初始化数据\n   var arr = [\"张三\", \"李四\", \"王五\"];\n\n   // 通过length获取数组的长度\n   var len = arr.length;\n\n   console.log(\"该数组的长度是：\" + len);\t// 3\n</script>\n```\n\n## 4.3、注意\n\n- 此处数组的长度是**数组元素的个数** ，不要和**数组的索引号**混淆\n\n- ==**当我们数组里面的元素个数发生了变化，这个 length 属性跟着一起变化，即：动态监测数组元素的个数**。==\n\n  ```html\n  <script>\n      // 创建数组并初始化数据\n      var arr = [\"张三\", \"李四\", \"王五\"];\n  \n      var len = arr.length;\n      console.log(\"该数组的长度是：\" + len);\n  \n      // 再额外的添加一个元素\n      arr[3] = '赵六';\n      console.log(\"新添加后，数组的长度是：\" + arr.length); // 4\n  </script>\n  ```\n\n# 五、遍历数组\n\n## 5.1、概述\n\n​\t\t就是把数组的元素从头到尾访问一次。\n\n## 5.2、方式一\n\n```html\n<script>\n   // 创建数组并初始化数据\n   var arr = [\"张三\", \"李四\", \"王五\"];\n\n   // 遍历数组\n   for (var i = 0; i < arr.length; i++) {\n      \tconsole.log(arr[i]);\n   }\n</script>\n```\n\n## 5.3、方式二\n\n```html\n<script>\n    // 创建数组并初始化数据\n    var arr = [\"张三\", \"李四\", \"王五\", \"赵六\"];\n\n    // 遍历数组\n    for (var index in arr) {\n       console.log(arr[index]);\n    }\n</script>\n```\n\n## 5.4、方式三\n\n```html\n<script>\n   // 创建数组并初始化数据\n   var arr = [\"张三\", \"李四\", \"王五\", \"赵六\", \"猪头\"];\n\n   // 遍历数组\n   for (var item of arr) {\n      console.log(item);\n   }\n</script>\n```\n\n# 六、数组中新增元素\n\n## 6.1、通过修改 length 长度新增数组元素\n\n- 可以通过修改 length 长度来实现数组扩容的目的\n- length 属性是可读写的\n\n```html\n<script>\n   \tvar arr = [\"张三\", \"李四\", \"王五\"];\n    console.log(\"数组的长度是:\" + arr.length);\n\n    // 数组的长度修改为了 5  里面应该有5个元素\n    arr.length = 5;\n    console.log(arr[3]); // undefined\n    console.log(arr[4]); // undefined\n</script>\n```\n\n## 6.2、通过修改数组索引新增数组元素\n\n- 可以通过修改数组索引的方式追加数组元素\n\n```html\n<script>\n    var arr = [\"张三\", \"李四\", \"王五\"];\n    console.log(\"数组的长度是:\" + arr.length);\n\n    // 通过修改索引的方式新增数组元素\n    arr[5] = '赵六';\n    \n    console.log(arr[3]); // undefined\n    console.log(arr[4]); // undefined\n    console.log(arr[5]); // 赵六\n</script>\n```\n\n# 7、数组练习\n\n## 7.1、案例1\n\n```html\n<script>\n    // 求数组 [2, 6, 1, 7, 4] 里面所有元素的和以及平均值。\n    \n    var sum = 0; // 求和变量\n    var average = 0; // 求平均值变量\n    var arr = [2, 6, 1, 7, 4];\n    for (var i = 0; i < arr.length; i++) {\n     \tsum = sum + arr[i];\n    }\n    average = sum / arr.length;\n\n    // 要输出多个变量，可以使用\",\"进行分隔\n    console.log(sum, average);\n</script>\n```\n\n## 7.2、案例2\n\n```html\n<script>\n    // 求数组[2,6,1,77,52,25,7]中的最大值\n\n    /*\n            思路：\n                1. 声明一个保存最大元素的变量 max。\n                2. 默认最大值可以取数组中的第一个元素。\n                3. 遍历这个数组，把里面每个数组元素和 max 相比较。\n                4. 如果这个数组元素大于max 就把这个数组元素存到 max 里面，否则继续下一轮比较。\n                5. 最后输出这个 max\n    */\n    var arr = [2, 6, 1, 77, 52, 25, 7];\n    var max = arr[0];\n\n    for (var i = 1; i < arr.length; i++) {\n        if (max <= arr[i]) {\n             max = arr[i];\n        }\n    }\n    console.log(\"数组中最大元素是：\" + max);\n</script>\n```\n\n## 7.3、案例3\n\n### 7.3.1、需求\n\n​\t\t将数组 [2, 0, 6, 1, 77, 0, 52, 0, 25, 7] 中大于等于 10 的元素选出来，放入新数组。\n\n### 7.3.2、方式一\n\n```html\n<script>\n    // 原数组\n    var arr = [2, 0, 6, 1, 77, 0, 52, 0, 25, 7];\n\n    // 新数组,保存原数组中大于10的元素\n    var newArr = [];\n\n    // 筛选\n    // 定义一个变量 用来计算 新数组的索引号\n    var j = 0;\n    for (var i = 0; i < arr.length; i++) {\n        if (arr[i] > 10) {\n             newArr[j] = arr[i];\n             j++;\n        }\n    }\n    console.log(\"新数组的元素:\" + newArr);\n</script>\n```\n\n### 7.3.3、方式二\n\n```html\n<script>\n    // 原数组\n    var arr = [2, 0, 6, 1, 77, 0, 52, 0, 25, 7];\n\n    // 新数组,保存原数组中大于10的元素\n    var newArr = [];\n\n    // 筛选\n    // 定义一个变量 用来计算 新数组的索引号\n    for (var i = 0; i < arr.length; i++) {\n        if (arr[i] > 10) {\n            newArr[newArr.length] = arr[i];\t // newArr.length 动态检测数组长度的变化\n        }\n    }\n    console.log(\"新数组的元素:\" + newArr);\n</script>\n```\n\n## 7.4、翻转数组\n\n### 7.4.1、需求\n\n​\t\t将数组 [2, 0, 6, 1, 77, 0, 52, 0, 25, 7]的内容反过来存放。\n\n### 7.4.2、方式一：存入新数组\n\n```html\n<script>\n    // 原数组\n    var arr = [2, 0, 6, 1, 77, 0, 52, 0, 25, 7];\n\n    // 新数组\n    var newArr = [];\n\n    // 翻转实现\n    for (var i = arr.length - 1; i >= 0; i--) {\n        newArr[newArr.length] = arr[i];\n    }\n\n    console.log(newArr);\n</script>\n```\n\n### 7.4.3、方式二：原来数组的基础上翻转\n\n```html\n<script>\n   // 原数组\n   var arr = [2, 0, 6, 1, 77, 0, 52, 0, 25, 7];\n   // 翻转实现\n   for (var i = 0; i < arr.length / 2; i++) {\n      var temp = arr[i];\n      arr[i] = arr[arr.length - i - 1];\n      arr[arr.length - 1] = temp;\n   }\n\n \tconsole.log(arr);\n</script>\n```\n","tags":["JavaScript","学习笔记"],"categories":["JavaScript笔记"]},{"title":"JavaScript笔记-01基础知识","url":"/2023/05/26/JavaScript笔记-01基础知识/","content":"\n# 一、概述\n\n## 1.1、初识JavaScirpt\n\n- JavaScript 是世界上最流行的语言之一，是一种运行在客户端的脚本语言 （Script 是脚本的意思）\n- 脚本语言：不需要编译，运行过程中由 js 解释器(js 引擎)逐行来进行解释并执行\n- 现在也可以基于 Node.js 技术进行服务器端编程\n- JavaScript同时也是一种==面向对象==的编程语言\n\n![0001](/assets/JavaScript笔记/0001.png)\n\n## 1.2、执行JavaScript\n\n​\t\t浏览器分成两部分：渲染引擎和 JS 引擎\n\n- 渲染引擎：用来解析HTML与CSS，俗称内核，比如 chrome 浏览器的 blink ，老版本的 webkit。\n- JS 引擎：也称为 JS 解释器，用来读取网页中的JavaScript代码，对其处理后运行，比如chrome浏览器的 V8。\n\n​\t浏览器本身并不会执行JS代码，而是通过内置 **JavaScript 引擎**(解释器) 来执行 JS 代码 。JS 引擎执行代码时**逐行解释**每一句源码（转换为机器语言），然后由计算机去执行，所以 JavaScript 语言归为脚本语言，会逐行解释执行。\n\n![0002](/assets/JavaScript笔记/0002.png)\n\n## 1.3、JavaScript的组成\n\n```markdown\n# JavaScript 包括 ECMAScript、DOM、BOM。\n```\n\n![0003](/assets/JavaScript笔记/0003.png)\n\n```markdown\n# ECMAScript\n\t是由ECMA 国际（原欧洲计算机制造商协会）进行标准化的一门编程语言，这种语言在万维网上应用广泛，它往往被称为 JavaScript 或 JScript，但实际上后两者是 ECMAScript 语言的实现和扩展。\n\tECMAScript 规定了JS的编程语法和基础核心知识，是所有浏览器厂商共同遵守的一套JS语法工业标准。\n\t\n# DOM\n\t(Document Object Model，简称DOM），是W3C组织推荐的处理可扩展标记语言的标准编程接口。通过 DOM 提供的接口可以对页面上的各种元素进行操作（大小、位置、颜色等）。\n\n# BOM\n\t(Browser Object Model，简称BOM) 是指浏览器对象模型，它提供了独立于内容的、可以与浏览器窗口进行互动的对象结构。通过BOM可以操作浏览器窗口，比如弹出框、控制浏览器跳转、获取分辨率等。\n```\n\n# 二、JS入门\n\n## 2.1、行内式JS\n\n```html\n<body>\n    <input type=\"button\" value=\"登录\" onclick=\"alert('登录成功啦');\">\n</body>\n```\n\n![0004](/assets/JavaScript笔记/0004.png)\n\n- 可以将单行或少量JS代码写在HTML标签的事件属性中(以on开头的属性)，如： onclink\n- 注意单双引号的使用：在HTML中我们推荐使用**双引号**，JS中我们推荐使用**单引号**\n- 可读性差，在 HTML 中编入 JS 大量代码时，不方便阅读\n- 特殊情况下使用\n\n## 2.2、内嵌式JS\n\n```html\n<head>\n    <script>\n        alert('HelloWorld');\n    </script>\n</head>\n```\n\n![0005](/assets/JavaScript笔记/0005.png)\n\n- 可以将多行JS代码写到`<script>`标签中\n- 内嵌 JS 是学习时常用的方式\n\n## 2.3、外部JS\n\n```html\n<head>\n    <script src=\"my.js\"></script>\n</head>\n```\n\n- 利于HTML页面代码结构化，把单独JS代码独立到HTML页面之外，既美观，又方便\n- ==引用外部JS文件的script标签中间不可以写代码，因为即便写上，代码也会被忽略。==\n- 适合于JS代码量比较大的情况\n\n# 三、JS基本语法\n\n## 3.1、注释\n\n### 3.1.1、单行注释\n\n```javascript\n// 单行注释\n```\n\n- 快捷键：`ctrl + /`\n\n### 3.1.2、多行注释\n\n```javascript\n/*\n\t多行注释\n*/\n```\n\n- 快捷键 `shift + alt + a`\n\n## 3.2、输入输出语句\n\n|       方法        |              说明              |  归属  |\n| :---------------: | :----------------------------: | :----: |\n|    alert(msg);    |        浏览器弹出警示框        | 浏览器 |\n| console.log(msg); |    浏览器控制台打印输出信息    | 浏览器 |\n|   prompt(info);   | 浏览器弹出输入框，用户可以输入 | 浏览器 |\n\n## 3.3、变量\n\n### 3.3.1、概述\n\n```markdown\n# 百话\n\t变量就是一个装东西的盒子。\n\t\n# 通俗的说\n\t变量是程序在内存中申请的一块用来存放数据的空间\n```\n\n![0006](/assets/JavaScript笔记/0006.png)\n\n### 3.3.2、变量在内存中的存储\n\n```markdown\n# 本质\n\t变量是程序在内存中申请的一块用来存放数据的空间。\n\t类似我们酒店的房间，一个房间就可以看做是一个变量。\n```\n\n![0007](/assets/JavaScript笔记/0007.png)\n\n### 3.3.3、变量的使用\n\n#### 3.3.3.1、说明\n\n```markdown\n# 变量在使用时分为两步： 1. 声明变量 2. 赋值\n```\n\n#### 3.3.3.2、声明变量\n\n```javascript\n// 声明变量，声明了一个名称为 age 的变量\nvar age;\n```\n\n- var 是一个 JS关键字，用来声明变量( variable 变量的意思 )。使用该关键字声明变量后，计算机会自动为变量分配内存空间，不需要程序员管。\n- age 是程序员定义的变量名，我们要通过变量名来访问内存中分配的空间\n\n#### 3.3.3.3、赋值\n\n```javascript\n// 给 age 这个变量赋值为 10, = 表示赋值，表示将10这个数字保存到这个名称为age的空间中\nage = 10; \n```\n\n- = 用来把右边的值赋给左边的变量空间中 此处代表赋值的意思。\n- 变量值是程序员保存到变量空间里的值\n\n#### 3.3.3.5、变量的初始化\n\n```javascript\n// 声明变量同时赋值为 18\nvar age = 18; \n```\n\n```markdown\n# 声明一个变量并赋值， 我们称之为【变量的初始化】。\n```\n\n### 3.3.4、变量其他说明\n\n#### 3.3.4.1、更新变量\n\n​\t\t一个变量被重新复赋值后，它原有的值就会被覆盖，变量值将以最后一次赋的值为准。\n\n```javascript\nvar age = 18;\n\nage = 81; // 最后的结果就是81因为18 被覆盖掉了\n```\n\n#### 3.3.4.2、同时声明多个变量\n\n​\t\t同时声明多个变量时，只需要写一个 var， 多个变量名之间使用英文逗号隔开。\n\n```javascript\nvar username = 'Hello' , age = 23, address = '河南省郑州市';\n```\n\n#### 3.3.4.3、声明变量特殊情况\n\n![0008](/assets/JavaScript笔记/0008.png)\n\n- 只声明，不赋值\n\n  ```html\n  <script>\n      // 只声明，不赋值，直接使用\n      var age;\n      console.info(age);  // undefined\n  </script>\n  ```\n\n- 不声明，不赋值，直接使用\n\n  ```html\n  <script>\n     // 不声明，不赋值，直接使用\n     console.info(age); // age is not defined\n  </script>\n  ```\n\n- 不声明，直接赋值\n\n  ```html\n  <script>\n     // 不声明，直接赋值，直接使用\n     age = 23;\n     console.info(age); // 23\n  </script>\n  ```\n\n### 3.3.5、变量命名规范\n\n- 由字母(A-Za-z)、数字(0-9)、下划线(_)、美元符号( $ )组成，如：usrAge, num01, _name\n- **严格区分大小写**。var app; 和 var App; 是两个变量\n- 不能 以数字开头。 18age 是错误的\n- 不能 是关键字、保留字。例如：var、for、while\n- 变量名必须有意义。\n- **遵守驼峰命名法**。首字母小写，后面单词的首字母需要大写。 myFirstName\n\n![0009](/assets/JavaScript笔记/0009.png)\n\n### 3.3.6、案例：交换两个变量的值\n\n```html\n<script>\n        // 分别定义两个变量\n        var one = 20;\n        var two = 30;\n\n        // 定义临时变量，用来做 临时的内存空间存储\n        var temp;\n\n        // 实现交换\n        temp = one;\n        one = two;\n        two = temp;\n\n        // 打印\n        console.log('one=' + one);\n        console.log('two=' + two);\n</script>\n```\n\n### 3.3.7、总结\n\n```markdown\n1. 因为我们一些数据需要保存，所以需要变量。\n2. 变量就是一个容器，用来存放数据的。方便我们以后使用里面的数据。\n3. 变量是内存里的一块空间，用来存储数据。\n4. 我们使用变量的时候，一定要声明变量，然后赋值\n5. 声明变量本质是去内存申请空间。\n6. 声明变量并赋值我们称之为变量的初始化\n7. 变量名尽量要规范，见名知意——驼峰命名法\n```\n\n## 3.4、数据类型\n\n### 3.4.1、为什么需要数据类型\n\n​\t\t在计算机中，不同的数据所需占用的存储空间是不同的，为了便于把数据分成所需内存大小不同的数据，充分利用存储空间，于是定义了不同的数据类型。\n\n​\t\t简单来说，数据类型就是数据的类别型号。比如姓名“张三”，年龄18，这些数据的类型是不一样的。\n\n### 3.4.2、变量的数据类型\n\n```markdown\n1. 变量是用来存储值的所在处，是一块内存空间，它们有名字和数据类型。\n2. 变量的数据类型决定了如何将代表这些值的位存储到计算机的内存中。\n3. JavaScript是一种弱类型或者说动态语言，意味着不用提前声明变量的类型，在程序运行过程中，类型会被自动确定。\n```\n\n```html\n<script>\n    var age = 23; // 这个是数字型\n    var username = 'HelloWorld'; // 这个是字符串型\n</script>\n```\n\n```markdown\n# 在代码运行时，变量的数据类型是由 JS引擎 根据 = 右边变量值的数据类型来判断 的，运行完毕之后， 变量就确定了数据类型。\n```\n\n```html\n<script>\n   var x = 10; // x此时是数字型\n   x = 'HelloWorld'; // x此时又是字符串类型\n</script>\n```\n\n```markdown\n# JavaScript 拥有动态类型，同时也意味着相同的变量可用作不同的类型，即：变量的数据类型是可以变化的。\n```\n\n### 3.4.3、数据类型的分类\n\n​\t\tJS 把数据类型分为两类： \n\n- 简单数据类型/基本数据类型 （Number,String,Boolean,Undefined,Null）\n\n  ![0010](/assets/JavaScript笔记/0010.png)\n\n- 复杂数据类型 （object)\n\n### 3.4.4、Number数字型\n\n#### 3.4.4.1、说明\n\n​\t\tJavaScript 数字类型既可以用来保存整数值，也可以保存小数(浮点数）。 \n\n```html\n<script>\n   var x = 10; \t\t// 整数\n   var y = 3.14; \t// 小数\n</script>\n```\n\n#### 3.4.4.2、数字型范围\n\n​\t\tJavaScript中数值的最大和最小值：\n\n```html\n<script>\n   \tconsole.log(Number.MAX_VALUE); // 最大值\n   \tconsole.log(Number.MIN_VALUE); // 最小值\n</script>\n```\n\n- 最大值：Number.MAX_VALUE，这个值为： 1.7976931348623157e+308\n- 最小值：Number.MIN_VALUE，这个值为：5e-32\n\n#### 3.4.4.3、数字型三个特殊值\n\n```html\n<script>\n   console.log(Number.MAX_VALUE * 2); //   Infinity\n   console.log(-Number.MAX_VALUE * 2); //   -Infinity\n   console.log(\"hello\" * 12); // NaN\n    \n   console.log(9 / 0);\t\t\t\t// 除数为0，并不会报错，而是 Infinity\n</script>\n```\n\n- Infinity ，代表无穷大，大于任何数值\n- -Infinity ，代表无穷小，小于任何数值\n- NaN ，Not a number，代表一个非数值\n\n#### 3.4.4.4、**isNaN()** \n\n```markdown\n# 用来判断一个变量是否为非数字的类型，返回 true 或者 false\n```\n\n![0011](/assets/JavaScript笔记/0011.png)\n\n```html\n<script>\n    // isNaN() 这个方法用来判断非数字并且返回一个值 如果是数字返回的是 false 如果不是数字返回的是true\n    \n   \tvar age = 12;\n    console.log(isNaN(age)); // false\n\n    var username = 'Hello';\n    console.log(isNaN(username)); // true\n</script>\n```\n\n### 3.4.5、String字符串型\n\n#### 3.4.5.1、说明\n\n```markdown\n# 1. 字符串型可以是引号中的任意文本，其语法为 双引号 \"\" 和 单引号 ''\n# 2. 双引号 和 单引号 需要成对搭配使用\n# 3. HTML 标签里面的属性使用的是双引号，JS 这里我们更推荐使用单引号。\n```\n\n```html\n<script>\n   \tvar str1 = \"今天天气不错,一起出去耍\"; // 双引号表示字符串\n\n    var str2 = '好好学习，天天向上'; // 单引号表示字符串\n\n    var str3 = 坚持努力; // 报错\n</script>\n```\n\n#### 3.4.5.2、字符串引号嵌套\n\n```markdown\n# JS 可以用单引号嵌套双引号 ，或者用双引号嵌套单引号 (外双内单，外单内双)\n```\n\n```html\n<script>\n    var str1 = \"我是一名'高富帅'程序猿\";\t// 可以用\"\" 包含''\t\n\n    var str2 = '我是一名\"高富帅\"程序猿';\t// 也可以用''包含\"\"\n</script>\n```\n\n#### 3.4.5.3、字符串转义符\n\n​\t\t类似HTML里面的特殊字符，字符串中也有特殊字符，我们称之为转义符。\n\n​\t\t转义符都是 \\ 开头的，常用的转义符及其说明如下：\n\n![0012](/assets/JavaScript笔记/0012.png)\n\n```html\n<script>\n    var content = \"今天天气不错,一起出去耍吧。\\n 好哒！\";\n\n    console.log(content);\n</script>\n```\n\n![0013](/assets/JavaScript笔记/0013.png)\n\n#### 3.4.5.4、字符串长度\n\n```markdown\n# 字符串是由若干字符组成的，这些字符的数量就是字符串的长度。通过字符串的 length 属性可以获取整个字符串的长度\n```\n\n```html\n<script>\n   var str = \"Hello World\";\n\n   console.log(str.length);\t// 11\n</script>\n```\n\n#### 3.4.5.5、字符串拼接\n\n- 多个字符串之间可以使用 + 进行拼接，其拼接方式为 **字符串 + 任何类型 = 拼接之后的新字符串**\n- 拼接前会把与字符串相加的任何类型转成字符串，再拼接成一个新的字符串\n\n```html\n<script>\n    // 两个字符串 相加\n    console.log('Hello' + ' ' + 'World'); // Hello World\n\n    // 两个数值字符串 相加\n    console.log('100' + '200'); // 100200\n\n    // 字符串 + 数值\n    console.log(\"年龄是:\" + 18); // 年龄是:18\n\n    // 字符串 + 布尔值\n    console.log(\"性别是:\" + true); // 性别是:true\n\n    // 数值 + 数值\n    console.log(20 + 30); // 50\n\n    // 数值字符串 + 数值\n    console.log('10' + 20); // 1020\n\n    // 特别注意1：\n    console.log('10' + 20 + 30); // 102030\n\n    // 特别注意2：\n    console.log(10 + 20 + '30'); // 3030\n</script>\n```\n\n```markdown\n# + 号总结口诀：数值相加 ，字符相连\n```\n\n#### 3.4.5.6、字符串拼接加强\n\n- 我们经常会将字符串和变量来拼接，因为变量可以很方便地修改里面的值 \n- 变量是不能添加引号的，因为加引号的变量会变成字符串\n- 如果变量两侧都有字符串拼接，口诀“引引加加 ”，删掉数字，变量写加中间\n\n```html\n<script>\n   var age = 12;\n   console.log('学生的年龄是' + age + '岁');\n</script>\n```\n\n### 3.4.6、Boolean布尔型\n\n#### 3.4.6.1、说明\n\n​\t\t布尔类型有两个值：true 和 false ，其中 true 表示真（对），而 false 表示假（错）。\n\n​\t\t布尔型和数字型相加的时候， true 的值为 1 ，false 的值为 0。\n\n#### 3.4.6.2、案例1\n\n```html\n<script>\n    var flag = true;\n\n    console.log(flag + 1); // true 参与加法运算当1来看,结果就是 2\n</script>\n```\n\n#### 3.4.6.3、案例2\n\n```html\n<script>\n    var flag = false;\n\n    console.log(flag + 1); // false 参与加法运算当0来看,结果就是 1\n</script>\n```\n\n### 3.4.7、undefined未定义\n\n```markdown\n# 一个声明后没有被赋值的变量会有一个默认值 undefined ( 如果进行相连或者相加时，注意结果）\n```\n\n```html\n<script>\n    // 变量声明但未赋值\n    var str;\n\n    console.log(str); // undefined\n    console.log(str + 'Hello'); // undefinedHello\n    console.log(str + 10); // undefined 和数字相加 最后的结果是 NaN\n</script>\n```\n\n### 3.4.8、null空值\n\n```markdown\n# 一个声明变量给 null 值，里面存的值为空（学习对象时，我们继续研究null)\n```\n\n```html\n<script>\n    // 变量声明,赋值为null\n    var str = null;\n\n    console.log(str); // null\n    console.log(str + 'Hello'); // nullHello\n    console.log(str + 10); // 10\n</script>\n```\n\n## 3.5、获取变量数据类型\n\n```markdown\n# typeof 可用来获取检测变量的数据类型\n```\n\n```html\n<script>\n     // 数字型\n     var num = 10;\n     console.log(typeof num); // number\n\n     // 字符串型\n     var str = 'Hello';\n     console.log(typeof str); // string\n\n     // 布尔型\n     var flag = true;\n     console.log(typeof flag); // boolean\n\n     // Undefined类型\n     var username = undefined;\n     console.log(typeof username); // undefined\n\n     // Null类型\n     var password = null;\n     console.log(typeof password); // object\n</script>\n```\n\n![0014](/assets/JavaScript笔记/0014.png)\n\n## 3.6、字面量\n\n​\t\t字面量是在源代码中一个固定值的表示法，通俗来说，就是字面量表示如何表达这个值。\n\n- 数字字面量：8，9，10\n- 字符串字面量：‘大前端’，‘后端’\n- 布尔字面量：true、false\n\n​\t\t通过控制台的颜色判断属于哪种数据类型：\n\n![0015](/assets/JavaScript笔记/0015.png)\n\n```html\n<script>\n    console.log(18);\n    console.log('18');\n    console.log(true);\n    console.log(undefined);\n    console.log(null);\n</script>\n```\n\n## 3.7、数据类型转换\n\n### 3.7.1、什么是数据类型转换\n\n​\t\t使用表单、prompt 获取过来的数据默认是字符串类型的，此时就不能直接简单的进行加法运算，而需要转换变量的数据类型。通俗来说，**就是把一种数据类型的变量转换成另外一种数据类型**。\n\n​\t\t我们通常会实现3种方式的转换：\n\n- 转换为字符串类型\n- 转换为数字型\n- 转换为布尔型\n\n### 3.7.2、转换为字符串\n\n![0016](/assets/JavaScript笔记/0016.png)\n\n```html\n<script>\n    // 把数字转换为字符串\n\n    var num = 10;\n    // 方式一: toString()\n    var str1 = num.toString();\n    console.log(str1);\n    console.log(typeof str1);\n\n   \t// 方式二: String(变量)\n    var str2 = String(num);\n    console.log(str2);\n    console.log(typeof str2);\n\n    // 方式三: 利用 + 拼接字符串的方法实现转换效果 隐式转换\n    var str3 = num + '';\n    console.log(str3);\n    console.log(typeof str3);\n</script>\n```\n\n### 3.7.3、转换为数字型\n\n![0017](/assets/JavaScript笔记/0017.png)\n\n```markdown\n# 隐式转换是我们在进行算数运算的时候，JS 自动转换了数据类型\n```\n\n```html\n<script>\n    // 把字符串转换为数字\n\n   \tvar str = '10';\n    // 方式一: toString()\n    var age1 = parseInt(str);\n    console.log(age1);\n    console.log(typeof age1);\n\n    // 方式二: Number(变量)\n    var age2 = Number(str);\n    console.log(age2);\n    console.log(typeof age2);\n\n    // 方式三: 利用了算数运算 -  *  /  隐式转换\n    var age3 = str - 0;\n    console.log(age3);\n    console.log(typeof age3);\n</script>\n```\n\n```html\n<script>\n    console.log(parseInt('3.14')); // 3\n    console.log(parseInt('3.94')); // 3 取整\n    console.log(parseInt('120px')); // 120 会去到这个px单位\n    console.log(parseInt('rem120px')); // NaN\n\n    console.log('12' - 0); // 12\n    console.log('12' * '12'); // 144\n    console.log('12' * 1); // 12\n</script>\n```\n\n### 3.7.4、转换为布尔型\n\n![0018](/assets/JavaScript笔记/0018.png)\n\n- **代表空、否定的值会被转换为 false ，如 ''、0、NaN、null、undefined** \n- 其余值都会被转换为 true\n\n```html\n<script>\n    console.log(Boolean('')); // false\n    console.log(Boolean(0)); // false\n    console.log(Boolean(NaN)); // false\n    console.log(Boolean(null)); // false\n    console.log(Boolean(undefined)); // false\n    console.log(Boolean('小白')); // true\n    console.log(Boolean(12)); // true\n</script>\n```\n\n## 3.8、运算符\n\n### 3.8.1、说明\n\n​\t\t运算符（operator）也被称为操作符，是用于实现赋值、比较和执行算数运算等功能的符号。\n\n​\t\tJavaScript中常用的运算符有：\n\n- 算数运算符\n- 递增和递减运算符\n- 比较运算符\n- 逻辑运算符 \n- 赋值运算符\n\n### 3.8.2、算术运算符\n\n#### 3.8.2.1、说明\n\n​\t\t概念：算术运算使用的符号，用于执行两个变量或值的算术运算。\n\n![0019](/assets/JavaScript笔记/0019.png)\n\n```html\n<script>\n    var num1 = 12;\n    var num2 = 5;\n\n    console.log(num1 / num2); // 除法，结果是：2.4\n    console.log(num1 % num2); // 取余，结果是：2\n </script>\n```\n\n#### 3.8.2.2、浮点数的精度问题\n\n​\t\t浮点数值的最高精度是 17 位小数，但在进行算术计算时其精确度远远不如整数。\n\n```html\n<script>\n    var num1 = 0.1;\n    var num2 = 0.2;\n\n    console.log(num1 + num2); // 0.30000000000000004\n\n    var num3 = 0.07;\n    console.log(num3 * 100); // 7.000000000000001\n\n    var num4 = 0.1 + 0.2;\n    console.log(num4 == 0.3); // false\n</script>\n```\n\n```markdown\n# 不要直接判断两个浮点数是否相等 !\n```\n\n#### 3.8.2.3、表达式和返回值\n\n​\t\t**表达式：**是由数字、运算符、变量等以能求得数值的有意义排列方法所得的组合。\n\n​\t\t简单理解：是由数字、运算符、变量等组成的式子。\n\n```markdown\n# 表达式最终都会有一个结果，返回给我们，我们称之为返回值\n```\n\n```html\n<script>\n    // 把我们的右边表达式(1 + 1)计算完毕后再把返回值给左边num变量\n\tvar num = 1 + 1;\n    console.info(num);\n</script>\n```\n\n### 3.8.3、递增和递减运算符\n\n#### 3.8.3.1、说明\n\n​\t\t如果需要反复给数字变量添加或减去1，可以使用**递增（++）和递减（ -- ）**运算符来完成。\n\n​\t\t在 JavaScript 中，递增（++）和递减（ -- ）既可以放在变量前面，也可以放在变量后面。放在变量前面时，\n\n我们可以称为前置递增（递减）运算符，放在变量后面时，我们可以称为后置递增（递减）运算符。\n\n​\t\t**注意：**递增和递减运算符必须和变量配合使用。\n\n#### 3.8.3.2、前置递增运算符\n\n​\t\t++num 前置递增，就是自加1，类似于 num = num + 1，但是 ++num 写起来更简单。\n\n```markdown\n# 使用口诀：先自加，后返回值\n```\n\n```html\n<script>\n    var age = 10;\n    ++age;\t// 等同于 age = age + 1\n    console.log(\"age=\" + age); // age=11\n</script>\n```\n\n```html\n<script>\n   \tvar age = 10;\n    var result = ++age + 10;\t// 先加1，再返回\n    console.log(\"result=\" + result); // result=21\n</script>\n```\n\n#### 3.8.3.3、后置递增运算符\n\n​\t\tnum++ 后置递增，就是自加1，类似于 num = num + 1 ，但是 num++ 写起来更简单。\n\n```markdown\n# 使用口诀：先返回原值，后自加\n```\n\n```html\n<script>\n    var age = 10;\n    age++;\t// 等同于 age = age + 1\n    console.log(\"age=\" + age); // age=11\n</script>\n```\n\n```html\n<script>\n   var age = 10;\n   var result = age++ + 10;\t\t// 先返回原值 后自加1\n   console.log(\"result=\" + result); // result = 20\n   console.log(\"age=\" + age); // age = 11\n</script>\n```\n\n#### 3.8.3.4、前置递增和后置递增小结\n\n- 前置递增和后置递增运算符可以简化代码的编写，让变量的值 + 1 比以前写法更简单\n- ==**单独使用时，运行结果相同**==\n- ==**与其他代码联用时，执行结果会不同**==\n- 后置：先原值运算，后自加（先人后己） \n- 前置：先自加，后运算（先已后人） \n- 开发时，大多使用后置递增/减，并且代码独占一行，例如：num++; 或者 num--;\n\n### 3.8.4、比较运算符/关系运算符\n\n#### 3.8.4.1、说明\n\n​\t\t概念：比较运算符（关系运算符）是两个数据进行比较时所使用的运算符，比较运算后，会返回一个布尔值\n\n（true / false）作为比较运算的结果。\n\n![0020](/assets/JavaScript笔记/0020.png)\n\n```html\n<script>\n   console.log(20 == 20); // true\n   console.log(20 == '20'); // true,默认转换数据类型 会把字符串型的数据转换为数字型 只要求值相等就可以\n\n   console.log(20 === 20); // true\n   console.log(20 === '20'); //false,一模一样  要求 两侧的值 还有 数据类型完全一致才可以 true\n</script>\n```\n\n#### 3.8.4.2、= 小结\n\n![0021](/assets/JavaScript笔记/0021.png)\n\n### 3.8.5、逻辑运算符\n\n#### 3.8.5.1、说明\n\n​\t\t概念：逻辑运算符是用来进行布尔值运算的运算符，其返回值也是布尔值。后面开发中经常用于多个条件的判断。\n\n![0022](/assets/JavaScript笔记/0022.png)\n\n#### 3.8.5.2、逻辑与&&\n\n```markdown\n# 两边都是 true才返回 true，否则返回 false\n```\n\n![0023](/assets/JavaScript笔记/0023.png)\n\n```html\n<script>\n        console.log(3 > 5 && 3 > 2); // false\n        console.log(3 < 5 && 3 > 2); // true\n</script>\n```\n\n#### 3.8.5.3、 逻辑或 ||\n\n```markdown\n# 两边都为 false 才返回 false，否则都为true (只要有一个true,结果就是true)\n```\n\n![0024](/assets/JavaScript笔记/0024.png)\n\n```html\n<script>\n   console.log(3 > 5 || 3 > 2); // true \n   console.log(3 > 5 || 3 < 2); // false\n</script>\n```\n\n#### 3.8.5.4、逻辑非 ！\n\n​\t\t逻辑非（!）也叫作取反符，用来取一个布尔值相反的值，如 true 的相反值是 false。\n\n```html\n<script>\n   var flag = true;\n   var result = !flag; // 取反\n   console.log(result); // false\n</script>\n```\n\n### 3.8.6、短路运算（逻辑中断）\n\n#### 3.8.6.1、说明\n\n```markdown\n# 短路运算的原理：当有多个表达式（值）时,左边的表达式值可以确定结果时,就不再继续运算右边的表达式的值;\n```\n\n#### 3.8.6.2、逻辑与\n\n- 语法： 表达式1 && 表达式2 \n- 如果第一个表达式的值为真，则返回表达式2 \n- 如果第一个表达式的值为假，则返回表达式1\n\n```html\n<script>\n    // 1. 布尔值参与逻辑与的短路操作\n    console.log(true && false); // false\n    console.log(false && false); // false\n\n    // 2. 值 或者是 表达式 参与逻辑与的短路操作\n    console.log(123 && 456); // 456\n    console.log(0 && 456); //  0\n    console.log(0 && 1 + 2 && 456 * 56789); // 0\n    console.log('' && 1 + 2 && 456 * 56789); // ''\n\n    // 总结: 逻辑与短路运算  如果表达式1 结果为真 则返回表达式2  如果表达式1为假 那么返回表达式1\n</script>\n```\n\n#### 3.8.6.3、逻辑或\n\n- 语法： 表达式1 || 表达式2 \n- 如果第一个表达式的值为真，则返回表达式1 \n- 如果第一个表达式的值为假，则返回表达式2\n\n```html\n<script>\n    // 1. 布尔值参与逻辑或的短路操作\n    console.log(true || false); // true\n    console.log(false || true); // true\n\n    // 2. 值 或者是 表达式 参与逻辑或的短路操作\n    console.log(123 || 456); // 123\n    console.log(0 || 456); //  456\n    console.log(0 || 1 + 2 || 456 * 56789); // 3\n    console.log('' || 1 + 2 || 456 * 56789); // 3\n\n    // 总结: 逻辑或短路运算  如果表达式1 结果为真 则返回的是表达式1 如果表达式1 结果为假 则返回表达式2\n</script>\n```\n\n### 3.8.7、赋值运算符\n\n​\t\t概念：用来把数据赋值给变量的运算符。\n\n![0025](/assets/JavaScript笔记/0025.png)\n\n```html\n<script>\n    // 将数字 10 赋值给左边的num1变量\n    var num1 = 10;\n\n    num1 += 10;\n\n    console.log(\"num1=\" + num1); // 20\n</script>\n```\n\n### 3.8.8、运算符优先级\n\n![0026](/assets/JavaScript笔记/0026.png)\n\n```markdown\n1. 一元运算符里面的逻辑非优先级很高。\n2. 逻辑与比逻辑或优先级高。\n```\n\n## 3.9、流程控制\n\n### 3.9.1、概述\n\n​\t\t在一个程序执行的过程中，各条代码的执行顺序对程序的结果是有直接影响的。很多时候我们要通过控制代码的执行顺序来实现我们要完成的功能。\n\n​\t\t简单理解： 流程控制就是来控制我们的代码按照什么结构顺序来执行。\n\n​\t\t流程控制主要有三种结构，分别是==顺序结构==、==分支结构==和==循环结构==，这三种结构代表三种代码执行的顺序。\n\n![0027](/assets/JavaScript笔记/0027.png)\n\n### 3.9.2、顺序流程控制\n\n​\t\t顺序结构是程序中最简单、最基本的流程控制，它没有特定的语法结构，程序会按照代码的先后顺序，依次执行，程序中大多数的代码都是这样执行的。\n\n![0028](/assets/JavaScript笔记/0028.png)\n\n### 3.9.3、分支流程控制\n\n#### 3.9.3.1、概述\n\n​\t\t由上到下执行代码的过程中，根据不同的条件，执行不同的路径代码（执行代码多选一的过程），从而得到不同的结果。\n\n![0029](/assets/JavaScript笔记/0029.png)\n\n#### 3.9.3.2、if 语句\n\n- **语法结构**\n\n  ![0030](/assets/JavaScript笔记/0030.png)\n\n- 执行流程\n\n  ![0031](/assets/JavaScript笔记/0031.png)\n\n- 案例\n\n  ​\t\t弹出一个输入框，要求用户输入年龄，如果年龄大于等于 18 岁，允许进网吧。\n\n  ```html\n  <script>\n      var age = prompt(\"请输入你的年龄:\");\n  \n      if (age >= 18) {\n          alert(\"已经成年,可以进入网吧！\");\n      }\n  </script>\n  ```\n\n#### 3.9.3.3、双分支语句\n\n- 语法结构\n\n  ![0032](/assets/JavaScript笔记/0032.png)\n\n- 执行流程\n\n  ![0033](/assets/JavaScript笔记/0033.png)\n\n- 案例\n\n  ​\t\t弹出一个输入框，要求用户输入年龄，如果年龄大于等于 18 岁，允许进网吧，否则提示不允许。\n\n  ```html\n  <script>\n      var age = prompt(\"请输入你的年龄:\");\n  \n      if (age >= 18) {\n          alert(\"已经成年,可以进入网吧！\");\n      } else {\n          alert(\"你还小,不能进入网吧\");\n      }\n  </script>\n  ```\n\n#### 3.9.3.4、多分支语句\n\n- 语法结构\n\n  ![0034](/assets/JavaScript笔记/0034.png)\n\n- 执行流程\n\n  ![0035](/assets/JavaScript笔记/0035.png)\n\n- 案例\n\n  ​\t\t接收用户输入的分数，根据分数输出对应的等级字母 A、B、C、D、E。\n\n  ```html\n  <script>\n     var score = prompt(\"请输入你的分数:\");\n  \n     if (score >= 90) {\n        alert(\"A\");\n     } else if (score >= 80) {\n        alert(\"B\");\n     } else if (score >= 70) {\n        alert(\"C\");\n     } else if (score >= 60) {\n        alert(\"D\");\n     } else {\n        alert(\"E\");\n     }\n  </script>\n  ```\n\n### 3.9.4、三元表达式\n\n#### 3.9.4.1、概述\n\n​\t\t三元表达式也能做一些简单的条件选择。 有三元运算符组成的式子称为三元表达式。\n\n- 语法结构\n\n  ![0036](/assets/JavaScript笔记/0036.png)\n\n- 执行思路\n\n  - 如果表达式1为 true ，则返回表达式2的值，如果表达式1为 false，则返回表达式3的值。\n  - 可以简单理解为：就类似于 if else （双分支） 的简写\n\n#### 3.9.4.2、案例\n\n​\t\t用户输入数字，如果数字小于10，则在前面补 0 ，比如01，09 ，如果数字大于10，则不需要补，比如 20。\n\n```html\n<script>\n   var num = prompt(\"请输入数字：\");\n\n  \tvar result = num < 10 ? '0' + num : num;\n\n    alert(result);\n</script>\n```\n\n### 3.9.5、switch 语句\n\n#### 3.9.5.1、语法结构\n\n​\t\tswitch 语句也是多分支语句，它用于基于不同的条件来执行不同的代码。当要针对变量设置一系列的**特定值**\n\n的选项时，就可以使用 switch。\n\n![0037](/assets/JavaScript笔记/0037.png)\n\n- switch ：开关 转换 ， case ：小例子 选项\n- 关键字 switch 后面括号内可以是表达式或值， 通常是一个变量\n- 关键字 case , 后跟一个选项的表达式或值，后面跟一个冒号\n- **switch 表达式的值会与结构中的 case 的值做比较，相匹配的时候是 ==全等==   必须是值和数据类型一致才可以**\n- 如果存在匹配全等(===) ，则与该 case 关联的代码块会被执行，并在遇到 break 时停止，整个 switch 语句代码执行结束\n- 如果所有的 case 的值都和表达式的值不匹配，则执行 default 里的代码\n- 执行case 里面的语句时，如果没有break，则继续执行下一个case里面的语句\n\n#### 3.9.5.2、案例\n\n​\t\t请输入周几，如果是周一周二，则输出卖苹果；如果是周三周四，则输出卖香蕉；如果是周五周六，则输出卖香梨。\n\n```html\n<script>\n    var week = prompt(\"请输入周几？\");\n\n    switch (week) {\n      \tcase '周一':\n        case '周二':\n            alert(\"卖苹果\");\n            break;\n        case '周三':\n        case '周四':\n            alert(\"卖香蕉\");\n            break;\n        case '周五':\n        case '周六':\n            alert(\"卖香梨\");\n            break;\n        default:\n            alert(\"输入有误\");\n    }\n</script>\n```\n\n#### 3.9.5.3、switch 语句和 if else if 语句的区别\n\n① 一般情况下，它们两个语句可以相互替换\n\n② switch...case 语句通常处理 case为比较确定值的情况， 而 if…else…语句更加灵活，常用于范围判断(大于、\n\n等于某个范围) \n\n③ switch 语句进行条件判断后直接执行到程序的条件语句，效率更高。而if…else 语句有几种条件，就得判断多\n\n少次。\n\n④ 当分支比较少时，if… else语句的执行效率比 switch语句高。 \n\n⑤ 当分支比较多时，switch语句的执行效率比较高，而且结构更清晰。\n\n# 四、循环\n\n## 4.1、概述\n\n- 生活中的循环\n\n![0040](/0040.gif)\n\n![0041](/assets/JavaScript笔记/0041.png)\n\n- 循环特点\n\n  - **循环条件**\n  - **循环操作**\n\n- 总结\n\n  ​\t在实际问题中，有许多具有规律性的重复操作，因此在程序中要完成这类操作就需要重复执行某些语句。\n\n- 在js 中，主要有三种类型的循环语句：\n\n  - for 循环\n  - while 循环\n  - do...while 循环\n\n## 4.2、for循环\n\n### 4.2.1、说明\n\n​\t\t在程序中，一组被重复执行的语句被称之为循环体，能否继续重复执行，取决于循环的终止条件。由循环体及循环的终止条件组成的语句，被称之为**循环语句** 。\n\n### 4.2.2、语法结构\n\n​\t\tfor 循环主要用于把某些代码循环若干次，通常跟计数有关系。其语法结构如下：\n\n![0039](/assets/JavaScript笔记/0039.png)\n\n- **初始化变量：**通常被用于初始化一个计数器，该表达式可以使用 var 关键字声明新的变量，这个变量帮我们来记录次数。\n- **条件表达式：**用于确定每一次循环是否能被执行。如果结果是 true 就继续循环，否则退出循环。\n- **操作表达式：**每次循环的最后都要执行的表达式。通常被用于更新或者递增计数器变量。当然，递减变量也是可以的。\n\n### 4.2.3、执行过程\n\n1. 初始化变量，**初始化操作在整个 for 循环只会执行一次。** \n\n2. 执行条件表达式，如果为true，则执行循环体语句，否则退出循环，循环结束。\n\n3. 执行操作表达式，此时第一轮结束。\n\n4. 第二轮开始，直接去执行条件表达式（不再初始化变量），如果为 true ，则去执行循环体语句，否则退出循环。\n\n5. 继续执行操作表达式，第二轮结束。\n\n6. 后续跟第二轮一致，直至条件表达式为假，结束整个 for 循环。\n\n### 4.2.4、案例1\n\n```html\n<script>\n    // 循环打印100遍：好好学习，天天向上\n    for (var i = 0; i < 100; i++) {\n        console.log('好好学习，天天向上!');\n    }\n</script>\n```\n\n### 4.2.5、案例2\n\n```html\n<script>\n    // 求1到100之间的和\n\n    var sum = 0;\n    for (var i = 1; i <= 100; i++) {\n       \tsum = sum + i;\n    }\n    console.log(\"1到100之间的和是:\" + sum);\n</script>\n```\n\n### 4.2.6、案例3\n\n![0042](/assets/JavaScript笔记/0042.png)\n\n```html\n<script>\n   var str = \"\";\n   for (var i = 1; i <= 5; i++) {\n       str = str + '☆';\n   }\n   console.log(str);\n</script>\n```\n\n```markdown\n# 我们采取追加字符串的方式，这样可以打印到控制台上\n```\n\n## 4.3、双重for循环\n\n### 4.3.1、思考\n\n![0043](/assets/JavaScript笔记/0043.png)\n\n​\t\t思考：使用一个for循环能实现一个5行5列的打印吗？\n\n​\t\t很多情况下，单层 for 循环并不能满足我们的需求，比如我们要打印一个 5 行 5 列的图形，此时就可以通过循环嵌套来实现。\n\n### 4.3.2、概述\n\n​\t\t循环嵌套：**循环嵌套**是指在一个循环语句中再定义一个循环语句的语法结构，例如在for循环语句中，可以再嵌套一个for 循环，这样的 for 循环语句我们称之为双重for循环。\n\n### 4.3.3、语法\n\n![0044](/assets/JavaScript笔记/0044.png)\n\n- 内层循环可以看做外层循环的语句\n- 内层循环执行的顺序也要遵循 for 循环的执行顺序 \n- 外层循环执行一次，内层循环要执行全部次数\n\n### 4.3.4、案例1\n\n```html\n<script>\n    for (var i = 1; i <= 5; i++) {\n        console.log('这是外层循环第' + i + '次');\n        for (var j = 1; j <= 3; j++) {\n            console.log('这是里层的循环第' + j + '次');\n        }\n    }\n</script>\n```\n\n### 4.3.5、案例2\n\n```html\n<script>\n   \tvar str = \"\";\n    for (var i = 1; i <= 5; i++) {\n        for (var j = 1; j <= 5; j++) {\n             str = str + \"☆\";\n        }\n    \tstr = str + \"\\n\";\n    }\n    console.log(str);\n</script>\n```\n\n### 4.3.6、案例3\n\n```html\n<script>\n        var str = \"\";\n        for (var i = 1; i <= 3; i++) {\n            for (let k = 1; k <= 3 - i; k++) {\n                str += '　';\t\t// 全角空格\n            }\n            for (var j = 1; j <= 2 * i - 1; j++) {\n                str = str + \"☆\";\n            }\n            str = str + \"\\n\";\n        }\n        console.log(str);\n</script>\n```\n\n## 4.4、while循环\n\n### 4.4.1、语法\n\n![0045](/assets/JavaScript笔记/0045.png)\n\n​\t\twhile 语句可以在条件表达式为真的前提下，循环执行指定的一段代码，直到表达式不为真时结束循环。\n\n​\t\t执行思路：\n\n① 先执行条件表达式，如果结果为 true，则执行循环体代码；如果为 false，则退出循环，执行后面代码\n\n② 执行循环体代码\n\n③ 循环体代码执行完毕后，程序会继续判断执行条件表达式，如条件仍为true，则会继续执行循环体，直到循\n\n环条件为 false 时，整个循环过程才会结束。、\n\n​\t\t注意：\n\n①  使用 while 循环时一定要注意，它必须要有退出条件，否则会成为死循环。\n\n### 4.4.2、案例1\n\n```html\n<script>\n    var num = 1;\n    while (num <= 10) {\n        console.log(\"好好学习，天天向上\");\n        num++;\n    }\n</script>\n```\n\n### 4.4.3、案例2\n\n```html\n<script>\n   var num = 1;\n   var sum = 0;\n   while (num <= 100) {\n        sum = sum + num;\n        num++;\n   }\n   console.log(\"1到100的和:\" + sum);\n</script>\n```\n\n## 4.5、do while循环\n\n### 4.5.1、语法\n\n![0046](/assets/JavaScript笔记/0046.png)\n\n​\t\t该循环会先执行一次代码块，然后对条件表达式进行判断，如果条件为真，就会重复执行循环体，否则退出循环。\n\n​\t\t执行思路：\n\n①  先执行一次循环体代码\n\n②  再执行条件表达式，如果结果为 true，则继续执行循环体代码，如果为 false，则退出循环，继续执行后面\n\n代码\n\n​\t\t**注意：**\n\n​\t\t先再执行循环体，再判断，我们会发现 do…while 循环语句**至少会执行一次循环体代码**\n\n### 4.5.2、案例1\n\n```html\n<script>\n    var num = 1;\n    do {\n        console.log(\"好好学习，天天向上\");\n        num++;\n    } while (num <= 100);\n</script>\n```\n\n### 4.5.3、案例2\n\n```html\n<script>\n    var num = 1;\n    var sum = 0;\n    do {\n       sum = sum + num;\n       num++;\n   \t} while (num <= 100);\n    console.log(\"1到100的和是:\" + sum);\n</script>\n```\n\n## 4.6、continue 关键字\n\n### 4.6.1、概述\n\n​\t\t**continue 关键字**用于立即**跳出本次循环**，**继续下一次循环**\n\n### 4.6.2、案例1\n\n```html\n<script>\n    // 吃5个包子，第3个有虫子，就扔掉第3个，继续吃第4个第5个包子，其代码实现如下：\n   \tfor (var i = 1; i <= 5; i++) {\n       if (i == 3) {\n            console.log('这第3个包子有虫子，扔掉');\n        \tcontinue; // 跳出本次循环，跳出的是第3次循环\n       }\n       console.log('我正在吃第' + i + '个包子呢');\n    }\n</script>\n```\n\n### 4.6.3、案例2\n\n```html\n<script>\n    // 求1~100 之间， 除了能被7整除之外的整数和\n    var sum = 0;\n    for (var i = 1; i <= 100; i++) {\n  \t    if (i % 7 == 0) {\n    \t    continue;\n        }\n        sum = sum + i;\n    }\n    console.log(sum);\n</script>\n```\n\n## 4.7、break关键字\n\n### 4.7.1、概述\n\n​\t\t**break 关键字用于**立即**跳出整个循环**（循环结束）。\n\n### 4.7.2、案例1\n\n```html\n<script>\n   // 吃5个包子，吃到第3个发现里面有半个虫子，其余的不吃了，其代码实现如\n   for (var i = 1; i <= 5; i++) {\n       if (i == 3) {\n          console.log(\"第3个包子有虫，后面的包子不吃了\");\n          break;\n       }\n       console.log(\"正在吃第\" + i + \"个包子\");\n   }\n</script>\n```\n\n","tags":["JavaScript","学习笔记"],"categories":["JavaScript笔记"]},{"title":"Pr笔记","url":"/2023/05/25/Pr笔记/","content":"\n# 多选素材\n\n## 多选一列\n\n​\t点击第一个图片，按住`shift`点击最后一张图片，可以把首尾之间图片进行选择\n\n## 单个图片多选\n\n​\t按住`alt`单击需要选择的图片，可以进行图片单个多选\n\n\n\n# 工作区域放大\n\n选中 pr 中要放大的面板，点击键盘`~`可以进行放大缩小\n\n\n\n# 调整时间轴\n\n## 手动调节\n\n​\t按住`alt + 滚轮`可以进行手动调节\n\n## 自动调节\n\n​\t点击键盘`|` 键，自动调节时间轴合适大小，注意要在`英文`状态下\n\n\n\n# V1与A1\n\n## 总的V1与A1\n\n​\tV1指的是视频\n\n​\tA1指的是音频\n\n​\t点亮后可以插入视频或音频，不点亮则不能插入\n\n## 小的V1,V2,V3...和A1,A2,A3...\n\n​\t点亮后，粘贴优先粘贴在当前点亮轨道，\n\n​\t多个点亮，则按从小到大优先级点亮\n\n\n\n# 批量添加转场效果\n\n1. 点击你所要添加的转场效果\n2. 右键点击设为默认过度\n2. 鼠标左键划取所要添加的部分\n3. 点击键盘`Ctrl + D`进行添加\n\n\n\n# 批量修改转场时间\n\n1. 找到上方菜单栏里的`编辑`\n2. 找到里面的`首选项`\n3. 点击`时间轴`\n4. 修改默认视频过渡持续时间\n5. 可能需要重新选中所要添加的部分，然后点击键盘`Ctrl + D`进行添加\n\n\n\n# 修改批量添加的视频持续时间\n\n1. 选中需要修改的部分\n2. 右击，选择`速度/持续时间...`（快捷键`Ctrl + R `）\n3. 修改持续的时间\n4. 记得勾选`波纹编辑，移动尾部剪辑`，否则的话，各个图片之间，会有间隔\n\n\n\n# 复制素材的方法\n\n1. Ctrl + C 和 Ctrl + V\n2. 按住`Alt`把素材往上拖或往下拖\n\n\n\n\n# 批量处理效果\n\n先做好一个，然后把做好的效果，给其他素材\n\n1. 选中做好的素材，然后右键点击`复制`\t（快捷键 `Ctrl + C`）\n2. 选中想要批处理的素材，右击`粘贴属性`，然后选择所要粘贴的属性（快捷键 `Ctrl + Alt + V`）\n\n粘贴属性快捷键`Ctrl + Alt + V`\n\n\n\n# 光晕素材黑色解决\n\n1. 点击素材，然后点击左上效果控件\n2. 找到`不透明度`中的混合模式，修改为`滤色`\n\n\n\n# 剃刀工具裁剪多段素材\n\n使用剃刀工具时，按住`shift` 进行裁剪，可以多段素材裁剪\n\n\n\n# 视频大小和序列大小不相同\n\n视频比序列小，有黑边\n\n1. 选中序列中的视频\n2. 右键，点击`缩放为帧大小`\n\n\n\n# 字幕遮罩\n\n用于遮挡原本视频存在的字幕\n\n1. 在新建序列的地方，选择新建  `颜色遮罩`\n2. 把颜色遮罩拖到时间轴上\n3. 在  `效果`里面搜索  `裁剪`\n4. 把裁剪效果添加到颜色遮上\n5. 在左上效果控件里找到裁剪\n6. 设置顶部 或 底部 大小为 `88%`\n\n\n\n# 添加字幕或文字\n\n1. 找到想要添加字幕的地方\n2. 按住`Ctrl + T`可以添加字幕\n3. 按 `T`或选择  `文本工具`  可以进行文本内容编辑\n\n\n\n# 标记\n\n点击`M`可以对时间轴进行标记\n\n点击`M` 按住`Alt` 进行拖动，可以对一段时间进行标记\n\n\n\n# 生成新的独立小视频片段\n\n1. 选中你裁切好的小视频\n2. 右击，选择  `制作子剪辑`\n3. 不勾选  将修剪限制为子剪辑边界\n\n\n\n# 视频启用或隐藏\n\n按住`shift + E`可以启用视频  或者隐藏视频 （音频也同时）\n\n\n\n# 批量把视频后移 \n\n使用`向前选择工具（快捷键A）` （和剃刀工具在一栏）\n\n\n\n# 视频预览小技巧\n\n第一次点击`L`是两倍速度\n\n第二次点击`L`是一倍速度\n\n..... 依此递增\n\n点击`K`是暂停\n\n点击`J`是倒退\n\n\n\n# 清除时间轴间隙\n\n法一： 单个删除，点击空隙，右键，`删除波纹`\n\n法二： 批量删除，选中区域，在顶部菜单栏找到序列，选择`封闭间隙`（注意：只有高版本才有）\n\n法三：在缩短时间时，勾选`波纹编辑，移动尾部剪辑`\n\n\n\n# 右移5帧\n\n按住  `shift + 右键`，向右移5帧\n\n\n\n# 制作花字\n\n1. 点击上方文件，找到 新建 里面的`旧版标题`\n2. 其他就按需所求\n3. 如果字体在背景下面，就 把字体`Ctrl + X`  剪切，然后  `Ctrl + V`粘贴\n4. 花字做好，需要拖到时间轴才能使用\n\n\n\n\n# 拖动矩形缩小\n\n拖动缩小矩形时，如果想两边同时缩小，拖动时按住`Alt` 键\n\n\n\n# 关键帧动画\n\n1. 选择所要添加关键帧的物体，点击左上的  `效果控件`\n2. 点击 `文字前面闹钟` 就可以添加关键帧动画\n3. 每换一个时间点，挪一下位置，都会生成关键帧动画\n4. 两个不同效果添加关键帧时，跨可以按住 `shift` 可以自动吸附到下一个点，或者是点击 `转到下一关键帧`\n\n\n\n\n\n# 关键帧动画效果\n\n​\t位置变化\n\n​\t缩放\n\n​\t旋转\n\n​\t透明度\n\n\n\n# 蒙版\n\n在  `效果控件`里面有个 `不透明度`，下面有个`椭圆和长方形`，点击后创建蒙版\n\n作用：框定一个范围，黑色的不显示，被选中的显示\n\n删除：点选蒙版，然后按`Del键`\n\n自定义路径时：为方便调整路径`可以按住Alt拖动`\n\n\n\n# 音频淡入淡出\n\n1. 选中音频，点击左下效果控件\n2. 选择`音频过渡`里面的 `恒定功率`\n\n\n\n# 视频调色\n\n1. 点击最上方菜单栏里的窗口\n2. 找到窗口里的`Lumetri Color / Lumetri 颜色`\n3. 在 `基本校正`里面，进行调节  曝光，对比度，阴影等....\n\n\n\n\n\n# QW法  快速处理废片\n\nQ：选择你要处理的视频，时间轴指针找到对应位置，点击`Q 键`删除前面的内容\n\nW：选择你要处理的视频，时间轴指针找到对应位置，点击`W 键`删除后面的内容\n\n\n\n# 追踪动画\n\n给贴图设置追踪动画\n\n1. 选中贴纸，找到效果控件里面的运动\n1. 点击`位置`，调整位置\n1. 设置`关键帧`动画，然后`shift + 右键`每5帧调整位置\n1. 多次调整位置就是追踪动画\n\n\n\n\n\n# 帧定格（视频画面暂停）\n\n添加帧定格，可以使视频画面暂停\n\n1. 选中素材，在时间轴上选择相应位置\n2. 右键素材，选择`添加帧定格`\n3. 整个画面就在当前位置定住\n\n\n\n\n\n# 视频黑白翻转\n\n视频颜色变成黑白\n\n1. 点选素材\n2. 找到添加效果界面（左下）\n3. 搜索`黑白`，把黑白效果拖动到素材上  \n\n\n\n\n\n# 调整图层\n\n是个空图层，但是可以把效果添加到调整图层\n\n例如，给视频添加黑白效果，可以把效果添加到调整图层，自由调整隔离图层，可以自由调整黑白位置和时间等\n\n在新建序列的地方，可以新建`调整图层`\n\n\n\n# 设置视频快放和慢放\n\n1. 选中视频，按`R`键\n2. 拖动视频，可以快放或着慢放\n\n\n\n# 视频部分位置方大（头部方法效果）\n\n注意： 放大前，先把需要方大的地方，用`剃刀工具裁剪开`，不然一整段视频都有放大效果\n\n1. 素材裁开，选中需要放大的区域\n2. 在效果中（左下）搜索 `放大`（在视频效果 -> 扭曲 -> 放大）\n3. 在效果控件中（左上），通过调整位置，大小，羽化值，设置放大效果\n4. 可以添加羽化值，放大的更柔和；可以给 `放大率`添加关键帧动画，有个放大过度\n\n\n\n# 视频扣取某个部分\n\n把视频中某个人物或物品抠出来，让物品可以单独运动\n\n1. 选中视频，找到合适位置，点击视频预览处（右上）的   `导出帧 / Ctrl + shift + E`\n2. 然后把你抠出的帧，重新导入到时间轴\n3. 在效果控件中（左上），在  `不透明度`中，选择钢笔工具，使用`蒙版`把人物或物体进行抠取\n\n如何保留背景？\n\n1.    把你导出来的帧放到ps里面\n2. 使用 `矩形框选工具`，框中人物或物品\n3. 然后按键盘 `shift +F5`内容识别\n4. 注意在英文状态下\n\n\n\n# 更改旋转中心点\n\n​\t在效果控件里面，找到`锚点`，更改数值，可以改变物体中心点\n\n# 视频翻转效果\n\n例如视频左右翻转\n\n1. 选中视频，找到效果（左下）\n1. 找到`视频效果`->`变换`\n3. 在里面挑选水平翻转或垂直翻转\n\n\n\n# 视频镜像效果\n\n视频上有多个当前画面\n\n1. 选中视频，找到效果（左下）\n2. 找到`视频效果`->`风格化`->`复制`\n3. 左上 `效果控件` 可以修改 `计数`，改变屏幕上数量\n\n\n\n# 标记入点I 和 标记出点O\n\n标记入点和标记出点可以选择一段片段\n\n选择了一个片段时，可以按`Ctrl + M`以`序列切入/序列切出`方式导出当前片段\n\n","tags":["学习笔记","Pr"],"categories":["Pr笔记"]},{"title":"Vue笔记-02简单语法","url":"/2023/05/24/Vue笔记-02简单语法/","content":"\n# VUE插值表达式\n\n## 插值表达式\n\nvue可以通过data提供数据，注意：`data必须是一个函数，并且返回一个对象`\n\n~~~vue\n<script>\nexport default {\n  data () {\n    return {\n      money: 100,\n      msg: 'hello'\n    }\n  }    \n}\n</script>\n~~~\n\n\n\n## 通过插值表达式显示数据\n\n插值表达式：小胡子语法 ```{{ }}```\n\n> ```{{变量，表达式，自己下面定义的函数(实参)}}```\n\n1. 使用 data 中的数据渲染视图（模板）\n\n2. 基本语法，支持简单数据处理\n\n   ~~~js\n   {{ msg }}\n   {{ obj.name }}\n   {{ msg.toUpperCase() }}\n   {{ obj.age > 18 ? '成年' : '未成年' }}\n   ~~~\n\n3. vue中插值表达式的注意点 \n\n   1. 使用的数据在 data 中要存在\n\n   ~~~html\n   <h1>{{ gaga }}</h1>\n   ~~~\n\n   2. 能使用表达式, 但是不能使用 if  for\n\n   ~~~html\n   <h1>{{ if (obj.age > 18 ) { }  }}</h1>\n   ~~~\n\n   3. 不能在标签属性中使用\n\n   ~~~html\n   <h1 id=\"box\" class=\"box\" title=\"{{ msg }}\"></h1>\n   ~~~\n\n\n\n\n\n\n\n# VUE指令\n\n> vue指令, 实质上就是特殊的 html 标签属性, 特点:  `v- 开头`\n>\n> 每个 v- 开头的指令, 都有着自己独立的功能, 将来vue解析时, 会根据不同的指令提供不同的功能\n\n## v-bind指令\n\n- 描述：插值表达式不能用在html的属性上，如果想要动态的设置html元素的属性，需要使用v-bind指令\n- 作用：动态的设置`html的属性`\n- 语法：`v-bind:标签内的属性名=\"变量名\"`\n- 简写：`:title=\"msg\"`\n\n~~~html\n<!-- 完整语法 -->\n<a v-bind:href=\"url\"></a>\n<!-- 缩写 -->\n<a :href=\"url\"></a>\n~~~\n\n\n\n## v-on指令\n\n### 基本使用\n\n#### 语法\n\n​\t1.v-on:事件名=“要执行的少量代码\"\n\n​\t2.v-on:事件名=“methods中的函数名\"\n\n​\t3.v-on:事件名=“methods中的函数名(实参)\" \n\n####基本结构\n\n`<button v-on:事件名=\"事件函数\">按钮</button>`，需要在methods中提供事件处理函数\n\n> `methods`用于存放函数方法\n>\n> `this`是指当前的组件\n>\n> 简写：`@事件名=\"事件函数\"`  v-on:可以简写成`@`\n\n~~~jsx\n<button v-on:click=\"fn\">搬砖</button>\n<button v-on:click=\"fn1\">卖房</button>\n\n  // 提供方法\n  methods: {\n    fn () {\n      console.log('你好啊')\n      // console.log(this)\n      this.money++\n    },\n    fn1 () {\n      this.money += 10000\n    },\n  }\n~~~\n\n#### 传递参数\n\n`<button v-on:事件名=\"事件函数(参数)\">按钮</button>`，需要在methods中提供事件函数，接受参数\n\n~~~jsx\n<button v-on:click=\"addMoney(1)\">搬砖</button>\n<button v-on:click=\"addMoney(10000)\">卖房</button>\n\nmethods: {\n  addMoney (money) {\n    this.money += money\n  }\n}\n~~~\n\n如果事件的逻辑足够简单，可以不提供函数\n\n~~~vue\n<button v-on:click=\"money++\">搬砖</button>\n<button v-on:click=\"money += 10000\">卖房</button>\n~~~\n\n\n\n### vue中获取事件对象(了解)\n\n需求：默认a标签点击会跳走,  希望阻止默认的跳转, 阻止默认行为  e.preventDefault()\n\n#### vue中获取事件对象\n\n1. 没有传参, 通过形参接收 e\n2. 传参了, 通过$event指代事件对象 e\n\n~~~jsx\n<template>\n  <div id=\"app\">\n    <a @click=\"fn\" href=\"http://www.baidu.com\">去百度</a>\n    <a @click=\"fn2(100, $event)\" href=\"http://www.baidu.com\">去百度2</a>\n  </div>\n</template>\n\n<script>\nexport default {\n  methods: {\n    fn(e) {\n      e.preventDefault()\n    },\n    fn2(num, e) {\n      e.preventDefault()\n    }\n  }\n}\n</script>\n~~~\n\n\n\n>插值表达式：标签`行外数据`绑定\n>\n>v-bind：标签`行内属性`绑定\n>\n>v-on：标签`事件`绑定\n\n\n\n\n\n## 修饰符\n\n### v-on 事件修饰符\n\nvue中提供的事件修饰符\n\n- `.prevent` 阻止默认行为\n- `.stop` 阻止冒泡\n\n~~~vue\n<div id=\"app\">\n  <a @click.prevent=\"fn\" href=\"http://www.baidu.com\">去百度</a>\n</div>\n~~~\n\n\n\n### 按键修饰符\n\n需求: 用户输入内容, 回车, 打印输入的内容\n\n在监听`键盘事件`时，我们经常需要判断详细的按键。此时，可以为键盘相关的事件添加按键修饰符\n\n- `@keyup.enter`  回车\n- `@keyup.esc`  返回\n\n~~~vue\n<div id=\"app\">\n  <input type=\"text\" @keyup=\"fn\"> <hr>\n  <input type=\"text\" @keyup.enter=\"fn2\">\n</div>\n~~~\n\n\n\n![](D:\\网课视频\\Vue\\笔记\\img\\02vue指令\\按键修饰符.png)\n\n\n\n\n\n\n\n## v-if 和 v-show 指令\n\n### 基本使用\n\nv-show 和 v-if 功能: 控制盒子的显示隐藏\n\n1. v-show\n\n   语法：`v-show=\"布尔值\"`  (true显示，false隐藏)\n\n   原理：实质是在控制元素的 css 样式, `display: none;`\n\n2. v-if\n\n   语法: `v-if=\"布尔值\"`  (true显示, false隐藏)\n\n   原理:  实质是在动态的创建 或者 删除元素节点\n\n应用场景: \n\n- 如果是频繁的切换显示隐藏, 用 v-show\n\n  v-if, 频繁切换会大量的创建和删除元素, 消耗性能\n\n- 如果是不用频繁切换, 要么显示, 要么隐藏的情况, 适合于用 v-if\n\n  v-if 是惰性的, 如果初始值为 false, 那么这些元素就直接不创建了, 节省一些初始渲染开销\n\n~~~vue\n<template>\n  <div id=\"app\">\n    <h1 v-show=\"isShow\">v-show盒子-{{ msg }}</h1>\n    <h1 v-if=\"isShow\">v-if盒子-{{ msg }}</h1>\n  </div>\n</template>\n~~~\n\n\n\n## v-if v-else 和 v-else-if\n\n~~~vue\n<div id=\"app\">\n  <h1 v-if=\"isLogin\">尊敬的超级vip, 你好</h1>\n  <h1 v-else>你谁呀, 赶紧登陆~</h1>\n\n  <hr>\n  \n  <h1 v-if=\"age >= 60\">60岁以上, 广场舞</h1>\n  <h1 v-else-if=\"age >= 30\">30岁以上, 搓麻将</h1>\n  <h1 v-else-if=\"age >= 20\">20岁以上, 蹦迪</h1>\n  <h1 v-else>20岁以下, 唱跳rap篮球</h1>\n</div>\n~~~\n\n> 指令可以配套！标签不用配套！\n\n\n\n\n\n## v-model\n\n### 基本用法\n\n作用：给表单元素使用, 双向数据绑定\n\n1. 数据变化了, 视图会跟着变\n2. 视图变化了, 数据要跟着变\n   - 输入框内容变化了(监听用户的输入, 监听input事件), 数据要跟着变\n\n语法：`v-model='值'`\n\n~~~html\n<input type=\"text\" v-model=\"msg\">\n~~~\n\n\n\n### v-model 处理其他表单元素\n\n数据双向绑定，双向更新，不写的话，就单项变化\n\n- select\n\n- checkbox\n\n- textarea\n\n  ~~~vue\n  <input type=\"checkbox\" v-model=\"key\">\n  <textarea v-model=\"msg\"></textarea>\n  <select v-model=\"num\">\n      <option value=\"1\">山东</option>\n      <option value=\"2\">上海</option>\n      <option value=\"3\">山东商务</option>\n  </select>\n  \n  <script>\n      export default {\n          data(){\n              return {\n                  msg:'这是txt',\n                  key:true,\n                  num:3\n              }\n          }\n      }\n  </script>\n  ~~~\n\n  \n\n注意：v-model 会忽略掉表单元素原本的value, checked等初始值\n\n\n\n### v-model 修饰符\n\n- number\n\n  如果想自动将用户的输入值, 用parseFloat转成数字类型, ，可以给 `v-model` 添加 `number` 修饰符：\n\n  ~~~HTML\n  <input v-model.number=\"age\" type=\"number\">\n  ~~~\n\n- trim\n\n  如果要自动过滤用户输入的首尾空白字符，可以给 `v-model` 添加 `trim` 修饰符：\n\n  ~~~HTML\n  <input v-model.trim=\"msg\">\n  ~~~\n\n- lazy\n\n  在`change`时而非`input`时更新，可以给 `v-model` 添加 `lazy` 修饰符：\n\n  （用户离开输入框时才触发更新操作，而不是用户每输入一个字符就进行一次更新）\n\n  ~~~html\n  <input v-model.lazy=\"msg\">\n  ~~~\n\n\n\n\n\n## v-text 和 v-html\n\n### v-text指令\n\n- 解释：更新元素的 `textContent/innerText`。如果要更新部分的 `textContent` ，需要使用 `{{ Mustache }}` 插值。 \n\n  ~~~js\n  <h1 v-text=\"msg\"></h1>\n  \n  export default {\n    data(){\n      return {\n        msg:'<button>这是按钮</button>'\n      }\n    }\n  }\n  ~~~\n\n\n\n### v-html指令\n\n- 解释：更新DOM对象的` innerHTML`,html标签会生效\n\n  ~~~js\n  <h1 v-html=\"msg\"></h1>\n  \n  export default {\n    data(){\n      return {\n        msg:'<button>这是按钮</button>'\n      }\n    }\n  }\n  ~~~\n\n> **在网站上动态渲染任意 HTML 是非常危险的，因为容易导致 [XSS 攻击](https://en.wikipedia.org/wiki/Cross-site_scripting)。** \n>\n> **只在可信内容上使用 `v-html`，永不用在用户提交的内容上。** \n\n\n\n\n\n## v-for\n\n### 基本使用\n\nv-for 作用: 遍历`对象`和`数组`\n\n1. 遍历数组（常用）\n\n~~~jsx\nv-for=\"item in 数组名\"  item每一项\nv-for=\"(item, index) in 数组名\"  item每一项 index下标\n\n注意：item和index不是定死的，可以是任意的名字，但是需要注意 第一项是值  第二项是下标\n~~~\n\n2. 遍历对象 (一般不用)\n\n~~~jsx\n<!--\n  v-for也可以遍历对象（不常用）\n  v-for=\"(值, 键) in 对象\"\n-->\n<ul>\n  <li v-for=\"value in user\" :key=\"value\">{{value}}</li>\n</ul>\n<ul>\n  <li v-for=\"(value, key) in user\" :key=\"key\">{{value}} ---{{key}}</li>\n</ul>\n~~~\n\n3. 遍历数字\n\n~~~jsx\n<!-- \n  遍历数字\n  语法： v-for=\"(item, index) in 数字\"\n  作用：遍历具体的次数 item从1开始  index下标从0开始的\n-->\n<ul>\n  <li v-for=\"(item, index) in 10\" :key=\"item\">{{item}} ---{{index}}</li>\n</ul>\n~~~\n\n\n\n### v-for 的key的说明\n\n1. 设置 和 不设置 key 有什么区别？\n   - 不设置 key， 默认同级兄弟元素按照下标进行比较。\n   - 设置了key，按照相同key的新旧元素`比较`。\n2. key值要求是?\n   - 字符串或者数值，唯一不重复\n   - 有 id 用 id,  有唯一值用唯一值，实在都没有，才用索引\n3. key的好处?\n   - key的作用：提高虚拟DOM的对比复用性能\n\n以后：只要是写到列表渲染，都推荐加上 key 属性。且 key 推荐是设置成 id， 实在没有，就设置成 index\n\n> 注意：key是用来虚拟dom`比较`，而不是排序 （`diff算法`）\n\n\n\n\n\n## v-computed 计算属性\n\n### 基本使用\n\n> 计算属性是一个`属性`，写法上是一个`函数`，这个函数的`返回值`就是计算属性最终的值。\n\n1. 计算属性必须定义在`computed`节点中\n2. 计算属性必须是一个`function`,计算属性必须有返回值\n3. 计算属性不能被当作方法调用,当成`属性`来用\n\n\n\n### 定义计算属性\n\n~~~js\n// 组件的数据： 需要计算的属性\ncomputed: {\n  reverseMsg () {\n    return this.msg.split('').reverse().join('')\n  }\n}\n~~~\n\n\n\n### 使用计算属性\n\n~~~html\n<p>{{ reverseMsg }}</p>\n~~~\n\n<hr>\n\n未完待续...\n","tags":["学习笔记","Vue"],"categories":["Vue笔记"]},{"title":"Vue笔记-01初始vue","url":"/2023/05/24/Vue笔记-01初始vue/","content":"# 初始vue\n\n## 开发vue的方式\n\n开发vue有两种方式\n\n- 传统开发模式：基于html/css/js文件开发vue \n- 工程化开发方式：在webpack环境中开发vue，这是最推荐的方式。\n\n\n\n## vue-cli的使用\n\n### webpack基本使用\n\n- 初始化一个vue项目\n\n```bash\nvue create 项目名(不能用中文)\n```\n\n- 启动项目\n\n```bash\nnpm run serve\n```\n\n- 访问项目\n\n```bash\n浏览器访问  \nhttp://localhost:${端口号}/\nhttp://127.0.0.1:${端口号}/\nhttp://${本地ip}:${端口号}/\n```\n\n\n\n## 目录分析\n\n\n\n### 重要介绍\n\n\n- public/index.html不用动，提供一个最基础的页面\n\n- src/main.js不用动，  渲染了App.vue组件\n\n- src/App.vue默认有很多的内容，可以全部删除\n\n  ```jsx\n  <template>\n    <div id=\"app\"> </div>\n  </template>\n  ```\n  \n- assets文件夹与components直接删除\n\n\n\n## 修改端口号\n\n如果需要覆盖webpack的配置，可以修改vue.config.js文件，覆盖webpack配置文件\n\n```js\nconst { defineConfig } = require('@vue/cli-service')\nmodule.exports = defineConfig({\n  transpileDependencies: true,\n  // 配置端口号\n  devServer: {\n    port: 3000\n  }\n})\n```\n\n\n\n## vue单文件组件的说明\n\n一个`.vue`文件就是一个组件，后续开发vue，所有的功能都是基于组件实现。\n\n根组件为`app.vue`\n\n\n\n一个单文件组件由三部分构成\n\n- template(必须)  影响组件渲染的结构  html  （只能有一个根元素,就是最外层只能有一个div）\n- script      逻辑js\n- style       样式   css less scss\n\n>style用于提供组件的样式，默认只能用css\n>\n>可以通过style标签， `lang=\"less\"`开启less的功能，需要安装依赖包\n>\n>`npm install less-loader@7.2.1 less --save-dev`\n\n\n\n","tags":["学习笔记","Vue"],"categories":["Vue笔记"]},{"title":"这是我的第一篇文章","url":"/2023/05/24/第一篇文章/","content":"## 这是我的第一篇文章\n"},{"title":"分类","url":"/categories/index.html"},{"title":"关于","url":"/about/index.html","content":"## 1.关于本人📃\n- 姓名：赵梓茗\n- 性别：♂\n- 生日：200X.08.14\n- 地点：北方某城市\n- 邮箱：[63388848@qq.com](mailto:63388848@qq.com)\n- 擅长：\n  - 熟悉使用`H5+CSS3`对页面进行布局和样式设计，包括使用 flexbox、grid 布局，实现响应式设计和动画效果。(成功的页面仔)\n  - 熟悉使用原生`JavaScript`进行前端开发，包括DOM操作、事件处理、Ajax等。\n  - 熟悉使用`ES6`特性，如箭头函数、模板字符串、解构赋值等，以提高开发效率和代码质量。\n  - 了解`jQuery`库，可以利用其简化 DOM 操作、事件处理、动画效果等。\n  - 了解`Vue.js`框架，可以使用其进行组件化开发、数据驱动视图等，提供更好的开发体验和性能优化。\n  - 了解前端构建工具，如 webpack、gulp，可以进行代码打包、压缩、模块化管理等。\n  - 具备良好的代码风格和规范意识，注重代码的可读性、可维护性和可扩展性。\n  - 持续学习和关注前端技术的发展动态，保持对新技术的敏感性和学习能力。\n\n\n\n## 2.关于本站🧪\n- 本站以[Hexo框架](https://hexo.io/zh-cn/)为基础，进行搭建。\n- 项目地址[Github个人博客](https://github.com/xMing66/xMing66.github.io)\n- 搭建初衷：作为一名学习计算机的学生，一直觉得拥有自己的独立网站是一件十分酷的事情！这样就相当于拥有自己独立的空间。网站成为了自己的一个名片，在上面写写东西，记录生活，分享知识，把自己想与他人展现的技能放在博客上，何尝不是一件有趣的事情！所以借助`校内技能大赛机会`，部署了属于自己的Blog。\n- 博客内容：\n  - 记录自己在学习中的知识点、算法、编程技巧等内容，并进行总结和归纳。这些笔记和总结旨在帮助我巩固所学知识，并与他人分享我的学习心得和经验。\n  - 分享我在学习和实践过程中发现的优质技术资源，包括书籍、教程、在线课程、工具和框架等。我会附上简要的评价和推荐理由，希望能够帮助读者在学习和工作中找到有价值的资源。\n  - 当然，也有部分内容是搬运过来的，仅供学习交流之用，不涉及商业用途。如果无意中侵犯了您的版权，请来信告知，我会在第一时间删除。"},{"url":"/js/cat.js","content":"if (document.body.clientWidth > 992) {\n    function getBasicInfo() {\n        /* 窗口高度 */\n        var ViewH = $(window).height();\n        /* document高度 */\n        var DocH = $(\"body\")[0].scrollHeight;\n        /* 滚动的高度 */\n        var ScrollTop = $(window).scrollTop();\n        /* 可滚动的高度 */\n        var S_V = DocH - ViewH;\n        var Band_H = ScrollTop / (DocH - ViewH) * 100;\n        return {\n            ViewH: ViewH,\n            DocH: DocH,\n            ScrollTop: ScrollTop,\n            Band_H: Band_H,\n            S_V: S_V\n        }\n    };\n    function show(basicInfo) {\n        if (basicInfo.ScrollTop > 0.001) {\n            $(\".neko\").css('display', 'block');\n        } else {\n            $(\".neko\").css('display', 'none');\n        }\n    }\n    (function ($) {\n        $.fn.nekoScroll = function (option) {\n            var defaultSetting = {\n                top: '0',\n                scroWidth: 6 + 'px',\n                z_index: 9999,\n                zoom: 0.9,\n                borderRadius: 5 + 'px',\n                right: 60 + 'px',\n                // 这里可以换为你喜欢的图片，例如我就换为了雪人，但是要抠图\n                nekoImg: \"https://bu.dusays.com/2022/07/20/62d812db74be9.png\",\n                hoverMsg: \"喵喵喵~\",\n                color: \"#6f42c1\",\n                during: 500,\n                blog_body: \"body\",\n            };\n            var setting = $.extend(defaultSetting, option);\n            var getThis = this.prop(\"className\") !== \"\" ? \".\" + this.prop(\"className\") : this.prop(\"id\") !== \"\" ? \"#\" +\n                this.prop(\"id\") : this.prop(\"nodeName\");\n            if ($(\".neko\").length == 0) {\n                this.after(\"<div class=\\\"neko\\\" id=\" + setting.nekoname + \" data-msg=\\\"\" + setting.hoverMsg + \"\\\"></div>\");\n            }\n            let basicInfo = getBasicInfo();\n            $(getThis)\n                .css({\n                    'position': 'fixed',\n                    'width': setting.scroWidth,\n                    'top': setting.top,\n                    'height': basicInfo.Band_H * setting.zoom * basicInfo.ViewH * 0.01 + 'px',\n                    'z-index': setting.z_index,\n                    'background-color': setting.bgcolor,\n                    \"border-radius\": setting.borderRadius,\n                    'right': setting.right,\n                    'background-image': 'url(' + setting.scImg + ')',\n                    'background-image': '-webkit-linear-gradient(45deg, rgba(255, 255, 255, 0.1) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, 0.1) 50%, rgba(255, 255, 255, 0.1) 75%, transparent 75%, transparent)', 'border-radius': '2em',\n                    'background-size': 'contain'\n                });\n            $(\"#\" + setting.nekoname)\n                .css({\n                    'position': 'fixed',\n                    'top': basicInfo.Band_H * setting.zoom * basicInfo.ViewH * 0.01 - 50 + 'px',\n                    'z-index': setting.z_index * 10,\n                    'right': setting.right,\n                    'background-image': 'url(' + setting.nekoImg + ')',\n                });\n            show(getBasicInfo());\n            $(window)\n                .scroll(function () {\n                    let basicInfo = getBasicInfo();\n                    show(basicInfo);\n                    $(getThis)\n                        .css({\n                            'position': 'fixed',\n                            'width': setting.scroWidth,\n                            'top': setting.top,\n                            'height': basicInfo.Band_H * setting.zoom * basicInfo.ViewH * 0.01 + 'px',\n                            'z-index': setting.z_index,\n                            'background-color': setting.bgcolor,\n                            \"border-radius\": setting.borderRadius,\n                            'right': setting.right,\n                            'background-image': 'url(' + setting.scImg + ')',\n                            'background-image': '-webkit-linear-gradient(45deg, rgba(255, 255, 255, 0.1) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, 0.1) 50%, rgba(255, 255, 255, 0.1) 75%, transparent 75%, transparent)', 'border-radius': '2em',\n                            'background-size': 'contain'\n                        });\n                    $(\"#\" + setting.nekoname)\n                        .css({\n                            'position': 'fixed',\n                            'top': basicInfo.Band_H * setting.zoom * basicInfo.ViewH * 0.01 - 50 + 'px',\n                            'z-index': setting.z_index * 10,\n                            'right': setting.right,\n                            'background-image': 'url(' + setting.nekoImg + ')',\n                        });\n                    if (basicInfo.ScrollTop == basicInfo.S_V) {\n                        $(\"#\" + setting.nekoname)\n                            .addClass(\"showMsg\")\n                    } else {\n                        $(\"#\" + setting.nekoname)\n                            .removeClass(\"showMsg\");\n                        $(\"#\" + setting.nekoname)\n                            .attr(\"data-msg\", setting.hoverMsg);\n                    }\n                });\n            this.click(function (e) {\n                btf.scrollToDest(0, 500)\n            });\n            $(\"#\" + setting.nekoname)\n                .click(function () {\n                    btf.scrollToDest(0, 500)\n                });\n            return this;\n        }\n    })(jQuery);\n\n    $(document).ready(function () {\n        //部分自定义\n        $(\"#myscoll\").nekoScroll({\n            bgcolor: 'rgb(0 0 0 / .5)', //背景颜色，没有绳子背景图片时有效\n            borderRadius: '2em',\n            zoom: 0.9\n        }\n        );\n        //自定义（去掉以下注释，并注释掉其他的查看效果）\n        /*\n        $(\"#myscoll\").nekoScroll({\n            nekoname:'neko1', //nekoname，相当于id\n            nekoImg:'img/猫咪.png', //neko的背景图片\n            scImg:\"img/绳1.png\", //绳子的背景图片\n            bgcolor:'#1e90ff', //背景颜色，没有绳子背景图片时有效\n            zoom:0.9, //绳子长度的缩放值\n            hoverMsg:'你好~喵', //鼠标浮动到neko上方的对话框信息\n            right:'100px', //距离页面右边的距离\n            fontFamily:'楷体', //对话框字体\n            fontSize:'14px', //对话框字体的大小\n            color:'#1e90ff', //对话框字体颜色\n            scroWidth:'8px', //绳子的宽度\n            z_index:100, //不用解释了吧\n            during:1200, //从顶部到底部滑动的时长\n        });\n        */\n    })\n}"},{"url":"/js/cursor.js","content":"// 鼠标样式改变js\nvar CURSOR;\n\nMath.lerp = (a, b, n) => (1 - n) * a + n * b;\n\nconst getStyle = (el, attr) => {\n    try {\n        return window.getComputedStyle\n            ? window.getComputedStyle(el)[attr]\n            : el.currentStyle[attr];\n    } catch (e) {}\n    return \"\";\n};\n\nclass Cursor {\n    constructor() {\n        this.pos = {curr: null, prev: null};\n        this.pt = [];\n        this.create();\n        this.init();\n        this.render();\n    }\n\n    move(left, top) {\n        this.cursor.style[\"left\"] = `${left}px`;\n        this.cursor.style[\"top\"] = `${top}px`;\n    }\n\n    create() {\n        if (!this.cursor) {\n            this.cursor = document.createElement(\"div\");\n            this.cursor.id = \"cursor\";\n            this.cursor.classList.add(\"hidden\");\n            document.body.append(this.cursor);\n        }\n\n        var el = document.getElementsByTagName('*');\n        for (let i = 0; i < el.length; i++)\n            if (getStyle(el[i], \"cursor\") == \"pointer\")\n                this.pt.push(el[i].outerHTML);\n\n        document.body.appendChild((this.scr = document.createElement(\"style\")));\n        // 这里改变鼠标指针的颜色 由svg生成\n        this.scr.innerHTML = `* {cursor: url(\"data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 8 8' width='8px' height='8px'><circle cx='4' cy='4' r='4' opacity='1.0' fill='rgb(57, 197, 187)'/></svg>\") 4 4, auto}`;\n    }\n\n    refresh() {\n        this.scr.remove();\n        this.cursor.classList.remove(\"hover\");\n        this.cursor.classList.remove(\"active\");\n        this.pos = {curr: null, prev: null};\n        this.pt = [];\n\n        this.create();\n        this.init();\n        this.render();\n    }\n\n    init() {\n        document.onmouseover  = e => this.pt.includes(e.target.outerHTML) && this.cursor.classList.add(\"hover\");\n        document.onmouseout   = e => this.pt.includes(e.target.outerHTML) && this.cursor.classList.remove(\"hover\");\n        document.onmousemove  = e => {(this.pos.curr == null) && this.move(e.clientX - 8, e.clientY - 8); this.pos.curr = {x: e.clientX - 8, y: e.clientY - 8}; this.cursor.classList.remove(\"hidden\");};\n        document.onmouseenter = e => this.cursor.classList.remove(\"hidden\");\n        document.onmouseleave = e => this.cursor.classList.add(\"hidden\");\n        document.onmousedown  = e => this.cursor.classList.add(\"active\");\n        document.onmouseup    = e => this.cursor.classList.remove(\"active\");\n    }\n\n    render() {\n        if (this.pos.prev) {\n            this.pos.prev.x = Math.lerp(this.pos.prev.x, this.pos.curr.x, 0.15);\n            this.pos.prev.y = Math.lerp(this.pos.prev.y, this.pos.curr.y, 0.15);\n            this.move(this.pos.prev.x, this.pos.prev.y);\n        } else {\n            this.pos.prev = this.pos.curr;\n        }\n        requestAnimationFrame(() => this.render());\n    }\n}\n\n(() => {\n    CURSOR = new Cursor();\n    // 需要重新获取列表时，使用 CURSOR.refresh()\n})();\n\n"},{"url":"/js/runtime.js","content":"//页脚js文件\n\nvar now = new Date();\n\n// Set the start date for the \"来到商务\" duration\nvar businessStartDate = new Date(\"09/01/2021 13:15:34\");\n\nfunction padZero(value) {\n  return value < 10 ? \"0\" + value : value;\n}\n\nfunction createTime() {\n  now.setTime(now.getTime() + 1000);\n  var startDate = new Date(\"05/24/2023 00:00:00\");\n  var elapsedTimeSeconds = Math.floor((now - startDate) / 1000);\n  var days = Math.floor(elapsedTimeSeconds / 86400);\n  elapsedTimeSeconds -= days * 86400;\n  var hours = Math.floor(elapsedTimeSeconds / 3600);\n  elapsedTimeSeconds -= hours * 3600;\n  var minutes = Math.floor(elapsedTimeSeconds / 60);\n  var seconds = elapsedTimeSeconds % 60;\n\n  var businessElapsedTimeSeconds = Math.floor((now - businessStartDate) / 1000);\n  var businessDays = Math.floor(businessElapsedTimeSeconds / 86400);\n  businessElapsedTimeSeconds -= businessDays * 86400;\n  var businessHours = Math.floor(businessElapsedTimeSeconds / 3600);\n  businessElapsedTimeSeconds -= businessHours * 3600;\n  var businessMinutes = Math.floor(businessElapsedTimeSeconds / 60);\n  var businessSeconds = businessElapsedTimeSeconds % 60;\n\n  let output = `<div style=\"font-size:13px;font-weight:bold\">本站居然运行了 ${padZero(days)} 天 ${padZero(hours)} 小时 ${padZero(minutes)} 分 ${padZero(seconds)} 秒 &nbsp;<i id=\"heartbeat\" class='fas fa-heartbeat'></i> <br> 在商务生活 ${padZero(businessDays)} 天 ${padZero(businessHours)} 小时 ${padZero(businessMinutes)} 分 ${padZero(businessSeconds)} 秒 &nbsp;🚀</div>`;\n\n  if (document.getElementById(\"workboard\")) {\n    document.getElementById(\"workboard\").innerHTML = output;\n  }\n}\n\nsetInterval(() => {\n  createTime();\n}, 1000);\n"},{"url":"/js/jquery.min.js","content":"/*! jQuery v3.6.0 | (c) OpenJS Foundation and other contributors | jquery.org/license */\n!function(e,t){\"use strict\";\"object\"==typeof module&&\"object\"==typeof module.exports?module.exports=e.document?t(e,!0):function(e){if(!e.document)throw new Error(\"jQuery requires a window with a document\");return t(e)}:t(e)}(\"undefined\"!=typeof window?window:this,function(C,e){\"use strict\";var t=[],r=Object.getPrototypeOf,s=t.slice,g=t.flat?function(e){return t.flat.call(e)}:function(e){return t.concat.apply([],e)},u=t.push,i=t.indexOf,n={},o=n.toString,v=n.hasOwnProperty,a=v.toString,l=a.call(Object),y={},m=function(e){return\"function\"==typeof e&&\"number\"!=typeof e.nodeType&&\"function\"!=typeof e.item},x=function(e){return null!=e&&e===e.window},E=C.document,c={type:!0,src:!0,nonce:!0,noModule:!0};function b(e,t,n){var r,i,o=(n=n||E).createElement(\"script\");if(o.text=e,t)for(r in c)(i=t[r]||t.getAttribute&&t.getAttribute(r))&&o.setAttribute(r,i);n.head.appendChild(o).parentNode.removeChild(o)}function w(e){return null==e?e+\"\":\"object\"==typeof e||\"function\"==typeof e?n[o.call(e)]||\"object\":typeof e}var f=\"3.6.0\",S=function(e,t){return new S.fn.init(e,t)};function p(e){var t=!!e&&\"length\"in e&&e.length,n=w(e);return!m(e)&&!x(e)&&(\"array\"===n||0===t||\"number\"==typeof t&&0<t&&t-1 in e)}S.fn=S.prototype={jquery:f,constructor:S,length:0,toArray:function(){return s.call(this)},get:function(e){return null==e?s.call(this):e<0?this[e+this.length]:this[e]},pushStack:function(e){var t=S.merge(this.constructor(),e);return t.prevObject=this,t},each:function(e){return S.each(this,e)},map:function(n){return this.pushStack(S.map(this,function(e,t){return n.call(e,t,e)}))},slice:function(){return this.pushStack(s.apply(this,arguments))},first:function(){return this.eq(0)},last:function(){return this.eq(-1)},even:function(){return this.pushStack(S.grep(this,function(e,t){return(t+1)%2}))},odd:function(){return this.pushStack(S.grep(this,function(e,t){return t%2}))},eq:function(e){var t=this.length,n=+e+(e<0?t:0);return this.pushStack(0<=n&&n<t?[this[n]]:[])},end:function(){return this.prevObject||this.constructor()},push:u,sort:t.sort,splice:t.splice},S.extend=S.fn.extend=function(){var e,t,n,r,i,o,a=arguments[0]||{},s=1,u=arguments.length,l=!1;for(\"boolean\"==typeof a&&(l=a,a=arguments[s]||{},s++),\"object\"==typeof a||m(a)||(a={}),s===u&&(a=this,s--);s<u;s++)if(null!=(e=arguments[s]))for(t in e)r=e[t],\"__proto__\"!==t&&a!==r&&(l&&r&&(S.isPlainObject(r)||(i=Array.isArray(r)))?(n=a[t],o=i&&!Array.isArray(n)?[]:i||S.isPlainObject(n)?n:{},i=!1,a[t]=S.extend(l,o,r)):void 0!==r&&(a[t]=r));return a},S.extend({expando:\"jQuery\"+(f+Math.random()).replace(/\\D/g,\"\"),isReady:!0,error:function(e){throw new Error(e)},noop:function(){},isPlainObject:function(e){var t,n;return!(!e||\"[object Object]\"!==o.call(e))&&(!(t=r(e))||\"function\"==typeof(n=v.call(t,\"constructor\")&&t.constructor)&&a.call(n)===l)},isEmptyObject:function(e){var t;for(t in e)return!1;return!0},globalEval:function(e,t,n){b(e,{nonce:t&&t.nonce},n)},each:function(e,t){var n,r=0;if(p(e)){for(n=e.length;r<n;r++)if(!1===t.call(e[r],r,e[r]))break}else for(r in e)if(!1===t.call(e[r],r,e[r]))break;return e},makeArray:function(e,t){var n=t||[];return null!=e&&(p(Object(e))?S.merge(n,\"string\"==typeof e?[e]:e):u.call(n,e)),n},inArray:function(e,t,n){return null==t?-1:i.call(t,e,n)},merge:function(e,t){for(var n=+t.length,r=0,i=e.length;r<n;r++)e[i++]=t[r];return e.length=i,e},grep:function(e,t,n){for(var r=[],i=0,o=e.length,a=!n;i<o;i++)!t(e[i],i)!==a&&r.push(e[i]);return r},map:function(e,t,n){var r,i,o=0,a=[];if(p(e))for(r=e.length;o<r;o++)null!=(i=t(e[o],o,n))&&a.push(i);else for(o in e)null!=(i=t(e[o],o,n))&&a.push(i);return g(a)},guid:1,support:y}),\"function\"==typeof Symbol&&(S.fn[Symbol.iterator]=t[Symbol.iterator]),S.each(\"Boolean Number String Function Array Date RegExp Object Error Symbol\".split(\" \"),function(e,t){n[\"[object \"+t+\"]\"]=t.toLowerCase()});var d=function(n){var e,d,b,o,i,h,f,g,w,u,l,T,C,a,E,v,s,c,y,S=\"sizzle\"+1*new Date,p=n.document,k=0,r=0,m=ue(),x=ue(),A=ue(),N=ue(),j=function(e,t){return e===t&&(l=!0),0},D={}.hasOwnProperty,t=[],q=t.pop,L=t.push,H=t.push,O=t.slice,P=function(e,t){for(var n=0,r=e.length;n<r;n++)if(e[n]===t)return n;return-1},R=\"checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped\",M=\"[\\\\x20\\\\t\\\\r\\\\n\\\\f]\",I=\"(?:\\\\\\\\[\\\\da-fA-F]{1,6}\"+M+\"?|\\\\\\\\[^\\\\r\\\\n\\\\f]|[\\\\w-]|[^\\0-\\\\x7f])+\",W=\"\\\\[\"+M+\"*(\"+I+\")(?:\"+M+\"*([*^$|!~]?=)\"+M+\"*(?:'((?:\\\\\\\\.|[^\\\\\\\\'])*)'|\\\"((?:\\\\\\\\.|[^\\\\\\\\\\\"])*)\\\"|(\"+I+\"))|)\"+M+\"*\\\\]\",F=\":(\"+I+\")(?:\\\\((('((?:\\\\\\\\.|[^\\\\\\\\'])*)'|\\\"((?:\\\\\\\\.|[^\\\\\\\\\\\"])*)\\\")|((?:\\\\\\\\.|[^\\\\\\\\()[\\\\]]|\"+W+\")*)|.*)\\\\)|)\",B=new RegExp(M+\"+\",\"g\"),$=new RegExp(\"^\"+M+\"+|((?:^|[^\\\\\\\\])(?:\\\\\\\\.)*)\"+M+\"+$\",\"g\"),_=new RegExp(\"^\"+M+\"*,\"+M+\"*\"),z=new RegExp(\"^\"+M+\"*([>+~]|\"+M+\")\"+M+\"*\"),U=new RegExp(M+\"|>\"),X=new RegExp(F),V=new RegExp(\"^\"+I+\"$\"),G={ID:new RegExp(\"^#(\"+I+\")\"),CLASS:new RegExp(\"^\\\\.(\"+I+\")\"),TAG:new RegExp(\"^(\"+I+\"|[*])\"),ATTR:new RegExp(\"^\"+W),PSEUDO:new RegExp(\"^\"+F),CHILD:new RegExp(\"^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\\\(\"+M+\"*(even|odd|(([+-]|)(\\\\d*)n|)\"+M+\"*(?:([+-]|)\"+M+\"*(\\\\d+)|))\"+M+\"*\\\\)|)\",\"i\"),bool:new RegExp(\"^(?:\"+R+\")$\",\"i\"),needsContext:new RegExp(\"^\"+M+\"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\\\(\"+M+\"*((?:-\\\\d)?\\\\d*)\"+M+\"*\\\\)|)(?=[^-]|$)\",\"i\")},Y=/HTML$/i,Q=/^(?:input|select|textarea|button)$/i,J=/^h\\d$/i,K=/^[^{]+\\{\\s*\\[native \\w/,Z=/^(?:#([\\w-]+)|(\\w+)|\\.([\\w-]+))$/,ee=/[+~]/,te=new RegExp(\"\\\\\\\\[\\\\da-fA-F]{1,6}\"+M+\"?|\\\\\\\\([^\\\\r\\\\n\\\\f])\",\"g\"),ne=function(e,t){var n=\"0x\"+e.slice(1)-65536;return t||(n<0?String.fromCharCode(n+65536):String.fromCharCode(n>>10|55296,1023&n|56320))},re=/([\\0-\\x1f\\x7f]|^-?\\d)|^-$|[^\\0-\\x1f\\x7f-\\uFFFF\\w-]/g,ie=function(e,t){return t?\"\\0\"===e?\"\\ufffd\":e.slice(0,-1)+\"\\\\\"+e.charCodeAt(e.length-1).toString(16)+\" \":\"\\\\\"+e},oe=function(){T()},ae=be(function(e){return!0===e.disabled&&\"fieldset\"===e.nodeName.toLowerCase()},{dir:\"parentNode\",next:\"legend\"});try{H.apply(t=O.call(p.childNodes),p.childNodes),t[p.childNodes.length].nodeType}catch(e){H={apply:t.length?function(e,t){L.apply(e,O.call(t))}:function(e,t){var n=e.length,r=0;while(e[n++]=t[r++]);e.length=n-1}}}function se(t,e,n,r){var i,o,a,s,u,l,c,f=e&&e.ownerDocument,p=e?e.nodeType:9;if(n=n||[],\"string\"!=typeof t||!t||1!==p&&9!==p&&11!==p)return n;if(!r&&(T(e),e=e||C,E)){if(11!==p&&(u=Z.exec(t)))if(i=u[1]){if(9===p){if(!(a=e.getElementById(i)))return n;if(a.id===i)return n.push(a),n}else if(f&&(a=f.getElementById(i))&&y(e,a)&&a.id===i)return n.push(a),n}else{if(u[2])return H.apply(n,e.getElementsByTagName(t)),n;if((i=u[3])&&d.getElementsByClassName&&e.getElementsByClassName)return H.apply(n,e.getElementsByClassName(i)),n}if(d.qsa&&!N[t+\" \"]&&(!v||!v.test(t))&&(1!==p||\"object\"!==e.nodeName.toLowerCase())){if(c=t,f=e,1===p&&(U.test(t)||z.test(t))){(f=ee.test(t)&&ye(e.parentNode)||e)===e&&d.scope||((s=e.getAttribute(\"id\"))?s=s.replace(re,ie):e.setAttribute(\"id\",s=S)),o=(l=h(t)).length;while(o--)l[o]=(s?\"#\"+s:\":scope\")+\" \"+xe(l[o]);c=l.join(\",\")}try{return H.apply(n,f.querySelectorAll(c)),n}catch(e){N(t,!0)}finally{s===S&&e.removeAttribute(\"id\")}}}return g(t.replace($,\"$1\"),e,n,r)}function ue(){var r=[];return function e(t,n){return r.push(t+\" \")>b.cacheLength&&delete e[r.shift()],e[t+\" \"]=n}}function le(e){return e[S]=!0,e}function ce(e){var t=C.createElement(\"fieldset\");try{return!!e(t)}catch(e){return!1}finally{t.parentNode&&t.parentNode.removeChild(t),t=null}}function fe(e,t){var n=e.split(\"|\"),r=n.length;while(r--)b.attrHandle[n[r]]=t}function pe(e,t){var n=t&&e,r=n&&1===e.nodeType&&1===t.nodeType&&e.sourceIndex-t.sourceIndex;if(r)return r;if(n)while(n=n.nextSibling)if(n===t)return-1;return e?1:-1}function de(t){return function(e){return\"input\"===e.nodeName.toLowerCase()&&e.type===t}}function he(n){return function(e){var t=e.nodeName.toLowerCase();return(\"input\"===t||\"button\"===t)&&e.type===n}}function ge(t){return function(e){return\"form\"in e?e.parentNode&&!1===e.disabled?\"label\"in e?\"label\"in e.parentNode?e.parentNode.disabled===t:e.disabled===t:e.isDisabled===t||e.isDisabled!==!t&&ae(e)===t:e.disabled===t:\"label\"in e&&e.disabled===t}}function ve(a){return le(function(o){return o=+o,le(function(e,t){var n,r=a([],e.length,o),i=r.length;while(i--)e[n=r[i]]&&(e[n]=!(t[n]=e[n]))})})}function ye(e){return e&&\"undefined\"!=typeof e.getElementsByTagName&&e}for(e in d=se.support={},i=se.isXML=function(e){var t=e&&e.namespaceURI,n=e&&(e.ownerDocument||e).documentElement;return!Y.test(t||n&&n.nodeName||\"HTML\")},T=se.setDocument=function(e){var t,n,r=e?e.ownerDocument||e:p;return r!=C&&9===r.nodeType&&r.documentElement&&(a=(C=r).documentElement,E=!i(C),p!=C&&(n=C.defaultView)&&n.top!==n&&(n.addEventListener?n.addEventListener(\"unload\",oe,!1):n.attachEvent&&n.attachEvent(\"onunload\",oe)),d.scope=ce(function(e){return a.appendChild(e).appendChild(C.createElement(\"div\")),\"undefined\"!=typeof e.querySelectorAll&&!e.querySelectorAll(\":scope fieldset div\").length}),d.attributes=ce(function(e){return e.className=\"i\",!e.getAttribute(\"className\")}),d.getElementsByTagName=ce(function(e){return e.appendChild(C.createComment(\"\")),!e.getElementsByTagName(\"*\").length}),d.getElementsByClassName=K.test(C.getElementsByClassName),d.getById=ce(function(e){return a.appendChild(e).id=S,!C.getElementsByName||!C.getElementsByName(S).length}),d.getById?(b.filter.ID=function(e){var t=e.replace(te,ne);return function(e){return e.getAttribute(\"id\")===t}},b.find.ID=function(e,t){if(\"undefined\"!=typeof t.getElementById&&E){var n=t.getElementById(e);return n?[n]:[]}}):(b.filter.ID=function(e){var n=e.replace(te,ne);return function(e){var t=\"undefined\"!=typeof e.getAttributeNode&&e.getAttributeNode(\"id\");return t&&t.value===n}},b.find.ID=function(e,t){if(\"undefined\"!=typeof t.getElementById&&E){var n,r,i,o=t.getElementById(e);if(o){if((n=o.getAttributeNode(\"id\"))&&n.value===e)return[o];i=t.getElementsByName(e),r=0;while(o=i[r++])if((n=o.getAttributeNode(\"id\"))&&n.value===e)return[o]}return[]}}),b.find.TAG=d.getElementsByTagName?function(e,t){return\"undefined\"!=typeof t.getElementsByTagName?t.getElementsByTagName(e):d.qsa?t.querySelectorAll(e):void 0}:function(e,t){var n,r=[],i=0,o=t.getElementsByTagName(e);if(\"*\"===e){while(n=o[i++])1===n.nodeType&&r.push(n);return r}return o},b.find.CLASS=d.getElementsByClassName&&function(e,t){if(\"undefined\"!=typeof t.getElementsByClassName&&E)return t.getElementsByClassName(e)},s=[],v=[],(d.qsa=K.test(C.querySelectorAll))&&(ce(function(e){var t;a.appendChild(e).innerHTML=\"<a id='\"+S+\"'></a><select id='\"+S+\"-\\r\\\\' msallowcapture=''><option selected=''></option></select>\",e.querySelectorAll(\"[msallowcapture^='']\").length&&v.push(\"[*^$]=\"+M+\"*(?:''|\\\"\\\")\"),e.querySelectorAll(\"[selected]\").length||v.push(\"\\\\[\"+M+\"*(?:value|\"+R+\")\"),e.querySelectorAll(\"[id~=\"+S+\"-]\").length||v.push(\"~=\"),(t=C.createElement(\"input\")).setAttribute(\"name\",\"\"),e.appendChild(t),e.querySelectorAll(\"[name='']\").length||v.push(\"\\\\[\"+M+\"*name\"+M+\"*=\"+M+\"*(?:''|\\\"\\\")\"),e.querySelectorAll(\":checked\").length||v.push(\":checked\"),e.querySelectorAll(\"a#\"+S+\"+*\").length||v.push(\".#.+[+~]\"),e.querySelectorAll(\"\\\\\\f\"),v.push(\"[\\\\r\\\\n\\\\f]\")}),ce(function(e){e.innerHTML=\"<a href='' disabled='disabled'></a><select disabled='disabled'><option/></select>\";var t=C.createElement(\"input\");t.setAttribute(\"type\",\"hidden\"),e.appendChild(t).setAttribute(\"name\",\"D\"),e.querySelectorAll(\"[name=d]\").length&&v.push(\"name\"+M+\"*[*^$|!~]?=\"),2!==e.querySelectorAll(\":enabled\").length&&v.push(\":enabled\",\":disabled\"),a.appendChild(e).disabled=!0,2!==e.querySelectorAll(\":disabled\").length&&v.push(\":enabled\",\":disabled\"),e.querySelectorAll(\"*,:x\"),v.push(\",.*:\")})),(d.matchesSelector=K.test(c=a.matches||a.webkitMatchesSelector||a.mozMatchesSelector||a.oMatchesSelector||a.msMatchesSelector))&&ce(function(e){d.disconnectedMatch=c.call(e,\"*\"),c.call(e,\"[s!='']:x\"),s.push(\"!=\",F)}),v=v.length&&new RegExp(v.join(\"|\")),s=s.length&&new RegExp(s.join(\"|\")),t=K.test(a.compareDocumentPosition),y=t||K.test(a.contains)?function(e,t){var n=9===e.nodeType?e.documentElement:e,r=t&&t.parentNode;return e===r||!(!r||1!==r.nodeType||!(n.contains?n.contains(r):e.compareDocumentPosition&&16&e.compareDocumentPosition(r)))}:function(e,t){if(t)while(t=t.parentNode)if(t===e)return!0;return!1},j=t?function(e,t){if(e===t)return l=!0,0;var n=!e.compareDocumentPosition-!t.compareDocumentPosition;return n||(1&(n=(e.ownerDocument||e)==(t.ownerDocument||t)?e.compareDocumentPosition(t):1)||!d.sortDetached&&t.compareDocumentPosition(e)===n?e==C||e.ownerDocument==p&&y(p,e)?-1:t==C||t.ownerDocument==p&&y(p,t)?1:u?P(u,e)-P(u,t):0:4&n?-1:1)}:function(e,t){if(e===t)return l=!0,0;var n,r=0,i=e.parentNode,o=t.parentNode,a=[e],s=[t];if(!i||!o)return e==C?-1:t==C?1:i?-1:o?1:u?P(u,e)-P(u,t):0;if(i===o)return pe(e,t);n=e;while(n=n.parentNode)a.unshift(n);n=t;while(n=n.parentNode)s.unshift(n);while(a[r]===s[r])r++;return r?pe(a[r],s[r]):a[r]==p?-1:s[r]==p?1:0}),C},se.matches=function(e,t){return se(e,null,null,t)},se.matchesSelector=function(e,t){if(T(e),d.matchesSelector&&E&&!N[t+\" \"]&&(!s||!s.test(t))&&(!v||!v.test(t)))try{var n=c.call(e,t);if(n||d.disconnectedMatch||e.document&&11!==e.document.nodeType)return n}catch(e){N(t,!0)}return 0<se(t,C,null,[e]).length},se.contains=function(e,t){return(e.ownerDocument||e)!=C&&T(e),y(e,t)},se.attr=function(e,t){(e.ownerDocument||e)!=C&&T(e);var n=b.attrHandle[t.toLowerCase()],r=n&&D.call(b.attrHandle,t.toLowerCase())?n(e,t,!E):void 0;return void 0!==r?r:d.attributes||!E?e.getAttribute(t):(r=e.getAttributeNode(t))&&r.specified?r.value:null},se.escape=function(e){return(e+\"\").replace(re,ie)},se.error=function(e){throw new Error(\"Syntax error, unrecognized expression: \"+e)},se.uniqueSort=function(e){var t,n=[],r=0,i=0;if(l=!d.detectDuplicates,u=!d.sortStable&&e.slice(0),e.sort(j),l){while(t=e[i++])t===e[i]&&(r=n.push(i));while(r--)e.splice(n[r],1)}return u=null,e},o=se.getText=function(e){var t,n=\"\",r=0,i=e.nodeType;if(i){if(1===i||9===i||11===i){if(\"string\"==typeof e.textContent)return e.textContent;for(e=e.firstChild;e;e=e.nextSibling)n+=o(e)}else if(3===i||4===i)return e.nodeValue}else while(t=e[r++])n+=o(t);return n},(b=se.selectors={cacheLength:50,createPseudo:le,match:G,attrHandle:{},find:{},relative:{\">\":{dir:\"parentNode\",first:!0},\" \":{dir:\"parentNode\"},\"+\":{dir:\"previousSibling\",first:!0},\"~\":{dir:\"previousSibling\"}},preFilter:{ATTR:function(e){return e[1]=e[1].replace(te,ne),e[3]=(e[3]||e[4]||e[5]||\"\").replace(te,ne),\"~=\"===e[2]&&(e[3]=\" \"+e[3]+\" \"),e.slice(0,4)},CHILD:function(e){return e[1]=e[1].toLowerCase(),\"nth\"===e[1].slice(0,3)?(e[3]||se.error(e[0]),e[4]=+(e[4]?e[5]+(e[6]||1):2*(\"even\"===e[3]||\"odd\"===e[3])),e[5]=+(e[7]+e[8]||\"odd\"===e[3])):e[3]&&se.error(e[0]),e},PSEUDO:function(e){var t,n=!e[6]&&e[2];return G.CHILD.test(e[0])?null:(e[3]?e[2]=e[4]||e[5]||\"\":n&&X.test(n)&&(t=h(n,!0))&&(t=n.indexOf(\")\",n.length-t)-n.length)&&(e[0]=e[0].slice(0,t),e[2]=n.slice(0,t)),e.slice(0,3))}},filter:{TAG:function(e){var t=e.replace(te,ne).toLowerCase();return\"*\"===e?function(){return!0}:function(e){return e.nodeName&&e.nodeName.toLowerCase()===t}},CLASS:function(e){var t=m[e+\" \"];return t||(t=new RegExp(\"(^|\"+M+\")\"+e+\"(\"+M+\"|$)\"))&&m(e,function(e){return t.test(\"string\"==typeof e.className&&e.className||\"undefined\"!=typeof e.getAttribute&&e.getAttribute(\"class\")||\"\")})},ATTR:function(n,r,i){return function(e){var t=se.attr(e,n);return null==t?\"!=\"===r:!r||(t+=\"\",\"=\"===r?t===i:\"!=\"===r?t!==i:\"^=\"===r?i&&0===t.indexOf(i):\"*=\"===r?i&&-1<t.indexOf(i):\"$=\"===r?i&&t.slice(-i.length)===i:\"~=\"===r?-1<(\" \"+t.replace(B,\" \")+\" \").indexOf(i):\"|=\"===r&&(t===i||t.slice(0,i.length+1)===i+\"-\"))}},CHILD:function(h,e,t,g,v){var y=\"nth\"!==h.slice(0,3),m=\"last\"!==h.slice(-4),x=\"of-type\"===e;return 1===g&&0===v?function(e){return!!e.parentNode}:function(e,t,n){var r,i,o,a,s,u,l=y!==m?\"nextSibling\":\"previousSibling\",c=e.parentNode,f=x&&e.nodeName.toLowerCase(),p=!n&&!x,d=!1;if(c){if(y){while(l){a=e;while(a=a[l])if(x?a.nodeName.toLowerCase()===f:1===a.nodeType)return!1;u=l=\"only\"===h&&!u&&\"nextSibling\"}return!0}if(u=[m?c.firstChild:c.lastChild],m&&p){d=(s=(r=(i=(o=(a=c)[S]||(a[S]={}))[a.uniqueID]||(o[a.uniqueID]={}))[h]||[])[0]===k&&r[1])&&r[2],a=s&&c.childNodes[s];while(a=++s&&a&&a[l]||(d=s=0)||u.pop())if(1===a.nodeType&&++d&&a===e){i[h]=[k,s,d];break}}else if(p&&(d=s=(r=(i=(o=(a=e)[S]||(a[S]={}))[a.uniqueID]||(o[a.uniqueID]={}))[h]||[])[0]===k&&r[1]),!1===d)while(a=++s&&a&&a[l]||(d=s=0)||u.pop())if((x?a.nodeName.toLowerCase()===f:1===a.nodeType)&&++d&&(p&&((i=(o=a[S]||(a[S]={}))[a.uniqueID]||(o[a.uniqueID]={}))[h]=[k,d]),a===e))break;return(d-=v)===g||d%g==0&&0<=d/g}}},PSEUDO:function(e,o){var t,a=b.pseudos[e]||b.setFilters[e.toLowerCase()]||se.error(\"unsupported pseudo: \"+e);return a[S]?a(o):1<a.length?(t=[e,e,\"\",o],b.setFilters.hasOwnProperty(e.toLowerCase())?le(function(e,t){var n,r=a(e,o),i=r.length;while(i--)e[n=P(e,r[i])]=!(t[n]=r[i])}):function(e){return a(e,0,t)}):a}},pseudos:{not:le(function(e){var r=[],i=[],s=f(e.replace($,\"$1\"));return s[S]?le(function(e,t,n,r){var i,o=s(e,null,r,[]),a=e.length;while(a--)(i=o[a])&&(e[a]=!(t[a]=i))}):function(e,t,n){return r[0]=e,s(r,null,n,i),r[0]=null,!i.pop()}}),has:le(function(t){return function(e){return 0<se(t,e).length}}),contains:le(function(t){return t=t.replace(te,ne),function(e){return-1<(e.textContent||o(e)).indexOf(t)}}),lang:le(function(n){return V.test(n||\"\")||se.error(\"unsupported lang: \"+n),n=n.replace(te,ne).toLowerCase(),function(e){var t;do{if(t=E?e.lang:e.getAttribute(\"xml:lang\")||e.getAttribute(\"lang\"))return(t=t.toLowerCase())===n||0===t.indexOf(n+\"-\")}while((e=e.parentNode)&&1===e.nodeType);return!1}}),target:function(e){var t=n.location&&n.location.hash;return t&&t.slice(1)===e.id},root:function(e){return e===a},focus:function(e){return e===C.activeElement&&(!C.hasFocus||C.hasFocus())&&!!(e.type||e.href||~e.tabIndex)},enabled:ge(!1),disabled:ge(!0),checked:function(e){var t=e.nodeName.toLowerCase();return\"input\"===t&&!!e.checked||\"option\"===t&&!!e.selected},selected:function(e){return e.parentNode&&e.parentNode.selectedIndex,!0===e.selected},empty:function(e){for(e=e.firstChild;e;e=e.nextSibling)if(e.nodeType<6)return!1;return!0},parent:function(e){return!b.pseudos.empty(e)},header:function(e){return J.test(e.nodeName)},input:function(e){return Q.test(e.nodeName)},button:function(e){var t=e.nodeName.toLowerCase();return\"input\"===t&&\"button\"===e.type||\"button\"===t},text:function(e){var t;return\"input\"===e.nodeName.toLowerCase()&&\"text\"===e.type&&(null==(t=e.getAttribute(\"type\"))||\"text\"===t.toLowerCase())},first:ve(function(){return[0]}),last:ve(function(e,t){return[t-1]}),eq:ve(function(e,t,n){return[n<0?n+t:n]}),even:ve(function(e,t){for(var n=0;n<t;n+=2)e.push(n);return e}),odd:ve(function(e,t){for(var n=1;n<t;n+=2)e.push(n);return e}),lt:ve(function(e,t,n){for(var r=n<0?n+t:t<n?t:n;0<=--r;)e.push(r);return e}),gt:ve(function(e,t,n){for(var r=n<0?n+t:n;++r<t;)e.push(r);return e})}}).pseudos.nth=b.pseudos.eq,{radio:!0,checkbox:!0,file:!0,password:!0,image:!0})b.pseudos[e]=de(e);for(e in{submit:!0,reset:!0})b.pseudos[e]=he(e);function me(){}function xe(e){for(var t=0,n=e.length,r=\"\";t<n;t++)r+=e[t].value;return r}function be(s,e,t){var u=e.dir,l=e.next,c=l||u,f=t&&\"parentNode\"===c,p=r++;return e.first?function(e,t,n){while(e=e[u])if(1===e.nodeType||f)return s(e,t,n);return!1}:function(e,t,n){var r,i,o,a=[k,p];if(n){while(e=e[u])if((1===e.nodeType||f)&&s(e,t,n))return!0}else while(e=e[u])if(1===e.nodeType||f)if(i=(o=e[S]||(e[S]={}))[e.uniqueID]||(o[e.uniqueID]={}),l&&l===e.nodeName.toLowerCase())e=e[u]||e;else{if((r=i[c])&&r[0]===k&&r[1]===p)return a[2]=r[2];if((i[c]=a)[2]=s(e,t,n))return!0}return!1}}function we(i){return 1<i.length?function(e,t,n){var r=i.length;while(r--)if(!i[r](e,t,n))return!1;return!0}:i[0]}function Te(e,t,n,r,i){for(var o,a=[],s=0,u=e.length,l=null!=t;s<u;s++)(o=e[s])&&(n&&!n(o,r,i)||(a.push(o),l&&t.push(s)));return a}function Ce(d,h,g,v,y,e){return v&&!v[S]&&(v=Ce(v)),y&&!y[S]&&(y=Ce(y,e)),le(function(e,t,n,r){var i,o,a,s=[],u=[],l=t.length,c=e||function(e,t,n){for(var r=0,i=t.length;r<i;r++)se(e,t[r],n);return n}(h||\"*\",n.nodeType?[n]:n,[]),f=!d||!e&&h?c:Te(c,s,d,n,r),p=g?y||(e?d:l||v)?[]:t:f;if(g&&g(f,p,n,r),v){i=Te(p,u),v(i,[],n,r),o=i.length;while(o--)(a=i[o])&&(p[u[o]]=!(f[u[o]]=a))}if(e){if(y||d){if(y){i=[],o=p.length;while(o--)(a=p[o])&&i.push(f[o]=a);y(null,p=[],i,r)}o=p.length;while(o--)(a=p[o])&&-1<(i=y?P(e,a):s[o])&&(e[i]=!(t[i]=a))}}else p=Te(p===t?p.splice(l,p.length):p),y?y(null,t,p,r):H.apply(t,p)})}function Ee(e){for(var i,t,n,r=e.length,o=b.relative[e[0].type],a=o||b.relative[\" \"],s=o?1:0,u=be(function(e){return e===i},a,!0),l=be(function(e){return-1<P(i,e)},a,!0),c=[function(e,t,n){var r=!o&&(n||t!==w)||((i=t).nodeType?u(e,t,n):l(e,t,n));return i=null,r}];s<r;s++)if(t=b.relative[e[s].type])c=[be(we(c),t)];else{if((t=b.filter[e[s].type].apply(null,e[s].matches))[S]){for(n=++s;n<r;n++)if(b.relative[e[n].type])break;return Ce(1<s&&we(c),1<s&&xe(e.slice(0,s-1).concat({value:\" \"===e[s-2].type?\"*\":\"\"})).replace($,\"$1\"),t,s<n&&Ee(e.slice(s,n)),n<r&&Ee(e=e.slice(n)),n<r&&xe(e))}c.push(t)}return we(c)}return me.prototype=b.filters=b.pseudos,b.setFilters=new me,h=se.tokenize=function(e,t){var n,r,i,o,a,s,u,l=x[e+\" \"];if(l)return t?0:l.slice(0);a=e,s=[],u=b.preFilter;while(a){for(o in n&&!(r=_.exec(a))||(r&&(a=a.slice(r[0].length)||a),s.push(i=[])),n=!1,(r=z.exec(a))&&(n=r.shift(),i.push({value:n,type:r[0].replace($,\" \")}),a=a.slice(n.length)),b.filter)!(r=G[o].exec(a))||u[o]&&!(r=u[o](r))||(n=r.shift(),i.push({value:n,type:o,matches:r}),a=a.slice(n.length));if(!n)break}return t?a.length:a?se.error(e):x(e,s).slice(0)},f=se.compile=function(e,t){var n,v,y,m,x,r,i=[],o=[],a=A[e+\" \"];if(!a){t||(t=h(e)),n=t.length;while(n--)(a=Ee(t[n]))[S]?i.push(a):o.push(a);(a=A(e,(v=o,m=0<(y=i).length,x=0<v.length,r=function(e,t,n,r,i){var o,a,s,u=0,l=\"0\",c=e&&[],f=[],p=w,d=e||x&&b.find.TAG(\"*\",i),h=k+=null==p?1:Math.random()||.1,g=d.length;for(i&&(w=t==C||t||i);l!==g&&null!=(o=d[l]);l++){if(x&&o){a=0,t||o.ownerDocument==C||(T(o),n=!E);while(s=v[a++])if(s(o,t||C,n)){r.push(o);break}i&&(k=h)}m&&((o=!s&&o)&&u--,e&&c.push(o))}if(u+=l,m&&l!==u){a=0;while(s=y[a++])s(c,f,t,n);if(e){if(0<u)while(l--)c[l]||f[l]||(f[l]=q.call(r));f=Te(f)}H.apply(r,f),i&&!e&&0<f.length&&1<u+y.length&&se.uniqueSort(r)}return i&&(k=h,w=p),c},m?le(r):r))).selector=e}return a},g=se.select=function(e,t,n,r){var i,o,a,s,u,l=\"function\"==typeof e&&e,c=!r&&h(e=l.selector||e);if(n=n||[],1===c.length){if(2<(o=c[0]=c[0].slice(0)).length&&\"ID\"===(a=o[0]).type&&9===t.nodeType&&E&&b.relative[o[1].type]){if(!(t=(b.find.ID(a.matches[0].replace(te,ne),t)||[])[0]))return n;l&&(t=t.parentNode),e=e.slice(o.shift().value.length)}i=G.needsContext.test(e)?0:o.length;while(i--){if(a=o[i],b.relative[s=a.type])break;if((u=b.find[s])&&(r=u(a.matches[0].replace(te,ne),ee.test(o[0].type)&&ye(t.parentNode)||t))){if(o.splice(i,1),!(e=r.length&&xe(o)))return H.apply(n,r),n;break}}}return(l||f(e,c))(r,t,!E,n,!t||ee.test(e)&&ye(t.parentNode)||t),n},d.sortStable=S.split(\"\").sort(j).join(\"\")===S,d.detectDuplicates=!!l,T(),d.sortDetached=ce(function(e){return 1&e.compareDocumentPosition(C.createElement(\"fieldset\"))}),ce(function(e){return e.innerHTML=\"<a href='#'></a>\",\"#\"===e.firstChild.getAttribute(\"href\")})||fe(\"type|href|height|width\",function(e,t,n){if(!n)return e.getAttribute(t,\"type\"===t.toLowerCase()?1:2)}),d.attributes&&ce(function(e){return e.innerHTML=\"<input/>\",e.firstChild.setAttribute(\"value\",\"\"),\"\"===e.firstChild.getAttribute(\"value\")})||fe(\"value\",function(e,t,n){if(!n&&\"input\"===e.nodeName.toLowerCase())return e.defaultValue}),ce(function(e){return null==e.getAttribute(\"disabled\")})||fe(R,function(e,t,n){var r;if(!n)return!0===e[t]?t.toLowerCase():(r=e.getAttributeNode(t))&&r.specified?r.value:null}),se}(C);S.find=d,S.expr=d.selectors,S.expr[\":\"]=S.expr.pseudos,S.uniqueSort=S.unique=d.uniqueSort,S.text=d.getText,S.isXMLDoc=d.isXML,S.contains=d.contains,S.escapeSelector=d.escape;var h=function(e,t,n){var r=[],i=void 0!==n;while((e=e[t])&&9!==e.nodeType)if(1===e.nodeType){if(i&&S(e).is(n))break;r.push(e)}return r},T=function(e,t){for(var n=[];e;e=e.nextSibling)1===e.nodeType&&e!==t&&n.push(e);return n},k=S.expr.match.needsContext;function A(e,t){return e.nodeName&&e.nodeName.toLowerCase()===t.toLowerCase()}var N=/^<([a-z][^\\/\\0>:\\x20\\t\\r\\n\\f]*)[\\x20\\t\\r\\n\\f]*\\/?>(?:<\\/\\1>|)$/i;function j(e,n,r){return m(n)?S.grep(e,function(e,t){return!!n.call(e,t,e)!==r}):n.nodeType?S.grep(e,function(e){return e===n!==r}):\"string\"!=typeof n?S.grep(e,function(e){return-1<i.call(n,e)!==r}):S.filter(n,e,r)}S.filter=function(e,t,n){var r=t[0];return n&&(e=\":not(\"+e+\")\"),1===t.length&&1===r.nodeType?S.find.matchesSelector(r,e)?[r]:[]:S.find.matches(e,S.grep(t,function(e){return 1===e.nodeType}))},S.fn.extend({find:function(e){var t,n,r=this.length,i=this;if(\"string\"!=typeof e)return this.pushStack(S(e).filter(function(){for(t=0;t<r;t++)if(S.contains(i[t],this))return!0}));for(n=this.pushStack([]),t=0;t<r;t++)S.find(e,i[t],n);return 1<r?S.uniqueSort(n):n},filter:function(e){return this.pushStack(j(this,e||[],!1))},not:function(e){return this.pushStack(j(this,e||[],!0))},is:function(e){return!!j(this,\"string\"==typeof e&&k.test(e)?S(e):e||[],!1).length}});var D,q=/^(?:\\s*(<[\\w\\W]+>)[^>]*|#([\\w-]+))$/;(S.fn.init=function(e,t,n){var r,i;if(!e)return this;if(n=n||D,\"string\"==typeof e){if(!(r=\"<\"===e[0]&&\">\"===e[e.length-1]&&3<=e.length?[null,e,null]:q.exec(e))||!r[1]&&t)return!t||t.jquery?(t||n).find(e):this.constructor(t).find(e);if(r[1]){if(t=t instanceof S?t[0]:t,S.merge(this,S.parseHTML(r[1],t&&t.nodeType?t.ownerDocument||t:E,!0)),N.test(r[1])&&S.isPlainObject(t))for(r in t)m(this[r])?this[r](t[r]):this.attr(r,t[r]);return this}return(i=E.getElementById(r[2]))&&(this[0]=i,this.length=1),this}return e.nodeType?(this[0]=e,this.length=1,this):m(e)?void 0!==n.ready?n.ready(e):e(S):S.makeArray(e,this)}).prototype=S.fn,D=S(E);var L=/^(?:parents|prev(?:Until|All))/,H={children:!0,contents:!0,next:!0,prev:!0};function O(e,t){while((e=e[t])&&1!==e.nodeType);return e}S.fn.extend({has:function(e){var t=S(e,this),n=t.length;return this.filter(function(){for(var e=0;e<n;e++)if(S.contains(this,t[e]))return!0})},closest:function(e,t){var n,r=0,i=this.length,o=[],a=\"string\"!=typeof e&&S(e);if(!k.test(e))for(;r<i;r++)for(n=this[r];n&&n!==t;n=n.parentNode)if(n.nodeType<11&&(a?-1<a.index(n):1===n.nodeType&&S.find.matchesSelector(n,e))){o.push(n);break}return this.pushStack(1<o.length?S.uniqueSort(o):o)},index:function(e){return e?\"string\"==typeof e?i.call(S(e),this[0]):i.call(this,e.jquery?e[0]:e):this[0]&&this[0].parentNode?this.first().prevAll().length:-1},add:function(e,t){return this.pushStack(S.uniqueSort(S.merge(this.get(),S(e,t))))},addBack:function(e){return this.add(null==e?this.prevObject:this.prevObject.filter(e))}}),S.each({parent:function(e){var t=e.parentNode;return t&&11!==t.nodeType?t:null},parents:function(e){return h(e,\"parentNode\")},parentsUntil:function(e,t,n){return h(e,\"parentNode\",n)},next:function(e){return O(e,\"nextSibling\")},prev:function(e){return O(e,\"previousSibling\")},nextAll:function(e){return h(e,\"nextSibling\")},prevAll:function(e){return h(e,\"previousSibling\")},nextUntil:function(e,t,n){return h(e,\"nextSibling\",n)},prevUntil:function(e,t,n){return h(e,\"previousSibling\",n)},siblings:function(e){return T((e.parentNode||{}).firstChild,e)},children:function(e){return T(e.firstChild)},contents:function(e){return null!=e.contentDocument&&r(e.contentDocument)?e.contentDocument:(A(e,\"template\")&&(e=e.content||e),S.merge([],e.childNodes))}},function(r,i){S.fn[r]=function(e,t){var n=S.map(this,i,e);return\"Until\"!==r.slice(-5)&&(t=e),t&&\"string\"==typeof t&&(n=S.filter(t,n)),1<this.length&&(H[r]||S.uniqueSort(n),L.test(r)&&n.reverse()),this.pushStack(n)}});var P=/[^\\x20\\t\\r\\n\\f]+/g;function R(e){return e}function M(e){throw e}function I(e,t,n,r){var i;try{e&&m(i=e.promise)?i.call(e).done(t).fail(n):e&&m(i=e.then)?i.call(e,t,n):t.apply(void 0,[e].slice(r))}catch(e){n.apply(void 0,[e])}}S.Callbacks=function(r){var e,n;r=\"string\"==typeof r?(e=r,n={},S.each(e.match(P)||[],function(e,t){n[t]=!0}),n):S.extend({},r);var i,t,o,a,s=[],u=[],l=-1,c=function(){for(a=a||r.once,o=i=!0;u.length;l=-1){t=u.shift();while(++l<s.length)!1===s[l].apply(t[0],t[1])&&r.stopOnFalse&&(l=s.length,t=!1)}r.memory||(t=!1),i=!1,a&&(s=t?[]:\"\")},f={add:function(){return s&&(t&&!i&&(l=s.length-1,u.push(t)),function n(e){S.each(e,function(e,t){m(t)?r.unique&&f.has(t)||s.push(t):t&&t.length&&\"string\"!==w(t)&&n(t)})}(arguments),t&&!i&&c()),this},remove:function(){return S.each(arguments,function(e,t){var n;while(-1<(n=S.inArray(t,s,n)))s.splice(n,1),n<=l&&l--}),this},has:function(e){return e?-1<S.inArray(e,s):0<s.length},empty:function(){return s&&(s=[]),this},disable:function(){return a=u=[],s=t=\"\",this},disabled:function(){return!s},lock:function(){return a=u=[],t||i||(s=t=\"\"),this},locked:function(){return!!a},fireWith:function(e,t){return a||(t=[e,(t=t||[]).slice?t.slice():t],u.push(t),i||c()),this},fire:function(){return f.fireWith(this,arguments),this},fired:function(){return!!o}};return f},S.extend({Deferred:function(e){var o=[[\"notify\",\"progress\",S.Callbacks(\"memory\"),S.Callbacks(\"memory\"),2],[\"resolve\",\"done\",S.Callbacks(\"once memory\"),S.Callbacks(\"once memory\"),0,\"resolved\"],[\"reject\",\"fail\",S.Callbacks(\"once memory\"),S.Callbacks(\"once memory\"),1,\"rejected\"]],i=\"pending\",a={state:function(){return i},always:function(){return s.done(arguments).fail(arguments),this},\"catch\":function(e){return a.then(null,e)},pipe:function(){var i=arguments;return S.Deferred(function(r){S.each(o,function(e,t){var n=m(i[t[4]])&&i[t[4]];s[t[1]](function(){var e=n&&n.apply(this,arguments);e&&m(e.promise)?e.promise().progress(r.notify).done(r.resolve).fail(r.reject):r[t[0]+\"With\"](this,n?[e]:arguments)})}),i=null}).promise()},then:function(t,n,r){var u=0;function l(i,o,a,s){return function(){var n=this,r=arguments,e=function(){var e,t;if(!(i<u)){if((e=a.apply(n,r))===o.promise())throw new TypeError(\"Thenable self-resolution\");t=e&&(\"object\"==typeof e||\"function\"==typeof e)&&e.then,m(t)?s?t.call(e,l(u,o,R,s),l(u,o,M,s)):(u++,t.call(e,l(u,o,R,s),l(u,o,M,s),l(u,o,R,o.notifyWith))):(a!==R&&(n=void 0,r=[e]),(s||o.resolveWith)(n,r))}},t=s?e:function(){try{e()}catch(e){S.Deferred.exceptionHook&&S.Deferred.exceptionHook(e,t.stackTrace),u<=i+1&&(a!==M&&(n=void 0,r=[e]),o.rejectWith(n,r))}};i?t():(S.Deferred.getStackHook&&(t.stackTrace=S.Deferred.getStackHook()),C.setTimeout(t))}}return S.Deferred(function(e){o[0][3].add(l(0,e,m(r)?r:R,e.notifyWith)),o[1][3].add(l(0,e,m(t)?t:R)),o[2][3].add(l(0,e,m(n)?n:M))}).promise()},promise:function(e){return null!=e?S.extend(e,a):a}},s={};return S.each(o,function(e,t){var n=t[2],r=t[5];a[t[1]]=n.add,r&&n.add(function(){i=r},o[3-e][2].disable,o[3-e][3].disable,o[0][2].lock,o[0][3].lock),n.add(t[3].fire),s[t[0]]=function(){return s[t[0]+\"With\"](this===s?void 0:this,arguments),this},s[t[0]+\"With\"]=n.fireWith}),a.promise(s),e&&e.call(s,s),s},when:function(e){var n=arguments.length,t=n,r=Array(t),i=s.call(arguments),o=S.Deferred(),a=function(t){return function(e){r[t]=this,i[t]=1<arguments.length?s.call(arguments):e,--n||o.resolveWith(r,i)}};if(n<=1&&(I(e,o.done(a(t)).resolve,o.reject,!n),\"pending\"===o.state()||m(i[t]&&i[t].then)))return o.then();while(t--)I(i[t],a(t),o.reject);return o.promise()}});var W=/^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;S.Deferred.exceptionHook=function(e,t){C.console&&C.console.warn&&e&&W.test(e.name)&&C.console.warn(\"jQuery.Deferred exception: \"+e.message,e.stack,t)},S.readyException=function(e){C.setTimeout(function(){throw e})};var F=S.Deferred();function B(){E.removeEventListener(\"DOMContentLoaded\",B),C.removeEventListener(\"load\",B),S.ready()}S.fn.ready=function(e){return F.then(e)[\"catch\"](function(e){S.readyException(e)}),this},S.extend({isReady:!1,readyWait:1,ready:function(e){(!0===e?--S.readyWait:S.isReady)||(S.isReady=!0)!==e&&0<--S.readyWait||F.resolveWith(E,[S])}}),S.ready.then=F.then,\"complete\"===E.readyState||\"loading\"!==E.readyState&&!E.documentElement.doScroll?C.setTimeout(S.ready):(E.addEventListener(\"DOMContentLoaded\",B),C.addEventListener(\"load\",B));var $=function(e,t,n,r,i,o,a){var s=0,u=e.length,l=null==n;if(\"object\"===w(n))for(s in i=!0,n)$(e,t,s,n[s],!0,o,a);else if(void 0!==r&&(i=!0,m(r)||(a=!0),l&&(a?(t.call(e,r),t=null):(l=t,t=function(e,t,n){return l.call(S(e),n)})),t))for(;s<u;s++)t(e[s],n,a?r:r.call(e[s],s,t(e[s],n)));return i?e:l?t.call(e):u?t(e[0],n):o},_=/^-ms-/,z=/-([a-z])/g;function U(e,t){return t.toUpperCase()}function X(e){return e.replace(_,\"ms-\").replace(z,U)}var V=function(e){return 1===e.nodeType||9===e.nodeType||!+e.nodeType};function G(){this.expando=S.expando+G.uid++}G.uid=1,G.prototype={cache:function(e){var t=e[this.expando];return t||(t={},V(e)&&(e.nodeType?e[this.expando]=t:Object.defineProperty(e,this.expando,{value:t,configurable:!0}))),t},set:function(e,t,n){var r,i=this.cache(e);if(\"string\"==typeof t)i[X(t)]=n;else for(r in t)i[X(r)]=t[r];return i},get:function(e,t){return void 0===t?this.cache(e):e[this.expando]&&e[this.expando][X(t)]},access:function(e,t,n){return void 0===t||t&&\"string\"==typeof t&&void 0===n?this.get(e,t):(this.set(e,t,n),void 0!==n?n:t)},remove:function(e,t){var n,r=e[this.expando];if(void 0!==r){if(void 0!==t){n=(t=Array.isArray(t)?t.map(X):(t=X(t))in r?[t]:t.match(P)||[]).length;while(n--)delete r[t[n]]}(void 0===t||S.isEmptyObject(r))&&(e.nodeType?e[this.expando]=void 0:delete e[this.expando])}},hasData:function(e){var t=e[this.expando];return void 0!==t&&!S.isEmptyObject(t)}};var Y=new G,Q=new G,J=/^(?:\\{[\\w\\W]*\\}|\\[[\\w\\W]*\\])$/,K=/[A-Z]/g;function Z(e,t,n){var r,i;if(void 0===n&&1===e.nodeType)if(r=\"data-\"+t.replace(K,\"-$&\").toLowerCase(),\"string\"==typeof(n=e.getAttribute(r))){try{n=\"true\"===(i=n)||\"false\"!==i&&(\"null\"===i?null:i===+i+\"\"?+i:J.test(i)?JSON.parse(i):i)}catch(e){}Q.set(e,t,n)}else n=void 0;return n}S.extend({hasData:function(e){return Q.hasData(e)||Y.hasData(e)},data:function(e,t,n){return Q.access(e,t,n)},removeData:function(e,t){Q.remove(e,t)},_data:function(e,t,n){return Y.access(e,t,n)},_removeData:function(e,t){Y.remove(e,t)}}),S.fn.extend({data:function(n,e){var t,r,i,o=this[0],a=o&&o.attributes;if(void 0===n){if(this.length&&(i=Q.get(o),1===o.nodeType&&!Y.get(o,\"hasDataAttrs\"))){t=a.length;while(t--)a[t]&&0===(r=a[t].name).indexOf(\"data-\")&&(r=X(r.slice(5)),Z(o,r,i[r]));Y.set(o,\"hasDataAttrs\",!0)}return i}return\"object\"==typeof n?this.each(function(){Q.set(this,n)}):$(this,function(e){var t;if(o&&void 0===e)return void 0!==(t=Q.get(o,n))?t:void 0!==(t=Z(o,n))?t:void 0;this.each(function(){Q.set(this,n,e)})},null,e,1<arguments.length,null,!0)},removeData:function(e){return this.each(function(){Q.remove(this,e)})}}),S.extend({queue:function(e,t,n){var r;if(e)return t=(t||\"fx\")+\"queue\",r=Y.get(e,t),n&&(!r||Array.isArray(n)?r=Y.access(e,t,S.makeArray(n)):r.push(n)),r||[]},dequeue:function(e,t){t=t||\"fx\";var n=S.queue(e,t),r=n.length,i=n.shift(),o=S._queueHooks(e,t);\"inprogress\"===i&&(i=n.shift(),r--),i&&(\"fx\"===t&&n.unshift(\"inprogress\"),delete o.stop,i.call(e,function(){S.dequeue(e,t)},o)),!r&&o&&o.empty.fire()},_queueHooks:function(e,t){var n=t+\"queueHooks\";return Y.get(e,n)||Y.access(e,n,{empty:S.Callbacks(\"once memory\").add(function(){Y.remove(e,[t+\"queue\",n])})})}}),S.fn.extend({queue:function(t,n){var e=2;return\"string\"!=typeof t&&(n=t,t=\"fx\",e--),arguments.length<e?S.queue(this[0],t):void 0===n?this:this.each(function(){var e=S.queue(this,t,n);S._queueHooks(this,t),\"fx\"===t&&\"inprogress\"!==e[0]&&S.dequeue(this,t)})},dequeue:function(e){return this.each(function(){S.dequeue(this,e)})},clearQueue:function(e){return this.queue(e||\"fx\",[])},promise:function(e,t){var n,r=1,i=S.Deferred(),o=this,a=this.length,s=function(){--r||i.resolveWith(o,[o])};\"string\"!=typeof e&&(t=e,e=void 0),e=e||\"fx\";while(a--)(n=Y.get(o[a],e+\"queueHooks\"))&&n.empty&&(r++,n.empty.add(s));return s(),i.promise(t)}});var ee=/[+-]?(?:\\d*\\.|)\\d+(?:[eE][+-]?\\d+|)/.source,te=new RegExp(\"^(?:([+-])=|)(\"+ee+\")([a-z%]*)$\",\"i\"),ne=[\"Top\",\"Right\",\"Bottom\",\"Left\"],re=E.documentElement,ie=function(e){return S.contains(e.ownerDocument,e)},oe={composed:!0};re.getRootNode&&(ie=function(e){return S.contains(e.ownerDocument,e)||e.getRootNode(oe)===e.ownerDocument});var ae=function(e,t){return\"none\"===(e=t||e).style.display||\"\"===e.style.display&&ie(e)&&\"none\"===S.css(e,\"display\")};function se(e,t,n,r){var i,o,a=20,s=r?function(){return r.cur()}:function(){return S.css(e,t,\"\")},u=s(),l=n&&n[3]||(S.cssNumber[t]?\"\":\"px\"),c=e.nodeType&&(S.cssNumber[t]||\"px\"!==l&&+u)&&te.exec(S.css(e,t));if(c&&c[3]!==l){u/=2,l=l||c[3],c=+u||1;while(a--)S.style(e,t,c+l),(1-o)*(1-(o=s()/u||.5))<=0&&(a=0),c/=o;c*=2,S.style(e,t,c+l),n=n||[]}return n&&(c=+c||+u||0,i=n[1]?c+(n[1]+1)*n[2]:+n[2],r&&(r.unit=l,r.start=c,r.end=i)),i}var ue={};function le(e,t){for(var n,r,i,o,a,s,u,l=[],c=0,f=e.length;c<f;c++)(r=e[c]).style&&(n=r.style.display,t?(\"none\"===n&&(l[c]=Y.get(r,\"display\")||null,l[c]||(r.style.display=\"\")),\"\"===r.style.display&&ae(r)&&(l[c]=(u=a=o=void 0,a=(i=r).ownerDocument,s=i.nodeName,(u=ue[s])||(o=a.body.appendChild(a.createElement(s)),u=S.css(o,\"display\"),o.parentNode.removeChild(o),\"none\"===u&&(u=\"block\"),ue[s]=u)))):\"none\"!==n&&(l[c]=\"none\",Y.set(r,\"display\",n)));for(c=0;c<f;c++)null!=l[c]&&(e[c].style.display=l[c]);return e}S.fn.extend({show:function(){return le(this,!0)},hide:function(){return le(this)},toggle:function(e){return\"boolean\"==typeof e?e?this.show():this.hide():this.each(function(){ae(this)?S(this).show():S(this).hide()})}});var ce,fe,pe=/^(?:checkbox|radio)$/i,de=/<([a-z][^\\/\\0>\\x20\\t\\r\\n\\f]*)/i,he=/^$|^module$|\\/(?:java|ecma)script/i;ce=E.createDocumentFragment().appendChild(E.createElement(\"div\")),(fe=E.createElement(\"input\")).setAttribute(\"type\",\"radio\"),fe.setAttribute(\"checked\",\"checked\"),fe.setAttribute(\"name\",\"t\"),ce.appendChild(fe),y.checkClone=ce.cloneNode(!0).cloneNode(!0).lastChild.checked,ce.innerHTML=\"<textarea>x</textarea>\",y.noCloneChecked=!!ce.cloneNode(!0).lastChild.defaultValue,ce.innerHTML=\"<option></option>\",y.option=!!ce.lastChild;var ge={thead:[1,\"<table>\",\"</table>\"],col:[2,\"<table><colgroup>\",\"</colgroup></table>\"],tr:[2,\"<table><tbody>\",\"</tbody></table>\"],td:[3,\"<table><tbody><tr>\",\"</tr></tbody></table>\"],_default:[0,\"\",\"\"]};function ve(e,t){var n;return n=\"undefined\"!=typeof e.getElementsByTagName?e.getElementsByTagName(t||\"*\"):\"undefined\"!=typeof e.querySelectorAll?e.querySelectorAll(t||\"*\"):[],void 0===t||t&&A(e,t)?S.merge([e],n):n}function ye(e,t){for(var n=0,r=e.length;n<r;n++)Y.set(e[n],\"globalEval\",!t||Y.get(t[n],\"globalEval\"))}ge.tbody=ge.tfoot=ge.colgroup=ge.caption=ge.thead,ge.th=ge.td,y.option||(ge.optgroup=ge.option=[1,\"<select multiple='multiple'>\",\"</select>\"]);var me=/<|&#?\\w+;/;function xe(e,t,n,r,i){for(var o,a,s,u,l,c,f=t.createDocumentFragment(),p=[],d=0,h=e.length;d<h;d++)if((o=e[d])||0===o)if(\"object\"===w(o))S.merge(p,o.nodeType?[o]:o);else if(me.test(o)){a=a||f.appendChild(t.createElement(\"div\")),s=(de.exec(o)||[\"\",\"\"])[1].toLowerCase(),u=ge[s]||ge._default,a.innerHTML=u[1]+S.htmlPrefilter(o)+u[2],c=u[0];while(c--)a=a.lastChild;S.merge(p,a.childNodes),(a=f.firstChild).textContent=\"\"}else p.push(t.createTextNode(o));f.textContent=\"\",d=0;while(o=p[d++])if(r&&-1<S.inArray(o,r))i&&i.push(o);else if(l=ie(o),a=ve(f.appendChild(o),\"script\"),l&&ye(a),n){c=0;while(o=a[c++])he.test(o.type||\"\")&&n.push(o)}return f}var be=/^([^.]*)(?:\\.(.+)|)/;function we(){return!0}function Te(){return!1}function Ce(e,t){return e===function(){try{return E.activeElement}catch(e){}}()==(\"focus\"===t)}function Ee(e,t,n,r,i,o){var a,s;if(\"object\"==typeof t){for(s in\"string\"!=typeof n&&(r=r||n,n=void 0),t)Ee(e,s,n,r,t[s],o);return e}if(null==r&&null==i?(i=n,r=n=void 0):null==i&&(\"string\"==typeof n?(i=r,r=void 0):(i=r,r=n,n=void 0)),!1===i)i=Te;else if(!i)return e;return 1===o&&(a=i,(i=function(e){return S().off(e),a.apply(this,arguments)}).guid=a.guid||(a.guid=S.guid++)),e.each(function(){S.event.add(this,t,i,r,n)})}function Se(e,i,o){o?(Y.set(e,i,!1),S.event.add(e,i,{namespace:!1,handler:function(e){var t,n,r=Y.get(this,i);if(1&e.isTrigger&&this[i]){if(r.length)(S.event.special[i]||{}).delegateType&&e.stopPropagation();else if(r=s.call(arguments),Y.set(this,i,r),t=o(this,i),this[i](),r!==(n=Y.get(this,i))||t?Y.set(this,i,!1):n={},r!==n)return e.stopImmediatePropagation(),e.preventDefault(),n&&n.value}else r.length&&(Y.set(this,i,{value:S.event.trigger(S.extend(r[0],S.Event.prototype),r.slice(1),this)}),e.stopImmediatePropagation())}})):void 0===Y.get(e,i)&&S.event.add(e,i,we)}S.event={global:{},add:function(t,e,n,r,i){var o,a,s,u,l,c,f,p,d,h,g,v=Y.get(t);if(V(t)){n.handler&&(n=(o=n).handler,i=o.selector),i&&S.find.matchesSelector(re,i),n.guid||(n.guid=S.guid++),(u=v.events)||(u=v.events=Object.create(null)),(a=v.handle)||(a=v.handle=function(e){return\"undefined\"!=typeof S&&S.event.triggered!==e.type?S.event.dispatch.apply(t,arguments):void 0}),l=(e=(e||\"\").match(P)||[\"\"]).length;while(l--)d=g=(s=be.exec(e[l])||[])[1],h=(s[2]||\"\").split(\".\").sort(),d&&(f=S.event.special[d]||{},d=(i?f.delegateType:f.bindType)||d,f=S.event.special[d]||{},c=S.extend({type:d,origType:g,data:r,handler:n,guid:n.guid,selector:i,needsContext:i&&S.expr.match.needsContext.test(i),namespace:h.join(\".\")},o),(p=u[d])||((p=u[d]=[]).delegateCount=0,f.setup&&!1!==f.setup.call(t,r,h,a)||t.addEventListener&&t.addEventListener(d,a)),f.add&&(f.add.call(t,c),c.handler.guid||(c.handler.guid=n.guid)),i?p.splice(p.delegateCount++,0,c):p.push(c),S.event.global[d]=!0)}},remove:function(e,t,n,r,i){var o,a,s,u,l,c,f,p,d,h,g,v=Y.hasData(e)&&Y.get(e);if(v&&(u=v.events)){l=(t=(t||\"\").match(P)||[\"\"]).length;while(l--)if(d=g=(s=be.exec(t[l])||[])[1],h=(s[2]||\"\").split(\".\").sort(),d){f=S.event.special[d]||{},p=u[d=(r?f.delegateType:f.bindType)||d]||[],s=s[2]&&new RegExp(\"(^|\\\\.)\"+h.join(\"\\\\.(?:.*\\\\.|)\")+\"(\\\\.|$)\"),a=o=p.length;while(o--)c=p[o],!i&&g!==c.origType||n&&n.guid!==c.guid||s&&!s.test(c.namespace)||r&&r!==c.selector&&(\"**\"!==r||!c.selector)||(p.splice(o,1),c.selector&&p.delegateCount--,f.remove&&f.remove.call(e,c));a&&!p.length&&(f.teardown&&!1!==f.teardown.call(e,h,v.handle)||S.removeEvent(e,d,v.handle),delete u[d])}else for(d in u)S.event.remove(e,d+t[l],n,r,!0);S.isEmptyObject(u)&&Y.remove(e,\"handle events\")}},dispatch:function(e){var t,n,r,i,o,a,s=new Array(arguments.length),u=S.event.fix(e),l=(Y.get(this,\"events\")||Object.create(null))[u.type]||[],c=S.event.special[u.type]||{};for(s[0]=u,t=1;t<arguments.length;t++)s[t]=arguments[t];if(u.delegateTarget=this,!c.preDispatch||!1!==c.preDispatch.call(this,u)){a=S.event.handlers.call(this,u,l),t=0;while((i=a[t++])&&!u.isPropagationStopped()){u.currentTarget=i.elem,n=0;while((o=i.handlers[n++])&&!u.isImmediatePropagationStopped())u.rnamespace&&!1!==o.namespace&&!u.rnamespace.test(o.namespace)||(u.handleObj=o,u.data=o.data,void 0!==(r=((S.event.special[o.origType]||{}).handle||o.handler).apply(i.elem,s))&&!1===(u.result=r)&&(u.preventDefault(),u.stopPropagation()))}return c.postDispatch&&c.postDispatch.call(this,u),u.result}},handlers:function(e,t){var n,r,i,o,a,s=[],u=t.delegateCount,l=e.target;if(u&&l.nodeType&&!(\"click\"===e.type&&1<=e.button))for(;l!==this;l=l.parentNode||this)if(1===l.nodeType&&(\"click\"!==e.type||!0!==l.disabled)){for(o=[],a={},n=0;n<u;n++)void 0===a[i=(r=t[n]).selector+\" \"]&&(a[i]=r.needsContext?-1<S(i,this).index(l):S.find(i,this,null,[l]).length),a[i]&&o.push(r);o.length&&s.push({elem:l,handlers:o})}return l=this,u<t.length&&s.push({elem:l,handlers:t.slice(u)}),s},addProp:function(t,e){Object.defineProperty(S.Event.prototype,t,{enumerable:!0,configurable:!0,get:m(e)?function(){if(this.originalEvent)return e(this.originalEvent)}:function(){if(this.originalEvent)return this.originalEvent[t]},set:function(e){Object.defineProperty(this,t,{enumerable:!0,configurable:!0,writable:!0,value:e})}})},fix:function(e){return e[S.expando]?e:new S.Event(e)},special:{load:{noBubble:!0},click:{setup:function(e){var t=this||e;return pe.test(t.type)&&t.click&&A(t,\"input\")&&Se(t,\"click\",we),!1},trigger:function(e){var t=this||e;return pe.test(t.type)&&t.click&&A(t,\"input\")&&Se(t,\"click\"),!0},_default:function(e){var t=e.target;return pe.test(t.type)&&t.click&&A(t,\"input\")&&Y.get(t,\"click\")||A(t,\"a\")}},beforeunload:{postDispatch:function(e){void 0!==e.result&&e.originalEvent&&(e.originalEvent.returnValue=e.result)}}}},S.removeEvent=function(e,t,n){e.removeEventListener&&e.removeEventListener(t,n)},S.Event=function(e,t){if(!(this instanceof S.Event))return new S.Event(e,t);e&&e.type?(this.originalEvent=e,this.type=e.type,this.isDefaultPrevented=e.defaultPrevented||void 0===e.defaultPrevented&&!1===e.returnValue?we:Te,this.target=e.target&&3===e.target.nodeType?e.target.parentNode:e.target,this.currentTarget=e.currentTarget,this.relatedTarget=e.relatedTarget):this.type=e,t&&S.extend(this,t),this.timeStamp=e&&e.timeStamp||Date.now(),this[S.expando]=!0},S.Event.prototype={constructor:S.Event,isDefaultPrevented:Te,isPropagationStopped:Te,isImmediatePropagationStopped:Te,isSimulated:!1,preventDefault:function(){var e=this.originalEvent;this.isDefaultPrevented=we,e&&!this.isSimulated&&e.preventDefault()},stopPropagation:function(){var e=this.originalEvent;this.isPropagationStopped=we,e&&!this.isSimulated&&e.stopPropagation()},stopImmediatePropagation:function(){var e=this.originalEvent;this.isImmediatePropagationStopped=we,e&&!this.isSimulated&&e.stopImmediatePropagation(),this.stopPropagation()}},S.each({altKey:!0,bubbles:!0,cancelable:!0,changedTouches:!0,ctrlKey:!0,detail:!0,eventPhase:!0,metaKey:!0,pageX:!0,pageY:!0,shiftKey:!0,view:!0,\"char\":!0,code:!0,charCode:!0,key:!0,keyCode:!0,button:!0,buttons:!0,clientX:!0,clientY:!0,offsetX:!0,offsetY:!0,pointerId:!0,pointerType:!0,screenX:!0,screenY:!0,targetTouches:!0,toElement:!0,touches:!0,which:!0},S.event.addProp),S.each({focus:\"focusin\",blur:\"focusout\"},function(e,t){S.event.special[e]={setup:function(){return Se(this,e,Ce),!1},trigger:function(){return Se(this,e),!0},_default:function(){return!0},delegateType:t}}),S.each({mouseenter:\"mouseover\",mouseleave:\"mouseout\",pointerenter:\"pointerover\",pointerleave:\"pointerout\"},function(e,i){S.event.special[e]={delegateType:i,bindType:i,handle:function(e){var t,n=e.relatedTarget,r=e.handleObj;return n&&(n===this||S.contains(this,n))||(e.type=r.origType,t=r.handler.apply(this,arguments),e.type=i),t}}}),S.fn.extend({on:function(e,t,n,r){return Ee(this,e,t,n,r)},one:function(e,t,n,r){return Ee(this,e,t,n,r,1)},off:function(e,t,n){var r,i;if(e&&e.preventDefault&&e.handleObj)return r=e.handleObj,S(e.delegateTarget).off(r.namespace?r.origType+\".\"+r.namespace:r.origType,r.selector,r.handler),this;if(\"object\"==typeof e){for(i in e)this.off(i,t,e[i]);return this}return!1!==t&&\"function\"!=typeof t||(n=t,t=void 0),!1===n&&(n=Te),this.each(function(){S.event.remove(this,e,n,t)})}});var ke=/<script|<style|<link/i,Ae=/checked\\s*(?:[^=]|=\\s*.checked.)/i,Ne=/^\\s*<!(?:\\[CDATA\\[|--)|(?:\\]\\]|--)>\\s*$/g;function je(e,t){return A(e,\"table\")&&A(11!==t.nodeType?t:t.firstChild,\"tr\")&&S(e).children(\"tbody\")[0]||e}function De(e){return e.type=(null!==e.getAttribute(\"type\"))+\"/\"+e.type,e}function qe(e){return\"true/\"===(e.type||\"\").slice(0,5)?e.type=e.type.slice(5):e.removeAttribute(\"type\"),e}function Le(e,t){var n,r,i,o,a,s;if(1===t.nodeType){if(Y.hasData(e)&&(s=Y.get(e).events))for(i in Y.remove(t,\"handle events\"),s)for(n=0,r=s[i].length;n<r;n++)S.event.add(t,i,s[i][n]);Q.hasData(e)&&(o=Q.access(e),a=S.extend({},o),Q.set(t,a))}}function He(n,r,i,o){r=g(r);var e,t,a,s,u,l,c=0,f=n.length,p=f-1,d=r[0],h=m(d);if(h||1<f&&\"string\"==typeof d&&!y.checkClone&&Ae.test(d))return n.each(function(e){var t=n.eq(e);h&&(r[0]=d.call(this,e,t.html())),He(t,r,i,o)});if(f&&(t=(e=xe(r,n[0].ownerDocument,!1,n,o)).firstChild,1===e.childNodes.length&&(e=t),t||o)){for(s=(a=S.map(ve(e,\"script\"),De)).length;c<f;c++)u=e,c!==p&&(u=S.clone(u,!0,!0),s&&S.merge(a,ve(u,\"script\"))),i.call(n[c],u,c);if(s)for(l=a[a.length-1].ownerDocument,S.map(a,qe),c=0;c<s;c++)u=a[c],he.test(u.type||\"\")&&!Y.access(u,\"globalEval\")&&S.contains(l,u)&&(u.src&&\"module\"!==(u.type||\"\").toLowerCase()?S._evalUrl&&!u.noModule&&S._evalUrl(u.src,{nonce:u.nonce||u.getAttribute(\"nonce\")},l):b(u.textContent.replace(Ne,\"\"),u,l))}return n}function Oe(e,t,n){for(var r,i=t?S.filter(t,e):e,o=0;null!=(r=i[o]);o++)n||1!==r.nodeType||S.cleanData(ve(r)),r.parentNode&&(n&&ie(r)&&ye(ve(r,\"script\")),r.parentNode.removeChild(r));return e}S.extend({htmlPrefilter:function(e){return e},clone:function(e,t,n){var r,i,o,a,s,u,l,c=e.cloneNode(!0),f=ie(e);if(!(y.noCloneChecked||1!==e.nodeType&&11!==e.nodeType||S.isXMLDoc(e)))for(a=ve(c),r=0,i=(o=ve(e)).length;r<i;r++)s=o[r],u=a[r],void 0,\"input\"===(l=u.nodeName.toLowerCase())&&pe.test(s.type)?u.checked=s.checked:\"input\"!==l&&\"textarea\"!==l||(u.defaultValue=s.defaultValue);if(t)if(n)for(o=o||ve(e),a=a||ve(c),r=0,i=o.length;r<i;r++)Le(o[r],a[r]);else Le(e,c);return 0<(a=ve(c,\"script\")).length&&ye(a,!f&&ve(e,\"script\")),c},cleanData:function(e){for(var t,n,r,i=S.event.special,o=0;void 0!==(n=e[o]);o++)if(V(n)){if(t=n[Y.expando]){if(t.events)for(r in t.events)i[r]?S.event.remove(n,r):S.removeEvent(n,r,t.handle);n[Y.expando]=void 0}n[Q.expando]&&(n[Q.expando]=void 0)}}}),S.fn.extend({detach:function(e){return Oe(this,e,!0)},remove:function(e){return Oe(this,e)},text:function(e){return $(this,function(e){return void 0===e?S.text(this):this.empty().each(function(){1!==this.nodeType&&11!==this.nodeType&&9!==this.nodeType||(this.textContent=e)})},null,e,arguments.length)},append:function(){return He(this,arguments,function(e){1!==this.nodeType&&11!==this.nodeType&&9!==this.nodeType||je(this,e).appendChild(e)})},prepend:function(){return He(this,arguments,function(e){if(1===this.nodeType||11===this.nodeType||9===this.nodeType){var t=je(this,e);t.insertBefore(e,t.firstChild)}})},before:function(){return He(this,arguments,function(e){this.parentNode&&this.parentNode.insertBefore(e,this)})},after:function(){return He(this,arguments,function(e){this.parentNode&&this.parentNode.insertBefore(e,this.nextSibling)})},empty:function(){for(var e,t=0;null!=(e=this[t]);t++)1===e.nodeType&&(S.cleanData(ve(e,!1)),e.textContent=\"\");return this},clone:function(e,t){return e=null!=e&&e,t=null==t?e:t,this.map(function(){return S.clone(this,e,t)})},html:function(e){return $(this,function(e){var t=this[0]||{},n=0,r=this.length;if(void 0===e&&1===t.nodeType)return t.innerHTML;if(\"string\"==typeof e&&!ke.test(e)&&!ge[(de.exec(e)||[\"\",\"\"])[1].toLowerCase()]){e=S.htmlPrefilter(e);try{for(;n<r;n++)1===(t=this[n]||{}).nodeType&&(S.cleanData(ve(t,!1)),t.innerHTML=e);t=0}catch(e){}}t&&this.empty().append(e)},null,e,arguments.length)},replaceWith:function(){var n=[];return He(this,arguments,function(e){var t=this.parentNode;S.inArray(this,n)<0&&(S.cleanData(ve(this)),t&&t.replaceChild(e,this))},n)}}),S.each({appendTo:\"append\",prependTo:\"prepend\",insertBefore:\"before\",insertAfter:\"after\",replaceAll:\"replaceWith\"},function(e,a){S.fn[e]=function(e){for(var t,n=[],r=S(e),i=r.length-1,o=0;o<=i;o++)t=o===i?this:this.clone(!0),S(r[o])[a](t),u.apply(n,t.get());return this.pushStack(n)}});var Pe=new RegExp(\"^(\"+ee+\")(?!px)[a-z%]+$\",\"i\"),Re=function(e){var t=e.ownerDocument.defaultView;return t&&t.opener||(t=C),t.getComputedStyle(e)},Me=function(e,t,n){var r,i,o={};for(i in t)o[i]=e.style[i],e.style[i]=t[i];for(i in r=n.call(e),t)e.style[i]=o[i];return r},Ie=new RegExp(ne.join(\"|\"),\"i\");function We(e,t,n){var r,i,o,a,s=e.style;return(n=n||Re(e))&&(\"\"!==(a=n.getPropertyValue(t)||n[t])||ie(e)||(a=S.style(e,t)),!y.pixelBoxStyles()&&Pe.test(a)&&Ie.test(t)&&(r=s.width,i=s.minWidth,o=s.maxWidth,s.minWidth=s.maxWidth=s.width=a,a=n.width,s.width=r,s.minWidth=i,s.maxWidth=o)),void 0!==a?a+\"\":a}function Fe(e,t){return{get:function(){if(!e())return(this.get=t).apply(this,arguments);delete this.get}}}!function(){function e(){if(l){u.style.cssText=\"position:absolute;left:-11111px;width:60px;margin-top:1px;padding:0;border:0\",l.style.cssText=\"position:relative;display:block;box-sizing:border-box;overflow:scroll;margin:auto;border:1px;padding:1px;width:60%;top:1%\",re.appendChild(u).appendChild(l);var e=C.getComputedStyle(l);n=\"1%\"!==e.top,s=12===t(e.marginLeft),l.style.right=\"60%\",o=36===t(e.right),r=36===t(e.width),l.style.position=\"absolute\",i=12===t(l.offsetWidth/3),re.removeChild(u),l=null}}function t(e){return Math.round(parseFloat(e))}var n,r,i,o,a,s,u=E.createElement(\"div\"),l=E.createElement(\"div\");l.style&&(l.style.backgroundClip=\"content-box\",l.cloneNode(!0).style.backgroundClip=\"\",y.clearCloneStyle=\"content-box\"===l.style.backgroundClip,S.extend(y,{boxSizingReliable:function(){return e(),r},pixelBoxStyles:function(){return e(),o},pixelPosition:function(){return e(),n},reliableMarginLeft:function(){return e(),s},scrollboxSize:function(){return e(),i},reliableTrDimensions:function(){var e,t,n,r;return null==a&&(e=E.createElement(\"table\"),t=E.createElement(\"tr\"),n=E.createElement(\"div\"),e.style.cssText=\"position:absolute;left:-11111px;border-collapse:separate\",t.style.cssText=\"border:1px solid\",t.style.height=\"1px\",n.style.height=\"9px\",n.style.display=\"block\",re.appendChild(e).appendChild(t).appendChild(n),r=C.getComputedStyle(t),a=parseInt(r.height,10)+parseInt(r.borderTopWidth,10)+parseInt(r.borderBottomWidth,10)===t.offsetHeight,re.removeChild(e)),a}}))}();var Be=[\"Webkit\",\"Moz\",\"ms\"],$e=E.createElement(\"div\").style,_e={};function ze(e){var t=S.cssProps[e]||_e[e];return t||(e in $e?e:_e[e]=function(e){var t=e[0].toUpperCase()+e.slice(1),n=Be.length;while(n--)if((e=Be[n]+t)in $e)return e}(e)||e)}var Ue=/^(none|table(?!-c[ea]).+)/,Xe=/^--/,Ve={position:\"absolute\",visibility:\"hidden\",display:\"block\"},Ge={letterSpacing:\"0\",fontWeight:\"400\"};function Ye(e,t,n){var r=te.exec(t);return r?Math.max(0,r[2]-(n||0))+(r[3]||\"px\"):t}function Qe(e,t,n,r,i,o){var a=\"width\"===t?1:0,s=0,u=0;if(n===(r?\"border\":\"content\"))return 0;for(;a<4;a+=2)\"margin\"===n&&(u+=S.css(e,n+ne[a],!0,i)),r?(\"content\"===n&&(u-=S.css(e,\"padding\"+ne[a],!0,i)),\"margin\"!==n&&(u-=S.css(e,\"border\"+ne[a]+\"Width\",!0,i))):(u+=S.css(e,\"padding\"+ne[a],!0,i),\"padding\"!==n?u+=S.css(e,\"border\"+ne[a]+\"Width\",!0,i):s+=S.css(e,\"border\"+ne[a]+\"Width\",!0,i));return!r&&0<=o&&(u+=Math.max(0,Math.ceil(e[\"offset\"+t[0].toUpperCase()+t.slice(1)]-o-u-s-.5))||0),u}function Je(e,t,n){var r=Re(e),i=(!y.boxSizingReliable()||n)&&\"border-box\"===S.css(e,\"boxSizing\",!1,r),o=i,a=We(e,t,r),s=\"offset\"+t[0].toUpperCase()+t.slice(1);if(Pe.test(a)){if(!n)return a;a=\"auto\"}return(!y.boxSizingReliable()&&i||!y.reliableTrDimensions()&&A(e,\"tr\")||\"auto\"===a||!parseFloat(a)&&\"inline\"===S.css(e,\"display\",!1,r))&&e.getClientRects().length&&(i=\"border-box\"===S.css(e,\"boxSizing\",!1,r),(o=s in e)&&(a=e[s])),(a=parseFloat(a)||0)+Qe(e,t,n||(i?\"border\":\"content\"),o,r,a)+\"px\"}function Ke(e,t,n,r,i){return new Ke.prototype.init(e,t,n,r,i)}S.extend({cssHooks:{opacity:{get:function(e,t){if(t){var n=We(e,\"opacity\");return\"\"===n?\"1\":n}}}},cssNumber:{animationIterationCount:!0,columnCount:!0,fillOpacity:!0,flexGrow:!0,flexShrink:!0,fontWeight:!0,gridArea:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnStart:!0,gridRow:!0,gridRowEnd:!0,gridRowStart:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,widows:!0,zIndex:!0,zoom:!0},cssProps:{},style:function(e,t,n,r){if(e&&3!==e.nodeType&&8!==e.nodeType&&e.style){var i,o,a,s=X(t),u=Xe.test(t),l=e.style;if(u||(t=ze(s)),a=S.cssHooks[t]||S.cssHooks[s],void 0===n)return a&&\"get\"in a&&void 0!==(i=a.get(e,!1,r))?i:l[t];\"string\"===(o=typeof n)&&(i=te.exec(n))&&i[1]&&(n=se(e,t,i),o=\"number\"),null!=n&&n==n&&(\"number\"!==o||u||(n+=i&&i[3]||(S.cssNumber[s]?\"\":\"px\")),y.clearCloneStyle||\"\"!==n||0!==t.indexOf(\"background\")||(l[t]=\"inherit\"),a&&\"set\"in a&&void 0===(n=a.set(e,n,r))||(u?l.setProperty(t,n):l[t]=n))}},css:function(e,t,n,r){var i,o,a,s=X(t);return Xe.test(t)||(t=ze(s)),(a=S.cssHooks[t]||S.cssHooks[s])&&\"get\"in a&&(i=a.get(e,!0,n)),void 0===i&&(i=We(e,t,r)),\"normal\"===i&&t in Ge&&(i=Ge[t]),\"\"===n||n?(o=parseFloat(i),!0===n||isFinite(o)?o||0:i):i}}),S.each([\"height\",\"width\"],function(e,u){S.cssHooks[u]={get:function(e,t,n){if(t)return!Ue.test(S.css(e,\"display\"))||e.getClientRects().length&&e.getBoundingClientRect().width?Je(e,u,n):Me(e,Ve,function(){return Je(e,u,n)})},set:function(e,t,n){var r,i=Re(e),o=!y.scrollboxSize()&&\"absolute\"===i.position,a=(o||n)&&\"border-box\"===S.css(e,\"boxSizing\",!1,i),s=n?Qe(e,u,n,a,i):0;return a&&o&&(s-=Math.ceil(e[\"offset\"+u[0].toUpperCase()+u.slice(1)]-parseFloat(i[u])-Qe(e,u,\"border\",!1,i)-.5)),s&&(r=te.exec(t))&&\"px\"!==(r[3]||\"px\")&&(e.style[u]=t,t=S.css(e,u)),Ye(0,t,s)}}}),S.cssHooks.marginLeft=Fe(y.reliableMarginLeft,function(e,t){if(t)return(parseFloat(We(e,\"marginLeft\"))||e.getBoundingClientRect().left-Me(e,{marginLeft:0},function(){return e.getBoundingClientRect().left}))+\"px\"}),S.each({margin:\"\",padding:\"\",border:\"Width\"},function(i,o){S.cssHooks[i+o]={expand:function(e){for(var t=0,n={},r=\"string\"==typeof e?e.split(\" \"):[e];t<4;t++)n[i+ne[t]+o]=r[t]||r[t-2]||r[0];return n}},\"margin\"!==i&&(S.cssHooks[i+o].set=Ye)}),S.fn.extend({css:function(e,t){return $(this,function(e,t,n){var r,i,o={},a=0;if(Array.isArray(t)){for(r=Re(e),i=t.length;a<i;a++)o[t[a]]=S.css(e,t[a],!1,r);return o}return void 0!==n?S.style(e,t,n):S.css(e,t)},e,t,1<arguments.length)}}),((S.Tween=Ke).prototype={constructor:Ke,init:function(e,t,n,r,i,o){this.elem=e,this.prop=n,this.easing=i||S.easing._default,this.options=t,this.start=this.now=this.cur(),this.end=r,this.unit=o||(S.cssNumber[n]?\"\":\"px\")},cur:function(){var e=Ke.propHooks[this.prop];return e&&e.get?e.get(this):Ke.propHooks._default.get(this)},run:function(e){var t,n=Ke.propHooks[this.prop];return this.options.duration?this.pos=t=S.easing[this.easing](e,this.options.duration*e,0,1,this.options.duration):this.pos=t=e,this.now=(this.end-this.start)*t+this.start,this.options.step&&this.options.step.call(this.elem,this.now,this),n&&n.set?n.set(this):Ke.propHooks._default.set(this),this}}).init.prototype=Ke.prototype,(Ke.propHooks={_default:{get:function(e){var t;return 1!==e.elem.nodeType||null!=e.elem[e.prop]&&null==e.elem.style[e.prop]?e.elem[e.prop]:(t=S.css(e.elem,e.prop,\"\"))&&\"auto\"!==t?t:0},set:function(e){S.fx.step[e.prop]?S.fx.step[e.prop](e):1!==e.elem.nodeType||!S.cssHooks[e.prop]&&null==e.elem.style[ze(e.prop)]?e.elem[e.prop]=e.now:S.style(e.elem,e.prop,e.now+e.unit)}}}).scrollTop=Ke.propHooks.scrollLeft={set:function(e){e.elem.nodeType&&e.elem.parentNode&&(e.elem[e.prop]=e.now)}},S.easing={linear:function(e){return e},swing:function(e){return.5-Math.cos(e*Math.PI)/2},_default:\"swing\"},S.fx=Ke.prototype.init,S.fx.step={};var Ze,et,tt,nt,rt=/^(?:toggle|show|hide)$/,it=/queueHooks$/;function ot(){et&&(!1===E.hidden&&C.requestAnimationFrame?C.requestAnimationFrame(ot):C.setTimeout(ot,S.fx.interval),S.fx.tick())}function at(){return C.setTimeout(function(){Ze=void 0}),Ze=Date.now()}function st(e,t){var n,r=0,i={height:e};for(t=t?1:0;r<4;r+=2-t)i[\"margin\"+(n=ne[r])]=i[\"padding\"+n]=e;return t&&(i.opacity=i.width=e),i}function ut(e,t,n){for(var r,i=(lt.tweeners[t]||[]).concat(lt.tweeners[\"*\"]),o=0,a=i.length;o<a;o++)if(r=i[o].call(n,t,e))return r}function lt(o,e,t){var n,a,r=0,i=lt.prefilters.length,s=S.Deferred().always(function(){delete u.elem}),u=function(){if(a)return!1;for(var e=Ze||at(),t=Math.max(0,l.startTime+l.duration-e),n=1-(t/l.duration||0),r=0,i=l.tweens.length;r<i;r++)l.tweens[r].run(n);return s.notifyWith(o,[l,n,t]),n<1&&i?t:(i||s.notifyWith(o,[l,1,0]),s.resolveWith(o,[l]),!1)},l=s.promise({elem:o,props:S.extend({},e),opts:S.extend(!0,{specialEasing:{},easing:S.easing._default},t),originalProperties:e,originalOptions:t,startTime:Ze||at(),duration:t.duration,tweens:[],createTween:function(e,t){var n=S.Tween(o,l.opts,e,t,l.opts.specialEasing[e]||l.opts.easing);return l.tweens.push(n),n},stop:function(e){var t=0,n=e?l.tweens.length:0;if(a)return this;for(a=!0;t<n;t++)l.tweens[t].run(1);return e?(s.notifyWith(o,[l,1,0]),s.resolveWith(o,[l,e])):s.rejectWith(o,[l,e]),this}}),c=l.props;for(!function(e,t){var n,r,i,o,a;for(n in e)if(i=t[r=X(n)],o=e[n],Array.isArray(o)&&(i=o[1],o=e[n]=o[0]),n!==r&&(e[r]=o,delete e[n]),(a=S.cssHooks[r])&&\"expand\"in a)for(n in o=a.expand(o),delete e[r],o)n in e||(e[n]=o[n],t[n]=i);else t[r]=i}(c,l.opts.specialEasing);r<i;r++)if(n=lt.prefilters[r].call(l,o,c,l.opts))return m(n.stop)&&(S._queueHooks(l.elem,l.opts.queue).stop=n.stop.bind(n)),n;return S.map(c,ut,l),m(l.opts.start)&&l.opts.start.call(o,l),l.progress(l.opts.progress).done(l.opts.done,l.opts.complete).fail(l.opts.fail).always(l.opts.always),S.fx.timer(S.extend(u,{elem:o,anim:l,queue:l.opts.queue})),l}S.Animation=S.extend(lt,{tweeners:{\"*\":[function(e,t){var n=this.createTween(e,t);return se(n.elem,e,te.exec(t),n),n}]},tweener:function(e,t){m(e)?(t=e,e=[\"*\"]):e=e.match(P);for(var n,r=0,i=e.length;r<i;r++)n=e[r],lt.tweeners[n]=lt.tweeners[n]||[],lt.tweeners[n].unshift(t)},prefilters:[function(e,t,n){var r,i,o,a,s,u,l,c,f=\"width\"in t||\"height\"in t,p=this,d={},h=e.style,g=e.nodeType&&ae(e),v=Y.get(e,\"fxshow\");for(r in n.queue||(null==(a=S._queueHooks(e,\"fx\")).unqueued&&(a.unqueued=0,s=a.empty.fire,a.empty.fire=function(){a.unqueued||s()}),a.unqueued++,p.always(function(){p.always(function(){a.unqueued--,S.queue(e,\"fx\").length||a.empty.fire()})})),t)if(i=t[r],rt.test(i)){if(delete t[r],o=o||\"toggle\"===i,i===(g?\"hide\":\"show\")){if(\"show\"!==i||!v||void 0===v[r])continue;g=!0}d[r]=v&&v[r]||S.style(e,r)}if((u=!S.isEmptyObject(t))||!S.isEmptyObject(d))for(r in f&&1===e.nodeType&&(n.overflow=[h.overflow,h.overflowX,h.overflowY],null==(l=v&&v.display)&&(l=Y.get(e,\"display\")),\"none\"===(c=S.css(e,\"display\"))&&(l?c=l:(le([e],!0),l=e.style.display||l,c=S.css(e,\"display\"),le([e]))),(\"inline\"===c||\"inline-block\"===c&&null!=l)&&\"none\"===S.css(e,\"float\")&&(u||(p.done(function(){h.display=l}),null==l&&(c=h.display,l=\"none\"===c?\"\":c)),h.display=\"inline-block\")),n.overflow&&(h.overflow=\"hidden\",p.always(function(){h.overflow=n.overflow[0],h.overflowX=n.overflow[1],h.overflowY=n.overflow[2]})),u=!1,d)u||(v?\"hidden\"in v&&(g=v.hidden):v=Y.access(e,\"fxshow\",{display:l}),o&&(v.hidden=!g),g&&le([e],!0),p.done(function(){for(r in g||le([e]),Y.remove(e,\"fxshow\"),d)S.style(e,r,d[r])})),u=ut(g?v[r]:0,r,p),r in v||(v[r]=u.start,g&&(u.end=u.start,u.start=0))}],prefilter:function(e,t){t?lt.prefilters.unshift(e):lt.prefilters.push(e)}}),S.speed=function(e,t,n){var r=e&&\"object\"==typeof e?S.extend({},e):{complete:n||!n&&t||m(e)&&e,duration:e,easing:n&&t||t&&!m(t)&&t};return S.fx.off?r.duration=0:\"number\"!=typeof r.duration&&(r.duration in S.fx.speeds?r.duration=S.fx.speeds[r.duration]:r.duration=S.fx.speeds._default),null!=r.queue&&!0!==r.queue||(r.queue=\"fx\"),r.old=r.complete,r.complete=function(){m(r.old)&&r.old.call(this),r.queue&&S.dequeue(this,r.queue)},r},S.fn.extend({fadeTo:function(e,t,n,r){return this.filter(ae).css(\"opacity\",0).show().end().animate({opacity:t},e,n,r)},animate:function(t,e,n,r){var i=S.isEmptyObject(t),o=S.speed(e,n,r),a=function(){var e=lt(this,S.extend({},t),o);(i||Y.get(this,\"finish\"))&&e.stop(!0)};return a.finish=a,i||!1===o.queue?this.each(a):this.queue(o.queue,a)},stop:function(i,e,o){var a=function(e){var t=e.stop;delete e.stop,t(o)};return\"string\"!=typeof i&&(o=e,e=i,i=void 0),e&&this.queue(i||\"fx\",[]),this.each(function(){var e=!0,t=null!=i&&i+\"queueHooks\",n=S.timers,r=Y.get(this);if(t)r[t]&&r[t].stop&&a(r[t]);else for(t in r)r[t]&&r[t].stop&&it.test(t)&&a(r[t]);for(t=n.length;t--;)n[t].elem!==this||null!=i&&n[t].queue!==i||(n[t].anim.stop(o),e=!1,n.splice(t,1));!e&&o||S.dequeue(this,i)})},finish:function(a){return!1!==a&&(a=a||\"fx\"),this.each(function(){var e,t=Y.get(this),n=t[a+\"queue\"],r=t[a+\"queueHooks\"],i=S.timers,o=n?n.length:0;for(t.finish=!0,S.queue(this,a,[]),r&&r.stop&&r.stop.call(this,!0),e=i.length;e--;)i[e].elem===this&&i[e].queue===a&&(i[e].anim.stop(!0),i.splice(e,1));for(e=0;e<o;e++)n[e]&&n[e].finish&&n[e].finish.call(this);delete t.finish})}}),S.each([\"toggle\",\"show\",\"hide\"],function(e,r){var i=S.fn[r];S.fn[r]=function(e,t,n){return null==e||\"boolean\"==typeof e?i.apply(this,arguments):this.animate(st(r,!0),e,t,n)}}),S.each({slideDown:st(\"show\"),slideUp:st(\"hide\"),slideToggle:st(\"toggle\"),fadeIn:{opacity:\"show\"},fadeOut:{opacity:\"hide\"},fadeToggle:{opacity:\"toggle\"}},function(e,r){S.fn[e]=function(e,t,n){return this.animate(r,e,t,n)}}),S.timers=[],S.fx.tick=function(){var e,t=0,n=S.timers;for(Ze=Date.now();t<n.length;t++)(e=n[t])()||n[t]!==e||n.splice(t--,1);n.length||S.fx.stop(),Ze=void 0},S.fx.timer=function(e){S.timers.push(e),S.fx.start()},S.fx.interval=13,S.fx.start=function(){et||(et=!0,ot())},S.fx.stop=function(){et=null},S.fx.speeds={slow:600,fast:200,_default:400},S.fn.delay=function(r,e){return r=S.fx&&S.fx.speeds[r]||r,e=e||\"fx\",this.queue(e,function(e,t){var n=C.setTimeout(e,r);t.stop=function(){C.clearTimeout(n)}})},tt=E.createElement(\"input\"),nt=E.createElement(\"select\").appendChild(E.createElement(\"option\")),tt.type=\"checkbox\",y.checkOn=\"\"!==tt.value,y.optSelected=nt.selected,(tt=E.createElement(\"input\")).value=\"t\",tt.type=\"radio\",y.radioValue=\"t\"===tt.value;var ct,ft=S.expr.attrHandle;S.fn.extend({attr:function(e,t){return $(this,S.attr,e,t,1<arguments.length)},removeAttr:function(e){return this.each(function(){S.removeAttr(this,e)})}}),S.extend({attr:function(e,t,n){var r,i,o=e.nodeType;if(3!==o&&8!==o&&2!==o)return\"undefined\"==typeof e.getAttribute?S.prop(e,t,n):(1===o&&S.isXMLDoc(e)||(i=S.attrHooks[t.toLowerCase()]||(S.expr.match.bool.test(t)?ct:void 0)),void 0!==n?null===n?void S.removeAttr(e,t):i&&\"set\"in i&&void 0!==(r=i.set(e,n,t))?r:(e.setAttribute(t,n+\"\"),n):i&&\"get\"in i&&null!==(r=i.get(e,t))?r:null==(r=S.find.attr(e,t))?void 0:r)},attrHooks:{type:{set:function(e,t){if(!y.radioValue&&\"radio\"===t&&A(e,\"input\")){var n=e.value;return e.setAttribute(\"type\",t),n&&(e.value=n),t}}}},removeAttr:function(e,t){var n,r=0,i=t&&t.match(P);if(i&&1===e.nodeType)while(n=i[r++])e.removeAttribute(n)}}),ct={set:function(e,t,n){return!1===t?S.removeAttr(e,n):e.setAttribute(n,n),n}},S.each(S.expr.match.bool.source.match(/\\w+/g),function(e,t){var a=ft[t]||S.find.attr;ft[t]=function(e,t,n){var r,i,o=t.toLowerCase();return n||(i=ft[o],ft[o]=r,r=null!=a(e,t,n)?o:null,ft[o]=i),r}});var pt=/^(?:input|select|textarea|button)$/i,dt=/^(?:a|area)$/i;function ht(e){return(e.match(P)||[]).join(\" \")}function gt(e){return e.getAttribute&&e.getAttribute(\"class\")||\"\"}function vt(e){return Array.isArray(e)?e:\"string\"==typeof e&&e.match(P)||[]}S.fn.extend({prop:function(e,t){return $(this,S.prop,e,t,1<arguments.length)},removeProp:function(e){return this.each(function(){delete this[S.propFix[e]||e]})}}),S.extend({prop:function(e,t,n){var r,i,o=e.nodeType;if(3!==o&&8!==o&&2!==o)return 1===o&&S.isXMLDoc(e)||(t=S.propFix[t]||t,i=S.propHooks[t]),void 0!==n?i&&\"set\"in i&&void 0!==(r=i.set(e,n,t))?r:e[t]=n:i&&\"get\"in i&&null!==(r=i.get(e,t))?r:e[t]},propHooks:{tabIndex:{get:function(e){var t=S.find.attr(e,\"tabindex\");return t?parseInt(t,10):pt.test(e.nodeName)||dt.test(e.nodeName)&&e.href?0:-1}}},propFix:{\"for\":\"htmlFor\",\"class\":\"className\"}}),y.optSelected||(S.propHooks.selected={get:function(e){var t=e.parentNode;return t&&t.parentNode&&t.parentNode.selectedIndex,null},set:function(e){var t=e.parentNode;t&&(t.selectedIndex,t.parentNode&&t.parentNode.selectedIndex)}}),S.each([\"tabIndex\",\"readOnly\",\"maxLength\",\"cellSpacing\",\"cellPadding\",\"rowSpan\",\"colSpan\",\"useMap\",\"frameBorder\",\"contentEditable\"],function(){S.propFix[this.toLowerCase()]=this}),S.fn.extend({addClass:function(t){var e,n,r,i,o,a,s,u=0;if(m(t))return this.each(function(e){S(this).addClass(t.call(this,e,gt(this)))});if((e=vt(t)).length)while(n=this[u++])if(i=gt(n),r=1===n.nodeType&&\" \"+ht(i)+\" \"){a=0;while(o=e[a++])r.indexOf(\" \"+o+\" \")<0&&(r+=o+\" \");i!==(s=ht(r))&&n.setAttribute(\"class\",s)}return this},removeClass:function(t){var e,n,r,i,o,a,s,u=0;if(m(t))return this.each(function(e){S(this).removeClass(t.call(this,e,gt(this)))});if(!arguments.length)return this.attr(\"class\",\"\");if((e=vt(t)).length)while(n=this[u++])if(i=gt(n),r=1===n.nodeType&&\" \"+ht(i)+\" \"){a=0;while(o=e[a++])while(-1<r.indexOf(\" \"+o+\" \"))r=r.replace(\" \"+o+\" \",\" \");i!==(s=ht(r))&&n.setAttribute(\"class\",s)}return this},toggleClass:function(i,t){var o=typeof i,a=\"string\"===o||Array.isArray(i);return\"boolean\"==typeof t&&a?t?this.addClass(i):this.removeClass(i):m(i)?this.each(function(e){S(this).toggleClass(i.call(this,e,gt(this),t),t)}):this.each(function(){var e,t,n,r;if(a){t=0,n=S(this),r=vt(i);while(e=r[t++])n.hasClass(e)?n.removeClass(e):n.addClass(e)}else void 0!==i&&\"boolean\"!==o||((e=gt(this))&&Y.set(this,\"__className__\",e),this.setAttribute&&this.setAttribute(\"class\",e||!1===i?\"\":Y.get(this,\"__className__\")||\"\"))})},hasClass:function(e){var t,n,r=0;t=\" \"+e+\" \";while(n=this[r++])if(1===n.nodeType&&-1<(\" \"+ht(gt(n))+\" \").indexOf(t))return!0;return!1}});var yt=/\\r/g;S.fn.extend({val:function(n){var r,e,i,t=this[0];return arguments.length?(i=m(n),this.each(function(e){var t;1===this.nodeType&&(null==(t=i?n.call(this,e,S(this).val()):n)?t=\"\":\"number\"==typeof t?t+=\"\":Array.isArray(t)&&(t=S.map(t,function(e){return null==e?\"\":e+\"\"})),(r=S.valHooks[this.type]||S.valHooks[this.nodeName.toLowerCase()])&&\"set\"in r&&void 0!==r.set(this,t,\"value\")||(this.value=t))})):t?(r=S.valHooks[t.type]||S.valHooks[t.nodeName.toLowerCase()])&&\"get\"in r&&void 0!==(e=r.get(t,\"value\"))?e:\"string\"==typeof(e=t.value)?e.replace(yt,\"\"):null==e?\"\":e:void 0}}),S.extend({valHooks:{option:{get:function(e){var t=S.find.attr(e,\"value\");return null!=t?t:ht(S.text(e))}},select:{get:function(e){var t,n,r,i=e.options,o=e.selectedIndex,a=\"select-one\"===e.type,s=a?null:[],u=a?o+1:i.length;for(r=o<0?u:a?o:0;r<u;r++)if(((n=i[r]).selected||r===o)&&!n.disabled&&(!n.parentNode.disabled||!A(n.parentNode,\"optgroup\"))){if(t=S(n).val(),a)return t;s.push(t)}return s},set:function(e,t){var n,r,i=e.options,o=S.makeArray(t),a=i.length;while(a--)((r=i[a]).selected=-1<S.inArray(S.valHooks.option.get(r),o))&&(n=!0);return n||(e.selectedIndex=-1),o}}}}),S.each([\"radio\",\"checkbox\"],function(){S.valHooks[this]={set:function(e,t){if(Array.isArray(t))return e.checked=-1<S.inArray(S(e).val(),t)}},y.checkOn||(S.valHooks[this].get=function(e){return null===e.getAttribute(\"value\")?\"on\":e.value})}),y.focusin=\"onfocusin\"in C;var mt=/^(?:focusinfocus|focusoutblur)$/,xt=function(e){e.stopPropagation()};S.extend(S.event,{trigger:function(e,t,n,r){var i,o,a,s,u,l,c,f,p=[n||E],d=v.call(e,\"type\")?e.type:e,h=v.call(e,\"namespace\")?e.namespace.split(\".\"):[];if(o=f=a=n=n||E,3!==n.nodeType&&8!==n.nodeType&&!mt.test(d+S.event.triggered)&&(-1<d.indexOf(\".\")&&(d=(h=d.split(\".\")).shift(),h.sort()),u=d.indexOf(\":\")<0&&\"on\"+d,(e=e[S.expando]?e:new S.Event(d,\"object\"==typeof e&&e)).isTrigger=r?2:3,e.namespace=h.join(\".\"),e.rnamespace=e.namespace?new RegExp(\"(^|\\\\.)\"+h.join(\"\\\\.(?:.*\\\\.|)\")+\"(\\\\.|$)\"):null,e.result=void 0,e.target||(e.target=n),t=null==t?[e]:S.makeArray(t,[e]),c=S.event.special[d]||{},r||!c.trigger||!1!==c.trigger.apply(n,t))){if(!r&&!c.noBubble&&!x(n)){for(s=c.delegateType||d,mt.test(s+d)||(o=o.parentNode);o;o=o.parentNode)p.push(o),a=o;a===(n.ownerDocument||E)&&p.push(a.defaultView||a.parentWindow||C)}i=0;while((o=p[i++])&&!e.isPropagationStopped())f=o,e.type=1<i?s:c.bindType||d,(l=(Y.get(o,\"events\")||Object.create(null))[e.type]&&Y.get(o,\"handle\"))&&l.apply(o,t),(l=u&&o[u])&&l.apply&&V(o)&&(e.result=l.apply(o,t),!1===e.result&&e.preventDefault());return e.type=d,r||e.isDefaultPrevented()||c._default&&!1!==c._default.apply(p.pop(),t)||!V(n)||u&&m(n[d])&&!x(n)&&((a=n[u])&&(n[u]=null),S.event.triggered=d,e.isPropagationStopped()&&f.addEventListener(d,xt),n[d](),e.isPropagationStopped()&&f.removeEventListener(d,xt),S.event.triggered=void 0,a&&(n[u]=a)),e.result}},simulate:function(e,t,n){var r=S.extend(new S.Event,n,{type:e,isSimulated:!0});S.event.trigger(r,null,t)}}),S.fn.extend({trigger:function(e,t){return this.each(function(){S.event.trigger(e,t,this)})},triggerHandler:function(e,t){var n=this[0];if(n)return S.event.trigger(e,t,n,!0)}}),y.focusin||S.each({focus:\"focusin\",blur:\"focusout\"},function(n,r){var i=function(e){S.event.simulate(r,e.target,S.event.fix(e))};S.event.special[r]={setup:function(){var e=this.ownerDocument||this.document||this,t=Y.access(e,r);t||e.addEventListener(n,i,!0),Y.access(e,r,(t||0)+1)},teardown:function(){var e=this.ownerDocument||this.document||this,t=Y.access(e,r)-1;t?Y.access(e,r,t):(e.removeEventListener(n,i,!0),Y.remove(e,r))}}});var bt=C.location,wt={guid:Date.now()},Tt=/\\?/;S.parseXML=function(e){var t,n;if(!e||\"string\"!=typeof e)return null;try{t=(new C.DOMParser).parseFromString(e,\"text/xml\")}catch(e){}return n=t&&t.getElementsByTagName(\"parsererror\")[0],t&&!n||S.error(\"Invalid XML: \"+(n?S.map(n.childNodes,function(e){return e.textContent}).join(\"\\n\"):e)),t};var Ct=/\\[\\]$/,Et=/\\r?\\n/g,St=/^(?:submit|button|image|reset|file)$/i,kt=/^(?:input|select|textarea|keygen)/i;function At(n,e,r,i){var t;if(Array.isArray(e))S.each(e,function(e,t){r||Ct.test(n)?i(n,t):At(n+\"[\"+(\"object\"==typeof t&&null!=t?e:\"\")+\"]\",t,r,i)});else if(r||\"object\"!==w(e))i(n,e);else for(t in e)At(n+\"[\"+t+\"]\",e[t],r,i)}S.param=function(e,t){var n,r=[],i=function(e,t){var n=m(t)?t():t;r[r.length]=encodeURIComponent(e)+\"=\"+encodeURIComponent(null==n?\"\":n)};if(null==e)return\"\";if(Array.isArray(e)||e.jquery&&!S.isPlainObject(e))S.each(e,function(){i(this.name,this.value)});else for(n in e)At(n,e[n],t,i);return r.join(\"&\")},S.fn.extend({serialize:function(){return S.param(this.serializeArray())},serializeArray:function(){return this.map(function(){var e=S.prop(this,\"elements\");return e?S.makeArray(e):this}).filter(function(){var e=this.type;return this.name&&!S(this).is(\":disabled\")&&kt.test(this.nodeName)&&!St.test(e)&&(this.checked||!pe.test(e))}).map(function(e,t){var n=S(this).val();return null==n?null:Array.isArray(n)?S.map(n,function(e){return{name:t.name,value:e.replace(Et,\"\\r\\n\")}}):{name:t.name,value:n.replace(Et,\"\\r\\n\")}}).get()}});var Nt=/%20/g,jt=/#.*$/,Dt=/([?&])_=[^&]*/,qt=/^(.*?):[ \\t]*([^\\r\\n]*)$/gm,Lt=/^(?:GET|HEAD)$/,Ht=/^\\/\\//,Ot={},Pt={},Rt=\"*/\".concat(\"*\"),Mt=E.createElement(\"a\");function It(o){return function(e,t){\"string\"!=typeof e&&(t=e,e=\"*\");var n,r=0,i=e.toLowerCase().match(P)||[];if(m(t))while(n=i[r++])\"+\"===n[0]?(n=n.slice(1)||\"*\",(o[n]=o[n]||[]).unshift(t)):(o[n]=o[n]||[]).push(t)}}function Wt(t,i,o,a){var s={},u=t===Pt;function l(e){var r;return s[e]=!0,S.each(t[e]||[],function(e,t){var n=t(i,o,a);return\"string\"!=typeof n||u||s[n]?u?!(r=n):void 0:(i.dataTypes.unshift(n),l(n),!1)}),r}return l(i.dataTypes[0])||!s[\"*\"]&&l(\"*\")}function Ft(e,t){var n,r,i=S.ajaxSettings.flatOptions||{};for(n in t)void 0!==t[n]&&((i[n]?e:r||(r={}))[n]=t[n]);return r&&S.extend(!0,e,r),e}Mt.href=bt.href,S.extend({active:0,lastModified:{},etag:{},ajaxSettings:{url:bt.href,type:\"GET\",isLocal:/^(?:about|app|app-storage|.+-extension|file|res|widget):$/.test(bt.protocol),global:!0,processData:!0,async:!0,contentType:\"application/x-www-form-urlencoded; charset=UTF-8\",accepts:{\"*\":Rt,text:\"text/plain\",html:\"text/html\",xml:\"application/xml, text/xml\",json:\"application/json, text/javascript\"},contents:{xml:/\\bxml\\b/,html:/\\bhtml/,json:/\\bjson\\b/},responseFields:{xml:\"responseXML\",text:\"responseText\",json:\"responseJSON\"},converters:{\"* text\":String,\"text html\":!0,\"text json\":JSON.parse,\"text xml\":S.parseXML},flatOptions:{url:!0,context:!0}},ajaxSetup:function(e,t){return t?Ft(Ft(e,S.ajaxSettings),t):Ft(S.ajaxSettings,e)},ajaxPrefilter:It(Ot),ajaxTransport:It(Pt),ajax:function(e,t){\"object\"==typeof e&&(t=e,e=void 0),t=t||{};var c,f,p,n,d,r,h,g,i,o,v=S.ajaxSetup({},t),y=v.context||v,m=v.context&&(y.nodeType||y.jquery)?S(y):S.event,x=S.Deferred(),b=S.Callbacks(\"once memory\"),w=v.statusCode||{},a={},s={},u=\"canceled\",T={readyState:0,getResponseHeader:function(e){var t;if(h){if(!n){n={};while(t=qt.exec(p))n[t[1].toLowerCase()+\" \"]=(n[t[1].toLowerCase()+\" \"]||[]).concat(t[2])}t=n[e.toLowerCase()+\" \"]}return null==t?null:t.join(\", \")},getAllResponseHeaders:function(){return h?p:null},setRequestHeader:function(e,t){return null==h&&(e=s[e.toLowerCase()]=s[e.toLowerCase()]||e,a[e]=t),this},overrideMimeType:function(e){return null==h&&(v.mimeType=e),this},statusCode:function(e){var t;if(e)if(h)T.always(e[T.status]);else for(t in e)w[t]=[w[t],e[t]];return this},abort:function(e){var t=e||u;return c&&c.abort(t),l(0,t),this}};if(x.promise(T),v.url=((e||v.url||bt.href)+\"\").replace(Ht,bt.protocol+\"//\"),v.type=t.method||t.type||v.method||v.type,v.dataTypes=(v.dataType||\"*\").toLowerCase().match(P)||[\"\"],null==v.crossDomain){r=E.createElement(\"a\");try{r.href=v.url,r.href=r.href,v.crossDomain=Mt.protocol+\"//\"+Mt.host!=r.protocol+\"//\"+r.host}catch(e){v.crossDomain=!0}}if(v.data&&v.processData&&\"string\"!=typeof v.data&&(v.data=S.param(v.data,v.traditional)),Wt(Ot,v,t,T),h)return T;for(i in(g=S.event&&v.global)&&0==S.active++&&S.event.trigger(\"ajaxStart\"),v.type=v.type.toUpperCase(),v.hasContent=!Lt.test(v.type),f=v.url.replace(jt,\"\"),v.hasContent?v.data&&v.processData&&0===(v.contentType||\"\").indexOf(\"application/x-www-form-urlencoded\")&&(v.data=v.data.replace(Nt,\"+\")):(o=v.url.slice(f.length),v.data&&(v.processData||\"string\"==typeof v.data)&&(f+=(Tt.test(f)?\"&\":\"?\")+v.data,delete v.data),!1===v.cache&&(f=f.replace(Dt,\"$1\"),o=(Tt.test(f)?\"&\":\"?\")+\"_=\"+wt.guid+++o),v.url=f+o),v.ifModified&&(S.lastModified[f]&&T.setRequestHeader(\"If-Modified-Since\",S.lastModified[f]),S.etag[f]&&T.setRequestHeader(\"If-None-Match\",S.etag[f])),(v.data&&v.hasContent&&!1!==v.contentType||t.contentType)&&T.setRequestHeader(\"Content-Type\",v.contentType),T.setRequestHeader(\"Accept\",v.dataTypes[0]&&v.accepts[v.dataTypes[0]]?v.accepts[v.dataTypes[0]]+(\"*\"!==v.dataTypes[0]?\", \"+Rt+\"; q=0.01\":\"\"):v.accepts[\"*\"]),v.headers)T.setRequestHeader(i,v.headers[i]);if(v.beforeSend&&(!1===v.beforeSend.call(y,T,v)||h))return T.abort();if(u=\"abort\",b.add(v.complete),T.done(v.success),T.fail(v.error),c=Wt(Pt,v,t,T)){if(T.readyState=1,g&&m.trigger(\"ajaxSend\",[T,v]),h)return T;v.async&&0<v.timeout&&(d=C.setTimeout(function(){T.abort(\"timeout\")},v.timeout));try{h=!1,c.send(a,l)}catch(e){if(h)throw e;l(-1,e)}}else l(-1,\"No Transport\");function l(e,t,n,r){var i,o,a,s,u,l=t;h||(h=!0,d&&C.clearTimeout(d),c=void 0,p=r||\"\",T.readyState=0<e?4:0,i=200<=e&&e<300||304===e,n&&(s=function(e,t,n){var r,i,o,a,s=e.contents,u=e.dataTypes;while(\"*\"===u[0])u.shift(),void 0===r&&(r=e.mimeType||t.getResponseHeader(\"Content-Type\"));if(r)for(i in s)if(s[i]&&s[i].test(r)){u.unshift(i);break}if(u[0]in n)o=u[0];else{for(i in n){if(!u[0]||e.converters[i+\" \"+u[0]]){o=i;break}a||(a=i)}o=o||a}if(o)return o!==u[0]&&u.unshift(o),n[o]}(v,T,n)),!i&&-1<S.inArray(\"script\",v.dataTypes)&&S.inArray(\"json\",v.dataTypes)<0&&(v.converters[\"text script\"]=function(){}),s=function(e,t,n,r){var i,o,a,s,u,l={},c=e.dataTypes.slice();if(c[1])for(a in e.converters)l[a.toLowerCase()]=e.converters[a];o=c.shift();while(o)if(e.responseFields[o]&&(n[e.responseFields[o]]=t),!u&&r&&e.dataFilter&&(t=e.dataFilter(t,e.dataType)),u=o,o=c.shift())if(\"*\"===o)o=u;else if(\"*\"!==u&&u!==o){if(!(a=l[u+\" \"+o]||l[\"* \"+o]))for(i in l)if((s=i.split(\" \"))[1]===o&&(a=l[u+\" \"+s[0]]||l[\"* \"+s[0]])){!0===a?a=l[i]:!0!==l[i]&&(o=s[0],c.unshift(s[1]));break}if(!0!==a)if(a&&e[\"throws\"])t=a(t);else try{t=a(t)}catch(e){return{state:\"parsererror\",error:a?e:\"No conversion from \"+u+\" to \"+o}}}return{state:\"success\",data:t}}(v,s,T,i),i?(v.ifModified&&((u=T.getResponseHeader(\"Last-Modified\"))&&(S.lastModified[f]=u),(u=T.getResponseHeader(\"etag\"))&&(S.etag[f]=u)),204===e||\"HEAD\"===v.type?l=\"nocontent\":304===e?l=\"notmodified\":(l=s.state,o=s.data,i=!(a=s.error))):(a=l,!e&&l||(l=\"error\",e<0&&(e=0))),T.status=e,T.statusText=(t||l)+\"\",i?x.resolveWith(y,[o,l,T]):x.rejectWith(y,[T,l,a]),T.statusCode(w),w=void 0,g&&m.trigger(i?\"ajaxSuccess\":\"ajaxError\",[T,v,i?o:a]),b.fireWith(y,[T,l]),g&&(m.trigger(\"ajaxComplete\",[T,v]),--S.active||S.event.trigger(\"ajaxStop\")))}return T},getJSON:function(e,t,n){return S.get(e,t,n,\"json\")},getScript:function(e,t){return S.get(e,void 0,t,\"script\")}}),S.each([\"get\",\"post\"],function(e,i){S[i]=function(e,t,n,r){return m(t)&&(r=r||n,n=t,t=void 0),S.ajax(S.extend({url:e,type:i,dataType:r,data:t,success:n},S.isPlainObject(e)&&e))}}),S.ajaxPrefilter(function(e){var t;for(t in e.headers)\"content-type\"===t.toLowerCase()&&(e.contentType=e.headers[t]||\"\")}),S._evalUrl=function(e,t,n){return S.ajax({url:e,type:\"GET\",dataType:\"script\",cache:!0,async:!1,global:!1,converters:{\"text script\":function(){}},dataFilter:function(e){S.globalEval(e,t,n)}})},S.fn.extend({wrapAll:function(e){var t;return this[0]&&(m(e)&&(e=e.call(this[0])),t=S(e,this[0].ownerDocument).eq(0).clone(!0),this[0].parentNode&&t.insertBefore(this[0]),t.map(function(){var e=this;while(e.firstElementChild)e=e.firstElementChild;return e}).append(this)),this},wrapInner:function(n){return m(n)?this.each(function(e){S(this).wrapInner(n.call(this,e))}):this.each(function(){var e=S(this),t=e.contents();t.length?t.wrapAll(n):e.append(n)})},wrap:function(t){var n=m(t);return this.each(function(e){S(this).wrapAll(n?t.call(this,e):t)})},unwrap:function(e){return this.parent(e).not(\"body\").each(function(){S(this).replaceWith(this.childNodes)}),this}}),S.expr.pseudos.hidden=function(e){return!S.expr.pseudos.visible(e)},S.expr.pseudos.visible=function(e){return!!(e.offsetWidth||e.offsetHeight||e.getClientRects().length)},S.ajaxSettings.xhr=function(){try{return new C.XMLHttpRequest}catch(e){}};var Bt={0:200,1223:204},$t=S.ajaxSettings.xhr();y.cors=!!$t&&\"withCredentials\"in $t,y.ajax=$t=!!$t,S.ajaxTransport(function(i){var o,a;if(y.cors||$t&&!i.crossDomain)return{send:function(e,t){var n,r=i.xhr();if(r.open(i.type,i.url,i.async,i.username,i.password),i.xhrFields)for(n in i.xhrFields)r[n]=i.xhrFields[n];for(n in i.mimeType&&r.overrideMimeType&&r.overrideMimeType(i.mimeType),i.crossDomain||e[\"X-Requested-With\"]||(e[\"X-Requested-With\"]=\"XMLHttpRequest\"),e)r.setRequestHeader(n,e[n]);o=function(e){return function(){o&&(o=a=r.onload=r.onerror=r.onabort=r.ontimeout=r.onreadystatechange=null,\"abort\"===e?r.abort():\"error\"===e?\"number\"!=typeof r.status?t(0,\"error\"):t(r.status,r.statusText):t(Bt[r.status]||r.status,r.statusText,\"text\"!==(r.responseType||\"text\")||\"string\"!=typeof r.responseText?{binary:r.response}:{text:r.responseText},r.getAllResponseHeaders()))}},r.onload=o(),a=r.onerror=r.ontimeout=o(\"error\"),void 0!==r.onabort?r.onabort=a:r.onreadystatechange=function(){4===r.readyState&&C.setTimeout(function(){o&&a()})},o=o(\"abort\");try{r.send(i.hasContent&&i.data||null)}catch(e){if(o)throw e}},abort:function(){o&&o()}}}),S.ajaxPrefilter(function(e){e.crossDomain&&(e.contents.script=!1)}),S.ajaxSetup({accepts:{script:\"text/javascript, application/javascript, application/ecmascript, application/x-ecmascript\"},contents:{script:/\\b(?:java|ecma)script\\b/},converters:{\"text script\":function(e){return S.globalEval(e),e}}}),S.ajaxPrefilter(\"script\",function(e){void 0===e.cache&&(e.cache=!1),e.crossDomain&&(e.type=\"GET\")}),S.ajaxTransport(\"script\",function(n){var r,i;if(n.crossDomain||n.scriptAttrs)return{send:function(e,t){r=S(\"<script>\").attr(n.scriptAttrs||{}).prop({charset:n.scriptCharset,src:n.url}).on(\"load error\",i=function(e){r.remove(),i=null,e&&t(\"error\"===e.type?404:200,e.type)}),E.head.appendChild(r[0])},abort:function(){i&&i()}}});var _t,zt=[],Ut=/(=)\\?(?=&|$)|\\?\\?/;S.ajaxSetup({jsonp:\"callback\",jsonpCallback:function(){var e=zt.pop()||S.expando+\"_\"+wt.guid++;return this[e]=!0,e}}),S.ajaxPrefilter(\"json jsonp\",function(e,t,n){var r,i,o,a=!1!==e.jsonp&&(Ut.test(e.url)?\"url\":\"string\"==typeof e.data&&0===(e.contentType||\"\").indexOf(\"application/x-www-form-urlencoded\")&&Ut.test(e.data)&&\"data\");if(a||\"jsonp\"===e.dataTypes[0])return r=e.jsonpCallback=m(e.jsonpCallback)?e.jsonpCallback():e.jsonpCallback,a?e[a]=e[a].replace(Ut,\"$1\"+r):!1!==e.jsonp&&(e.url+=(Tt.test(e.url)?\"&\":\"?\")+e.jsonp+\"=\"+r),e.converters[\"script json\"]=function(){return o||S.error(r+\" was not called\"),o[0]},e.dataTypes[0]=\"json\",i=C[r],C[r]=function(){o=arguments},n.always(function(){void 0===i?S(C).removeProp(r):C[r]=i,e[r]&&(e.jsonpCallback=t.jsonpCallback,zt.push(r)),o&&m(i)&&i(o[0]),o=i=void 0}),\"script\"}),y.createHTMLDocument=((_t=E.implementation.createHTMLDocument(\"\").body).innerHTML=\"<form></form><form></form>\",2===_t.childNodes.length),S.parseHTML=function(e,t,n){return\"string\"!=typeof e?[]:(\"boolean\"==typeof t&&(n=t,t=!1),t||(y.createHTMLDocument?((r=(t=E.implementation.createHTMLDocument(\"\")).createElement(\"base\")).href=E.location.href,t.head.appendChild(r)):t=E),o=!n&&[],(i=N.exec(e))?[t.createElement(i[1])]:(i=xe([e],t,o),o&&o.length&&S(o).remove(),S.merge([],i.childNodes)));var r,i,o},S.fn.load=function(e,t,n){var r,i,o,a=this,s=e.indexOf(\" \");return-1<s&&(r=ht(e.slice(s)),e=e.slice(0,s)),m(t)?(n=t,t=void 0):t&&\"object\"==typeof t&&(i=\"POST\"),0<a.length&&S.ajax({url:e,type:i||\"GET\",dataType:\"html\",data:t}).done(function(e){o=arguments,a.html(r?S(\"<div>\").append(S.parseHTML(e)).find(r):e)}).always(n&&function(e,t){a.each(function(){n.apply(this,o||[e.responseText,t,e])})}),this},S.expr.pseudos.animated=function(t){return S.grep(S.timers,function(e){return t===e.elem}).length},S.offset={setOffset:function(e,t,n){var r,i,o,a,s,u,l=S.css(e,\"position\"),c=S(e),f={};\"static\"===l&&(e.style.position=\"relative\"),s=c.offset(),o=S.css(e,\"top\"),u=S.css(e,\"left\"),(\"absolute\"===l||\"fixed\"===l)&&-1<(o+u).indexOf(\"auto\")?(a=(r=c.position()).top,i=r.left):(a=parseFloat(o)||0,i=parseFloat(u)||0),m(t)&&(t=t.call(e,n,S.extend({},s))),null!=t.top&&(f.top=t.top-s.top+a),null!=t.left&&(f.left=t.left-s.left+i),\"using\"in t?t.using.call(e,f):c.css(f)}},S.fn.extend({offset:function(t){if(arguments.length)return void 0===t?this:this.each(function(e){S.offset.setOffset(this,t,e)});var e,n,r=this[0];return r?r.getClientRects().length?(e=r.getBoundingClientRect(),n=r.ownerDocument.defaultView,{top:e.top+n.pageYOffset,left:e.left+n.pageXOffset}):{top:0,left:0}:void 0},position:function(){if(this[0]){var e,t,n,r=this[0],i={top:0,left:0};if(\"fixed\"===S.css(r,\"position\"))t=r.getBoundingClientRect();else{t=this.offset(),n=r.ownerDocument,e=r.offsetParent||n.documentElement;while(e&&(e===n.body||e===n.documentElement)&&\"static\"===S.css(e,\"position\"))e=e.parentNode;e&&e!==r&&1===e.nodeType&&((i=S(e).offset()).top+=S.css(e,\"borderTopWidth\",!0),i.left+=S.css(e,\"borderLeftWidth\",!0))}return{top:t.top-i.top-S.css(r,\"marginTop\",!0),left:t.left-i.left-S.css(r,\"marginLeft\",!0)}}},offsetParent:function(){return this.map(function(){var e=this.offsetParent;while(e&&\"static\"===S.css(e,\"position\"))e=e.offsetParent;return e||re})}}),S.each({scrollLeft:\"pageXOffset\",scrollTop:\"pageYOffset\"},function(t,i){var o=\"pageYOffset\"===i;S.fn[t]=function(e){return $(this,function(e,t,n){var r;if(x(e)?r=e:9===e.nodeType&&(r=e.defaultView),void 0===n)return r?r[i]:e[t];r?r.scrollTo(o?r.pageXOffset:n,o?n:r.pageYOffset):e[t]=n},t,e,arguments.length)}}),S.each([\"top\",\"left\"],function(e,n){S.cssHooks[n]=Fe(y.pixelPosition,function(e,t){if(t)return t=We(e,n),Pe.test(t)?S(e).position()[n]+\"px\":t})}),S.each({Height:\"height\",Width:\"width\"},function(a,s){S.each({padding:\"inner\"+a,content:s,\"\":\"outer\"+a},function(r,o){S.fn[o]=function(e,t){var n=arguments.length&&(r||\"boolean\"!=typeof e),i=r||(!0===e||!0===t?\"margin\":\"border\");return $(this,function(e,t,n){var r;return x(e)?0===o.indexOf(\"outer\")?e[\"inner\"+a]:e.document.documentElement[\"client\"+a]:9===e.nodeType?(r=e.documentElement,Math.max(e.body[\"scroll\"+a],r[\"scroll\"+a],e.body[\"offset\"+a],r[\"offset\"+a],r[\"client\"+a])):void 0===n?S.css(e,t,i):S.style(e,t,n,i)},s,n?e:void 0,n)}})}),S.each([\"ajaxStart\",\"ajaxStop\",\"ajaxComplete\",\"ajaxError\",\"ajaxSuccess\",\"ajaxSend\"],function(e,t){S.fn[t]=function(e){return this.on(t,e)}}),S.fn.extend({bind:function(e,t,n){return this.on(e,null,t,n)},unbind:function(e,t){return this.off(e,null,t)},delegate:function(e,t,n,r){return this.on(t,e,n,r)},undelegate:function(e,t,n){return 1===arguments.length?this.off(e,\"**\"):this.off(t,e||\"**\",n)},hover:function(e,t){return this.mouseenter(e).mouseleave(t||e)}}),S.each(\"blur focus focusin focusout resize scroll click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup contextmenu\".split(\" \"),function(e,n){S.fn[n]=function(e,t){return 0<arguments.length?this.on(n,null,e,t):this.trigger(n)}});var Xt=/^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g;S.proxy=function(e,t){var n,r,i;if(\"string\"==typeof t&&(n=e[t],t=e,e=n),m(e))return r=s.call(arguments,2),(i=function(){return e.apply(t||this,r.concat(s.call(arguments)))}).guid=e.guid=e.guid||S.guid++,i},S.holdReady=function(e){e?S.readyWait++:S.ready(!0)},S.isArray=Array.isArray,S.parseJSON=JSON.parse,S.nodeName=A,S.isFunction=m,S.isWindow=x,S.camelCase=X,S.type=w,S.now=Date.now,S.isNumeric=function(e){var t=S.type(e);return(\"number\"===t||\"string\"===t)&&!isNaN(e-parseFloat(e))},S.trim=function(e){return null==e?\"\":(e+\"\").replace(Xt,\"\")},\"function\"==typeof define&&define.amd&&define(\"jquery\",[],function(){return S});var Vt=C.jQuery,Gt=C.$;return S.noConflict=function(e){return C.$===S&&(C.$=Gt),e&&C.jQuery===S&&(C.jQuery=Vt),S},\"undefined\"==typeof e&&(C.jQuery=C.$=S),S});\n"},{"url":"/js/universe.js","content":"// 主页星星和流星效果\nfunction dark() {window.requestAnimationFrame=window.requestAnimationFrame||window.mozRequestAnimationFrame||window.webkitRequestAnimationFrame||window.msRequestAnimationFrame;var n,e,i,h,t=.05,s=document.getElementById(\"universe\"),o=!0,a=\"180,184,240\",r=\"226,225,142\",d=\"226,225,224\",c=[];function f(){n=window.innerWidth,e=window.innerHeight,i=.216*n,s.setAttribute(\"width\",n),s.setAttribute(\"height\",e)}function u(){h.clearRect(0,0,n,e);for(var t=c.length,i=0;i<t;i++){var s=c[i];s.move(),s.fadeIn(),s.fadeOut(),s.draw()}}function y(){this.reset=function(){this.giant=m(3),this.comet=!this.giant&&!o&&m(10),this.x=l(0,n-10),this.y=l(0,e),this.r=l(1.1,2.6),this.dx=l(t,6*t)+(this.comet+1-1)*t*l(50,120)+2*t,this.dy=-l(t,6*t)-(this.comet+1-1)*t*l(50,120),this.fadingOut=null,this.fadingIn=!0,this.opacity=0,this.opacityTresh=l(.2,1-.4*(this.comet+1-1)),this.do=l(5e-4,.002)+.001*(this.comet+1-1)},this.fadeIn=function(){this.fadingIn&&(this.fadingIn=!(this.opacity>this.opacityTresh),this.opacity+=this.do)},this.fadeOut=function(){this.fadingOut&&(this.fadingOut=!(this.opacity<0),this.opacity-=this.do/2,(this.x>n||this.y<0)&&(this.fadingOut=!1,this.reset()))},this.draw=function(){if(h.beginPath(),this.giant)h.fillStyle=\"rgba(\"+a+\",\"+this.opacity+\")\",h.arc(this.x,this.y,2,0,2*Math.PI,!1);else if(this.comet){h.fillStyle=\"rgba(\"+d+\",\"+this.opacity+\")\",h.arc(this.x,this.y,1.5,0,2*Math.PI,!1);for(var t=0;t<30;t++)h.fillStyle=\"rgba(\"+d+\",\"+(this.opacity-this.opacity/20*t)+\")\",h.rect(this.x-this.dx/4*t,this.y-this.dy/4*t-2,2,2),h.fill()}else h.fillStyle=\"rgba(\"+r+\",\"+this.opacity+\")\",h.rect(this.x,this.y,this.r,this.r);h.closePath(),h.fill()},this.move=function(){this.x+=this.dx,this.y+=this.dy,!1===this.fadingOut&&this.reset(),(this.x>n-n/4||this.y<0)&&(this.fadingOut=!0)},setTimeout(function(){o=!1},50)}function m(t){return Math.floor(1e3*Math.random())+1<10*t}function l(t,i){return Math.random()*(i-t)+t}f(),window.addEventListener(\"resize\",f,!1),function(){h=s.getContext(\"2d\");for(var t=0;t<i;t++)c[t]=new y,c[t].reset();u()}(),function t(){document.getElementsByTagName('html')[0].getAttribute('data-theme')=='dark'&&u(),window.requestAnimationFrame(t)}()};\ndark()"},{"url":"/css/runtime.css","content":"/* 页脚css配置 */\n\n#workboard{\n    font-size:13px;\n    font-weight:700;\n}\n\n#footer-wrap {\n    padding-bottom: 15px !important;\n}\n#heartbeat {\n    color: red;\n    animation: iconAnimate 1s ease-in-out infinite;\n}\n@-moz-keyframes iconAnimate {\n    0%,100% {\n        transform: scale(1)\n    }\n\n    10%,30% {\n        transform: scale(.9)\n    }\n\n    20%,40%,60%,80% {\n        transform: scale(1.1)\n    }\n\n    50%,70% {\n        transform: scale(1.1)\n    }\n}\n\n@-webkit-keyframes iconAnimate {\n    0%,100% {\n        transform: scale(1)\n    }\n\n    10%,30% {\n        transform: scale(.9)\n    }\n\n    20%,40%,60%,80% {\n        transform: scale(1.1)\n    }\n\n    50%,70% {\n        transform: scale(1.1)\n    }\n}\n\n@-o-keyframes iconAnimate {\n    0%,100% {\n        transform: scale(1)\n    }\n\n    10%,30% {\n        transform: scale(.9)\n    }\n\n    20%,40%,60%,80% {\n        transform: scale(1.1)\n    }\n\n    50%,70% {\n        transform: scale(1.1)\n    }\n}\n\n@keyframes iconAnimate {\n    0%,100% {\n        transform: scale(1)\n    }\n\n    10%,30% {\n        transform: scale(.9)\n    }\n\n    20%,40%,60%,80% {\n        transform: scale(1.1)\n    }\n\n    50%,70% {\n        transform: scale(1.1)\n    }\n}"},{"url":"/css/custom.css","content":":root {\n  --trans-light: rgba(255, 255, 255, 0.95);\n  --trans-dark: rgba(25, 25, 25, 0.92);\n  --border-style: 1px solid rgb(169, 169, 169);\n  --backdrop-filter: blur(5px) saturate(150%);\n}\n\n/* 字体引入 */\n/* 字体引入 */\n@font-face {\n  font-family: YSHST;\n  src: url(/font/优设好身体.woff2);\n  font-display: swap;\n}\n\n@font-face {\n  font-family: MiSans;\n  src: url(/font/MiSans.woff2);\n  font-display: swap;\n}\n\n@font-face {\n  font-family: HYTMR;\n  src: url(/font/HYTangMeiRen55W.woff2);\n  font-display: swap;\n}\n\n@font-face {\n  font-family: 'LXGW';\n  src: url(/font/霞鹜文楷.woff2);\n  font-display: block;\n}\n\n\n@font-face {\n  font-family: Consolas_1;\n  src: url(/font/Consolas.woff2);\n  font-display: swap;\n}\n\n@font-face {\n  font-family: ZhuZiAWan;\n  src: url(/font/ZhuZiAWan2.woff2);\n  font-display: swap;\n}\n\n/* 页脚与头图透明 */\n#footer {\n    background: rgba(0, 0, 0, .3) !important;\n}\n\n#page-header {\n    background: transparent !important;\n}\n\n/* 白天模式遮罩透明 */\n/* #footer::before {\n    background: transparent !important;\n} */\n\n#page-header::before {\n    background: rgba(0, 0, 0, .2) !important;\n}\n\n/* 夜间模式遮罩透明 */\n/* [data-theme=\"dark\"] #footer::before {\n    background: transparent !important;\n} */\n\n[data-theme=\"dark\"] #page-header::before {\n    background: transparent !important;\n}\n\n/* 小冰分类分类磁铁黑夜模式适配 */\n/* 一般状态 */\n[data-theme=\"dark\"] .magnet_link_context {\n    background: #1e1e1e;\n    color: antiquewhite;\n}\n\n/* 鼠标悬浮状态 */\n[data-theme=\"dark\"] .magnet_link_context:hover {\n    background: #3ecdf1;\n    color: #f2f2f2;\n}\n\n@media screen and (min-width: 600px) {\n    .blog-slider {\n        height: 260px !important\n    }\n\n    .blog-slider__img {\n        width: 36% !important;\n        height: 100% !important\n    }\n}\n\n/* 主页边框弧度 */\n#aside-content .card-widget {\n    border-radius: 18px !important;\n}\n\n#recent-posts>.recent-post-item {\n    border-radius: 25px !important;\n}\n\n#catalog_magnet {\n    padding: 18px 18px 0 18px !important;\n}\n\n/* 夜间模式轮播文章图片遮罩 */\n[data-theme='dark'] img {\n    filter: blur(0) brightness(0.8) !important;\n  }\n\n/* 夜间模式背景切换 */\n[data-theme='dark'] #web_bg {\n    background-image: url(/assets/bg/bg_6.webp) !important;\n    background-size: 100% 100%;\n    background-size: cover;\n    background-repeat: no-repeat center;\n}\n  \n\n/* 黑夜霓虹灯效果 */\n/* 日间模式不生效 */\n[data-theme=\"light\"] #site-name,\n[data-theme=\"light\"] #site-title,\n[data-theme=\"light\"] #site-subtitle,\n[data-theme=\"light\"] #post-info {\n  animation: none;\n}\n/* 夜间模式生效 */\n[data-theme=\"dark\"] .site-name,\n[data-theme=\"dark\"] #site-title {\n  animation: light_15px 10s linear infinite;\n}\n[data-theme=\"dark\"] #site-subtitle {\n  animation: light_10px 10s linear infinite;\n}\n\n/* 关键帧描述 */\n@keyframes light_15px {\n  0% {\n    text-shadow: #5636ed 0 0 15px;\n  }\n  12.5% {\n    text-shadow: #11ee5e 0 0 15px;\n  }\n  25% {\n    text-shadow: #f14747 0 0 15px;\n  }\n  37.5% {\n    text-shadow: #f1a247 0 0 15px;\n  }\n  50% {\n    text-shadow: #f1ee47 0 0 15px;\n  }\n  50% {\n    text-shadow: #b347f1 0 0 15px;\n  }\n  62.5% {\n    text-shadow: #002afa 0 0 15px;\n  }\n  75% {\n    text-shadow: #ed709b 0 0 15px;\n  }\n  87.5% {\n    text-shadow: #39c5bb 0 0 15px;\n  }\n  100% {\n    text-shadow: #5636ed 0 0 15px;\n  }\n}\n\n@keyframes light_10px {\n  0% {\n    text-shadow: #5636ed 0 0 10px;\n  }\n  12.5% {\n    text-shadow: #11ee5e 0 0 10px;\n  }\n  25% {\n    text-shadow: #f14747 0 0 10px;\n  }\n  37.5% {\n    text-shadow: #f1a247 0 0 10px;\n  }\n  50% {\n    text-shadow: #f1ee47 0 0 10px;\n  }\n  50% {\n    text-shadow: #b347f1 0 0 10px;\n  }\n  62.5% {\n    text-shadow: #002afa 0 0 10px;\n  }\n  75% {\n    text-shadow: #ed709b 0 0 10px;\n  }\n  87.5% {\n    text-shadow: #39c5bb 0 0 10px;\n  }\n  100% {\n    text-shadow: #5636ed 0 0 10px;\n  }\n}\n\n\n/* 主页星星和流行效果 */\n/* 背景宇宙星光  */\n#universe{\n    display: block;\n    position: fixed;\n    margin: 0;\n    padding: 0;\n    border: 0;\n    outline: 0;\n    left: 0;\n    top: 0;\n    width: 100%;\n    height: 100%;\n    pointer-events: none;\n    /* 这个是调置顶的优先级的，-1在文章页下面，背景上面，个人推荐这种 */\n    z-index: -1;\n  }\n\n\n /* 个人卡片渐变 */\n/* 侧边栏个人信息卡片动态渐变色 */\n#aside-content > .card-widget.card-info {\n    background: linear-gradient(\n      -45deg,\n      #e8d8b9,\n      #eccec5,\n      #a3e9eb,\n      #bdbdf0,\n      #eec1ea\n    );\n    /* box-shadow: 0 0 5px rgb(66, 68, 68); */\n    position: relative;\n    background-size: 400% 400%;\n    -webkit-animation: Gradient 10s ease infinite;\n    -moz-animation: Gradient 10s ease infinite;\n    animation: Gradient 10s ease infinite !important;\n  }\n  @-webkit-keyframes Gradient {\n    0% {\n      background-position: 0% 50%;\n    }\n    50% {\n      background-position: 100% 50%;\n    }\n    100% {\n      background-position: 0% 50%;\n    }\n  }\n  @-moz-keyframes Gradient {\n    0% {\n      background-position: 0% 50%;\n    }\n    50% {\n      background-position: 100% 50%;\n    }\n    100% {\n      background-position: 0% 50%;\n    }\n  }\n  @keyframes Gradient {\n    0% {\n      background-position: 0% 50%;\n    }\n    50% {\n      background-position: 100% 50%;\n    }\n    100% {\n      background-position: 0% 50%;\n    }\n  }\n  \n  /* 黑夜模式适配 */\n  [data-theme=\"dark\"] #aside-content > .card-widget.card-info {\n    background: #191919ee;\n  }\n  \n  /* 个人信息Follow me按钮 */\n  #aside-content > .card-widget.card-info > #card-info-btn {\n    background-color: #3eb8be;\n    border-radius: 8px;\n  }\n\n\n/* 鼠标样式 */\n#cursor {\n    position: fixed;\n    width: 16px;\n    height: 16px;\n    /* 这里改变跟随的底色 */\n    background: rgb(57, 197, 187);\n    border-radius: 8px;\n    opacity: 0.25;\n    z-index: 10086;\n    pointer-events: none;\n    transition: 0.2s ease-in-out;\n    transition-property: background, opacity, transform;\n  }\n  \n  #cursor.hidden {\n    opacity: 0;\n  }\n  \n  #cursor.hover {\n    opacity: 0.1;\n    transform: scale(2.5);\n    -webkit-transform: scale(2.5);\n    -moz-transform: scale(2.5);\n    -ms-transform: scale(2.5);\n    -o-transform: scale(2.5);\n  }\n  \n  #cursor.active {\n    opacity: 0.5;\n    transform: scale(0.5);\n    -webkit-transform: scale(0.5);\n    -moz-transform: scale(0.5);\n    -ms-transform: scale(0.5);\n    -o-transform: scale(0.5);\n  }\n\n\n/* 页面样式细节 */\n\n\n/* 首页文章卡片 */\n#recent-posts > .recent-post-item {\n  background: var(--trans-light);\n  backdrop-filter: var(--backdrop-filter);\n  border-radius: 25px;\n  border: var(--border-style);\n}\n\n/* 首页侧栏卡片 */\n#aside-content .card-widget {\n  background: var(--trans-light);\n  backdrop-filter: var(--backdrop-filter);\n  border-radius: 18px;\n  border: var(--border-style);\n}\n\n/* 文章页、归档页、普通页面 */\ndiv#post,\ndiv#page,\ndiv#archive {\n  background: var(--trans-light);\n  backdrop-filter: var(--backdrop-filter);\n  border: var(--border-style);\n  border-radius: 20px;\n}\n\n/* 导航栏 */\n#page-header.nav-fixed #nav {\n  background: rgba(255, 255, 255, 0.75);\n  backdrop-filter: var(--backdrop-filter);\n}\n\n[data-theme=\"dark\"] #page-header.nav-fixed #nav {\n  background: rgba(0, 0, 0, 0.7) !important;\n}\n\n/* 夜间模式遮罩 */\n[data-theme=\"dark\"] #recent-posts > .recent-post-item,\n[data-theme=\"dark\"] #aside-content .card-widget,\n[data-theme=\"dark\"] div#post,\n[data-theme=\"dark\"] div#archive,\n[data-theme=\"dark\"] div#page {\n  background: var(--trans-dark);\n}\n\n\n/* 夜间模式页脚页头遮罩透明 */\n[data-theme=\"dark\"] #footer::before {\n  background: transparent !important;\n}\n[data-theme=\"dark\"] #page-header::before {\n  background: transparent !important;\n}\n\n/* 阅读模式 */\n.read-mode #aside-content .card-widget {\n  background: rgba(158, 204, 171, 0.5) !important;\n}\n.read-mode div#post {\n  background: rgba(158, 204, 171, 0.5) !important;\n}\n\n/* 夜间模式下的阅读模式 */\n[data-theme=\"dark\"] .read-mode #aside-content .card-widget {\n  background: rgba(25, 25, 25, 0.9) !important;\n  color: #ffffff;\n}\n[data-theme=\"dark\"] .read-mode div#post {\n  background: rgba(25, 25, 25, 0.9) !important;\n  color: #ffffff;\n}\n\n\n/* b站视频适配 */\n/*哔哩哔哩视频适配*/\n.aspect-ratio {\n  position: relative;\n  width: 90%;\n  height: auto;\n  padding-bottom: 75%;\n  margin: 3% auto;\n  text-align: center;\n}\n.aspect-ratio iframe {\n  position: absolute;\n  width: 100%;\n  height: 86%;\n  left: 0;\n  top: 0;\n}\n\n/* 挂绳猫咪 */\n\nbody::-webkit-scrollbar {\n  width: 0;\n}\n\n.neko {\n  width: 64px;\n  height: 64px;\n  background-image: url(\"https://bu.dusays.com/2022/07/20/62d812db74be9.png\");\n  position: absolute;\n  right: 32px;\n  background-repeat: no-repeat;\n  background-size: contain;\n  transform: translateX(50%);\n  cursor: pointer;\n  font-family: tzy;\n  font-weight: 600;\n  font-size: 16px;\n  color: #6f42c1;\n  display: none;\n}\n\n.neko::after {\n  display: none;\n  width: 100px;\n  height: 100px;\n  background-image: url(\"https://bu.dusays.com/2022/07/20/62d812d95e6f5.png\");\n  background-size: contain;\n  z-index: 9999;\n  position: absolute;\n  right: 50%;\n  text-align: center;\n  line-height: 100px;\n  top: -115%;\n\n}\n\n.neko.showMsg::after {\n  content: attr(data-msg);\n  display: block;\n  overflow: hidden;\n  text-overflow: ellipsis;\n}\n\n.neko:hover::after {\n  content: attr(data-msg);\n  display: block;\n  overflow: hidden;\n  text-overflow: ellipsis;\n}\n\n.neko.fontColor::after {\n  color: #333;\n}\n\n/**\n* @description: 滚动条样式  跟猫二选一\n*/\n@media screen and (max-width:992px) {\n  ::-webkit-scrollbar {\n      width: 8px !important;\n      height: 8px !important\n  }\n\n  ::-webkit-scrollbar-track {\n      border-radius: 2em;\n  }\n\n  ::-webkit-scrollbar-thumb {\n      background-color: rgb(255 255 255 / .3);\n      background-image: -webkit-linear-gradient(45deg, rgba(255, 255, 255, 0.1) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, 0.1) 50%, rgba(255, 255, 255, 0.1) 75%, transparent 75%, transparent);\n      border-radius: 2em\n  }\n\n  ::-webkit-scrollbar-corner {\n      background-color: transparent\n  }\n}\n\n/* 导航栏图标大小 */\nsvg.icon {\n  width: 1.28em;\n  height: 1.28em;\n  vertical-align: -0.2em;\n  fill: currentColor;\n  overflow: hidden;\n}\n\n\n/* 个人卡片图标大小 */\n.social_icon {\n  width: 1.28em;\n  height: 1.28em;\n  vertical-align: -0.5em;\n  fill: currentColor;\n  overflow: hidden;\n}\n\n\n/* 导航栏居中 */\n/* 一级菜单居中 */\n#nav .menus_items {\n  position: absolute !important;\n  width: fit-content !important;\n  left: 50% !important;\n  transform: translateX(-50%) !important;\n}\n/* 子菜单横向展示 */\n#nav .menus_items .menus_item:hover .menus_item_child {\n  display: flex !important;\n}\n/* 这里的2是代表导航栏的第2个元素，即有子菜单的元素，可以按自己需求修改 */\n.menus_items .menus_item:nth-child(2) .menus_item_child {\n  left: -125px;\n}\n\n"},{"title":"友人帐","url":"/link/index.html"},{"title":"标签","url":"/tags/index.html"},{"title":"信息技术","url":"/liebiao/xinxi/index.html","content":"> 仅供平时学习，切勿作弊！！\n\n{% raw %}\n<style>\n    \n         #search-input {\n            width: 50%;\n            border: 3px solid #ccc;\n            border-radius: 10px;\n            padding: 5px;\n            outline: none;\n            margin-top: 10px;\n            margin-right: 20px;\n            height: 40px;\n            line-height: 40px;\n        }\n        \n        #xinxi-search-button {\n            display: inline-block;\n            width: 100px;\n            height: 50px;\n        }\n        [data-theme=\"dark\"] #xinxi-search-button {\n            color: var(--text-highlight-color);\n        }\n        \n        #search-results {\n            margin-top: 10px;\n            \n        }\n        \n        .search-container {\n            margin-top: 20px;\n        }\n        .search-results-container {\n            margin-top: 20px;\n        }\n        .result {\n            margin-bottom: 10px;\n            background-color: #f2f2f2;\n            padding: 10px;\n            border-radius: 5px;\n        }\n        [data-theme=\"dark\"] .result {\n            background-color:#f2f2f212;\n        }\n        [data-theme=\"dark\"] #search-input {\n            background-color:#f2f2f212;\n            color:var(--text-highlight-color);\n        }\n        .title {\n            font-weight: bold;\n            margin-bottom: 5px;\n        }\n        .answer {\n            color:red;\n        }\n</style>\n{% endraw %}\n{% raw %}\n <h1 align=\"center\">Question Search</h1>\n<input type=\"text\" id=\"search-input\" placeholder=\"Enter search keyword\">\n<button id=\"xinxi-search-button\">Search</button>\n<div id=\"search-results\"></div>\n{% endraw %}\n{% raw %}\n<script>\n        var quizQuestions = [{\n        \"title\": \"在Word2010中，要使用“格式刷”命令按钮，应该先选择()选项卡。\",\n        \"answer\": \"开始\"\n    },\n    {\n        \"title\": \"将Word2010文档中一部分内容复制到别处，先要进行的操作是()。\",\n        \"answer\": \"选择\"\n    },\n    {\n        \"title\": \"一组连接计算机各部件的公共通信线称为总线，它的组成是()。\",\n        \"answer\": \"地址线、数据线和控制线\"\n    },\n    {\n        \"title\": \"Word2010编辑状态下，若设置了标尺，则水平标尺和垂直标尺同时显示的视图方式为()。\",\n        \"answer\": \"页面视图\"\n    },\n    {\n        \"title\": \"计算机自诞生以来，无论在性能、价格等方面都发生了巨大的变化，但是()并没有发生多大的改变。\",\n        \"answer\": \"基本工作原理\"\n    },\n    {\n        \"title\": \"在Word2010中，对某文档进行编辑，但是没有保存就直接执行“关闭”命令，则以下说法正确的是()。\",\n        \"answer\": \"系统会弹出提示对话框，询问用户后续操作\"\n    },\n    {\n        \"title\": \"在Excel2010的工作表中，当鼠标的形状变为()时，就可进行自动填充操作。\",\n        \"answer\": \"实心细十字\"\n    },\n    {\n        \"title\": \"Excel2010中，若要选中若干个不连续的单元格，可选按住()键，然后逐一用鼠标单击。\",\n        \"answer\": \"Ctrl\"\n    },\n    {\n        \"title\": \"微型计算机中内存储器比外存储器()。\",\n        \"answer\": \"读写速度快\"\n    },\n    {\n        \"title\": \"中国教育科研网全国网络中心设在()，负责全国主干网的运行管理\",\n        \"answer\": \"清华大学\"\n    },\n    {\n        \"title\": \"在Windows中，用户建立的文件默认具有的属性是（）\",\n        \"answer\": \"存档\"\n    },\n    {\n        \"title\": \"只知道服务器的IP地址，而没有该服务器的域名，则无法访问该服务器。()\",\n        \"answer\": \"错误\"\n    },\n    {\n        \"title\": \"()的目的是在使用最少的网络资源和具有最小延迟的前提下，确保网络能提供可靠、连接的通信能力，并使网络资源的使用达到最优化的程度。\",\n        \"answer\": \"性能管理\"\n    },\n    {\n        \"title\": \"E-mail地址中@的含义为()\",\n        \"answer\": \"在\"\n    },\n    {\n        \"title\": \"在PowerPoint2010演示文稿中利用“大纲”窗格组织、排列幻灯片中的文字时，输入幻灯片标题后进入下一级文本输入状态的最快捷方法是()。\",\n        \"answer\": \"按Ctrl+Enter组合键\"\n    },\n    {\n        \"title\": \"在Excel2010中，各运算符号的优先级的顺序为（）。\",\n        \"answer\": \"引用运算符、算术运算符、文本运算符、关系运算符\"\n    },\n    {\n        \"title\": \"下列说法正确的是()\",\n        \"answer\": \"上因特网的计算机必须拥用一个独立的IP地址\"\n    },\n    {\n        \"title\": \"在PowerPoint2010中，要同时选择第1、 2、5三张幻灯片，应该在()视图下操作。\",\n        \"answer\": \"幻灯片浏览\"\n    },\n    {\n        \"title\": \"URL的格式是()\",\n        \"answer\": \"协议：//IP地址或域名/路径/文件名\"\n    },\n    {\n        \"title\": \"Excel中时间和日期都可以()，并可以包含到其他运算当中。\",\n        \"answer\": \"相加、相减\"\n    },\n    {\n        \"title\": \"在计算机中指令主要存放在()中\",\n        \"answer\": \"存储器\"\n    },\n    {\n        \"title\": \"在Word2010中，有关“定时自动保存”功能的说法中，正确的是()。\",\n        \"answer\": \"系统每隔一段时间自动保存在外存中，以避免意外丢失文档内容\"\n    },\n    {\n        \"title\": \"在PowerPoint2010中，若使幻灯片播放时，从“盒状展开”效果变换到下一张幻灯片需要设置()。\",\n        \"answer\": \"幻灯片切换\"\n    },\n    {\n        \"title\": \"计算机中对下列几个部件访问速度最快的是()\",\n        \"answer\": \"主存储器\"\n    },\n    {\n        \"title\": \"电话拨号上网是利用现成的电话线路，通过()将计算机连入Internet。\",\n        \"answer\": \"Modem\"\n    },\n    {\n        \"title\": \"一个工作簿里最多可以包含有()张工作表。\",\n        \"answer\": \"255\"\n    },\n    {\n        \"title\": \"网卡的主要功能不包括 \",\n        \"answer\": \"网络互连\"\n    },\n    {\n        \"title\": \"在PowerPoint2010中，若要更换另一种幻灯片的版式，下列操作正确的是（）\",\n        \"answer\": \"单击“开始”选项卡→“幻灯片”组中“版式”命令按钮\"\n    },\n    {\n        \"title\": \"计算机中正在运行的程序和数据都是保存在计算机的()中。\",\n        \"answer\": \"内存\"\n    },\n    {\n        \"title\": \"在Excel2010中，数字的千位后加千分号“,”,例如230000可以记作()。\",\n        \"answer\": \"230，000\"\n    },\n    {\n        \"title\": \"在Excel2010的数据操作中，计算求和的函数是()\",\n        \"answer\": \"SUM\"\n    },\n    {\n        \"title\": \"下列视图中不属于PowerPoint2010视图的是()。\",\n        \"answer\": \"页面视图\"\n    },\n    {\n        \"title\": \"关于Word编辑页眉页脚，下列叙述()不正确。\",\n        \"answer\": \"文档内容和页眉页脚可在同一窗口编辑\"\n    },\n    {\n        \"title\": \"计算机之所以能按人们的意图自动进行工作，最直接的原因是采用了()。\",\n        \"answer\": \"存储程序控制\"\n    },\n    {\n        \"title\": \"显示或打印汉字时，系统使用的是汉字的()。\",\n        \"answer\": \"字形码\"\n    },\n    {\n        \"title\": \"计算机中用来保存程序和数据，以及运算的中间结果和最后结果的装置是()\",\n        \"answer\": \"内存和外设\"\n    },\n    {\n        \"title\": \"计算机中所有信息的存储都采用()\",\n        \"answer\": \"二进制\"\n    },\n    {\n        \"title\": \"幻灯片中占位符的作用是()\",\n        \"answer\": \"为文本、图形预留位置\"\n    },\n    {\n        \"title\": \"Excel2010中不能实现的运算符是\",\n        \"answer\": \"等差运算符\"\n    },\n    {\n        \"title\": \"在Word2010Word2010中，当文档中插入图片对象后，可以通过设置图片的文字环绕方式进行图文混排，下列哪种方式不是Word提供的文字环绕方式()\",\n        \"answer\": \"左右型\"\n    },\n    {\n        \"title\": \"Excel2010所拥有的视图方式有()\",\n        \"answer\": \"普通视图;分页预览视图;页面布局;\"\n    },\n    {\n        \"title\": \"关于“指令”、“指令系统”，哪一种说法是正确的？()\",\n        \"answer\": \"指令通常由操作码和操作数组成;操作码规定计算机进行何种操作;基本指令的集合就是指令系统;\"\n    },\n    {\n        \"title\": \"以下关于管理Excel2010表格正确的表述是()。\",\n        \"answer\": \"可以给工作表插入行;可以给工作表插入列;\"\n    },\n    {\n        \"title\": \"在修改图形的大小时，若想保持其长宽比例不变，应该怎样操作()。\",\n        \"answer\": \"按住shift键，同时用鼠标拖动四角上的控制点;在“布局”对话框中，锁定纵横比;\"\n    },\n    {\n        \"title\": \"在Excel2010中，下面可用来设置和修改图表的操作有：()。\",\n        \"answer\": \"改变分类轴中的文字内容;改变系列图标的类型及颜色;改变背景墙的颜色;改变系列类型;\"\n    },\n    {\n        \"title\": \"下列关于活动窗口的描述中，不正确的是()。\",\n        \"answer\": \"光标的插入点在活动窗口中不会闪烁;活动窗口在任务栏上的按钮处于凸出状态;桌面上可以同时有两个活动窗口;\"\n    },\n    {\n        \"title\": \"当有多个图形时，需要对它们进行对齐，有哪些方式？()\",\n        \"answer\": \"左对齐;右对齐;顶端对齐;两端对齐;\"\n    },\n    {\n        \"title\": \"在Excel2010工作表中，下列正确的公式形式为()。\",\n        \"answer\": \"=B3*Sheet3! A2;=B3*$A2;\"\n    },\n    {\n        \"title\": \"关于windows7中的“命令提示符”方式，正确的说法是()\",\n        \"answer\": \"开机后,可以直接进入“命令提示符”的安全模式;通过“开始”按钮中的“程序/附件”菜单可以进入“命令提示符”方式;用“EXIT”命令,可从命令提示符方式回到windows环境;\"\n    },\n    {\n        \"title\": \"在Word2010的“剪贴板”命令中包括()。\",\n        \"answer\": \"剪切;复制;\"\n    },\n    {\n        \"title\": \"以下能打开资源管理器的操作是()\",\n        \"answer\": \"“开始菜单”→“所有程序”→“附件”→“windows资源管理器”;右击开始按钮选择“打开资源管理器”;按“WIN+E”快捷键;\"\n    },\n    {\n        \"title\": \"以下属于段落格式的有()\",\n        \"answer\": \"首行缩进;段前、段后;行距;\"\n    },\n    {\n        \"title\": \"在Word2010中保存的文件如何在装有 Word2003的机器上打开？()\",\n        \"answer\": \"将其保存为“Word 97-2003”格式;在Word 2003的机器上安装“Office文件格式兼容包”软件;\"\n    },\n    {\n        \"title\": \"在Word2010中，若想知道文档的字符数，可以应用的方法有()\",\n        \"answer\": \"审阅”标签下“校对”功能区的“字数统计”按钮; 快捷键Ctrl+Shift+G;\"\n    },\n    {\n        \"title\": \"在Word2010中，若光标定位在表格外右侧的行尾处，按Enter键，结果是()。\",\n        \"answer\": \"光标下移一列;插入一行，表格行数改变;\"\n    },\n    {\n        \"title\": \"在Excel2010中，“Delete”和“全部清除”命令的区别在于()。\",\n        \"answer\": \"Delete仅能删除单元格的内容;清除命令可删除单元格的内容,格式或批注;\"\n    },\n    {\n        \"title\": \"在Word2010打印设置中，可以进行以下哪些操作()。\",\n        \"answer\": \"打印到文件;手动双面打印;按纸型缩放打印;\"\n    },\n    {\n        \"title\": \"在Excel2010中，工作表“销售额”中的 B2:H308中包含所有的销售数据，在工作表“汇总”中需要计算机销售总额，可采用哪些方法()。\",\n        \"answer\": \"在工作表“汇总”中，输入“=SUM(销售额！B2:H308)”;在工作表“销售额”中，选中B2:H308区域，并在名称框输入“sales ”在工作表“汇总”中，输入“=SUM(sales)”;\"\n    },\n    {\n        \"title\": \"微型计算机的系统总线通常由()组成\",\n        \"answer\": \"数据总线;地址总线;控制总线;\"\n    },\n    {\n        \"title\": \"在Exce12010中，单元格地址引用的方式有（）。\",\n        \"answer\": \"相对引用;绝对引用;混合引用;\"\n    },\n    {\n        \"title\": \"已在某工作表的A1、B1单元格分别输入了，星期一、星期三，并且已将这两个单元格选定了，现将B1单元格右下角的填充柄向右拖动，请问在C1、D1、E1单元格显示的数据会是：星期四、星期五、星期六。\",\n        \"answer\": \"错误\"\n    },\n    {\n        \"title\": \"在单元格中输入i501S2199310220522,默认情况会显示1.50102E+17。\",\n        \"answer\": \"正确\"\n    },\n    {\n        \"title\": \"显示器是一种输出设备。\",\n        \"answer\": \"正确\"\n    },\n    {\n        \"title\": \"在Word编辑状态下，若当前的文本处于竖排状态，当选定若干文字后用鼠标左键单击“更改文字方向”按钮，则文档中的所有文字均变成横排状态。\",\n        \"answer\": \"正确\"\n    },\n    {\n        \"title\": \"窗口最小化是指关闭该窗口。\",\n        \"answer\": \"错误\"\n    },\n    {\n        \"title\": \"在PowerPoint2010的幻灯片放映过程中，要回到上一张幻灯片，可以按Page Up键。\",\n        \"answer\": \"正确\"\n    },\n    {\n        \"title\": \"Excel2010工作簿由多个工作表组成，每个工作表是独立的表对象，所以不能同时对多个工作表进行操作。\",\n        \"answer\": \"错误\"\n    },\n    {\n        \"title\": \"拆分文档窗口是将口拆分为两个，而不是将文档拆分为两个文档，在这两个窗口中对文档进行的编辑处理对文档都会产生影响。\",\n        \"answer\": \"正确\"\n    },\n    {\n        \"title\": \"操作系统的功能之一是提高计算机的运行速度。\",\n        \"answer\": \"错误\"\n    }\n    ]\n    \n    var searchInput = document.getElementById('search-input');\n    var searchButton = document.getElementById('xinxi-search-button');\n    var searchResults = document.getElementById('search-results');\n    console.log(searchButton)\n    searchButton.addEventListener('click', function(){\n        console.log(123);\n\n        performSearch();\n        searchInput.value = '';\n    });\n    \n    searchInput.addEventListener('keydown', function (event) {\n        if (event.key === 'Enter') {\n            performSearch();\n            searchInput.value = ''\n        }\n    });\n    \n    function performSearch() {\n        var keyword = searchInput.value.trim();\n    \n        // Clear previous search results\n        searchResults.innerHTML = '';\n    \n        if (keyword.length > 0) {\n            // Create a regular expression with the search keyword\n            var regex = new RegExp(keyword, 'gi');\n    \n            // Iterate through the quiz questions and check for matches\n            quizQuestions.forEach(function (question) {\n                if (question.title.match(regex)) {\n                    // Create result elements and append them to the search results container\n                    var resultContainer = document.createElement('div');\n                    resultContainer.className = 'result';\n    \n                    var titleElement = document.createElement('div');\n                    titleElement.className = 'title';\n                    titleElement.textContent = question.title;\n                    resultContainer.appendChild(titleElement);\n    \n                    var answerElement = document.createElement('div');\n                    answerElement.innerHTML = 'Answer: ' + `<span class='answer'>${question.answer}</span>`;\n                    resultContainer.appendChild(answerElement);\n    \n                    searchResults.appendChild(resultContainer);\n                    \n                }\n            });\n        }\n    }\n</script>\n{% endraw %}\n"},{"title":"学习强国","url":"/liebiao/xxqg/index.html","content":"## 咳咳...不好意思，请等待更新"},{"url":"/liebiao/xinxi/js/xinxi.js","content":"window.addEventListener('load',function(){\n    var quizQuestions = [{\n        \"title\": \"在Word2010中，要使用“格式刷”命令按钮，应该先选择()选项卡。\",\n        \"answer\": \"开始\"\n    },\n    {\n        \"title\": \"将Word2010文档中一部分内容复制到别处，先要进行的操作是()。\",\n        \"answer\": \"选择\"\n    },\n    {\n        \"title\": \"一组连接计算机各部件的公共通信线称为总线，它的组成是()。\",\n        \"answer\": \"地址线、数据线和控制线\"\n    },\n    {\n        \"title\": \"Word2010编辑状态下，若设置了标尺，则水平标尺和垂直标尺同时显示的视图方式为()。\",\n        \"answer\": \"页面视图\"\n    },\n    {\n        \"title\": \"计算机自诞生以来，无论在性能、价格等方面都发生了巨大的变化，但是()并没有发生多大的改变。\",\n        \"answer\": \"基本工作原理\"\n    },\n    {\n        \"title\": \"在Word2010中，对某文档进行编辑，但是没有保存就直接执行“关闭”命令，则以下说法正确的是()。\",\n        \"answer\": \"系统会弹出提示对话框，询问用户后续操作\"\n    },\n    {\n        \"title\": \"在Excel2010的工作表中，当鼠标的形状变为()时，就可进行自动填充操作。\",\n        \"answer\": \"实心细十字\"\n    },\n    {\n        \"title\": \"Excel2010中，若要选中若干个不连续的单元格，可选按住()键，然后逐一用鼠标单击。\",\n        \"answer\": \"Ctrl\"\n    },\n    {\n        \"title\": \"微型计算机中内存储器比外存储器()。\",\n        \"answer\": \"读写速度快\"\n    },\n    {\n        \"title\": \"中国教育科研网全国网络中心设在()，负责全国主干网的运行管理\",\n        \"answer\": \"清华大学\"\n    },\n    {\n        \"title\": \"在Windows中，用户建立的文件默认具有的属性是（）\",\n        \"answer\": \"存档\"\n    },\n    {\n        \"title\": \"只知道服务器的P地址，而没有该服务器的域名，则无法访问该服务器。()\",\n        \"answer\": \"错误\"\n    },\n    {\n        \"title\": \"()的目的是在使用最少的网络资源和具有最小延迟的前提下，确保网络能提供可靠、连接的通信能力，并使网络资源的使用达到最优化的程度。\",\n        \"answer\": \"性能管理\"\n    },\n    {\n        \"title\": \"E-mail地址中@的含义为()\",\n        \"answer\": \"在\"\n    },\n    {\n        \"title\": \"在PowerPoint2010演示文稿中利用“大纲”窗格组织、排列幻灯片中的文字时，输入幻灯片标题后进入下一级文本输入状态的最快捷方法是()。\",\n        \"answer\": \"按Ctrl+Enter组合键\"\n    },\n    {\n        \"title\": \"在Excel2010中，各运算符号的优先级的顺序为（）。\",\n        \"answer\": \"引用运算符、算术运算符、文本运算符、关系运算符\"\n    },\n    {\n        \"title\": \"下列说法正确的是()\",\n        \"answer\": \"上因特网的计算机必须拥用一个独立的IP地址\"\n    },\n    {\n        \"title\": \"在PowerPoint2010中，要同时选择第1、 2、5三张幻灯片，应该在()视图下操作。\",\n        \"answer\": \"幻灯片浏览\"\n    },\n    {\n        \"title\": \"URL的格式是()\",\n        \"answer\": \"协议：//IP地址或域名/路径/文件名\"\n    },\n    {\n        \"title\": \"Excel中时间和日期都可以()，并可以包含到其他运算当中。\",\n        \"answer\": \"相加、相减\"\n    },\n    {\n        \"title\": \"在计算机中指令主要存放在()中\",\n        \"answer\": \"存储器\"\n    },\n    {\n        \"title\": \"在Word2010中，有关“定时自动保存”功能的说法中，正确的是()。\",\n        \"answer\": \"系统每隔一段时间自动保存在外存中，以避免意外丢失文档内容\"\n    },\n    {\n        \"title\": \"在PowerPoint2010中，若使幻灯片播放时，从“盒状展开”效果变换到下一张幻灯片需要设置()。\",\n        \"answer\": \"幻灯片切换\"\n    },\n    {\n        \"title\": \"计算机中对下列几个部件访问速度最快的是()\",\n        \"answer\": \"主存储器\"\n    },\n    {\n        \"title\": \"电话拨号上网是利用现成的电话线路，通过()将计算机连入Internet。\",\n        \"answer\": \"Modem\"\n    },\n    {\n        \"title\": \"一个工作簿里最多可以包含有()张工作表。\",\n        \"answer\": \"255\"\n    },\n    {\n        \"title\": \"网卡的主要功能不包括 \",\n        \"answer\": \"网络互连\"\n    },\n    {\n        \"title\": \"在PowerPoint2010中，若要更换另一种幻灯片的版式，下列操作正确的是（）\",\n        \"answer\": \"单击“开始”选项卡→“幻灯片”组中“版式”命令按钮\"\n    },\n    {\n        \"title\": \"计算机中正在运行的程序和数据都是保存在计算机的()中。\",\n        \"answer\": \"内存\"\n    },\n    {\n        \"title\": \"在Excel2010中，数字的千位后加千分号“,”,例如230000可以记作()。\",\n        \"answer\": \"230，000\"\n    },\n    {\n        \"title\": \"在Excel2010的数据操作中，计算求和的函数是()\",\n        \"answer\": \"SUM\"\n    },\n    {\n        \"title\": \"下列视图中不属于PowerPoint2010视图的是()。\",\n        \"answer\": \"页面视图\"\n    },\n    {\n        \"title\": \"关于Word编辑页眉页脚，下列叙述()不正确。\",\n        \"answer\": \"文档内容和页眉页脚可在同一窗口编辑\"\n    },\n    {\n        \"title\": \"计算机之所以能按人们的意图自动进行工作，最直接的原因是采用了()。\",\n        \"answer\": \"存储程序控制\"\n    },\n    {\n        \"title\": \"显示或打印汉字时，系统使用的是汉字的()。\",\n        \"answer\": \"字形码\"\n    },\n    {\n        \"title\": \"计算机中用来保存程序和数据，以及运算的中间结果和最后结果的装置是()\",\n        \"answer\": \"内存和外设\"\n    },\n    {\n        \"title\": \"计算机中所有信息的存储都采用()\",\n        \"answer\": \"二进制\"\n    },\n    {\n        \"title\": \"幻灯片中占位符的作用是()\",\n        \"answer\": \"为文本、图形预留位置\"\n    },\n    {\n        \"title\": \"Excel2010中不能实现的运算符是\",\n        \"answer\": \"等差运算符\"\n    },\n    {\n        \"title\": \"在Word2010Word2010中，当文档中插入图片对象后，可以通过设置图片的文字环绕方式进行图文混排，下列哪种方式不是Word提供的文字环绕方式()\",\n        \"answer\": \"左右型\"\n    },\n    {\n        \"title\": \"Excel2010所拥有的视图方式有()\",\n        \"answer\": \"普通视图;分页预览视图;页面布局;\"\n    },\n    {\n        \"title\": \"关于“指令”、“指令系统”，哪一种说法是正确的？()\",\n        \"answer\": \"指令通常由操作码和操作数组成;操作码规定计算机进行何种操作;基本指令的集合就是指令系统;\"\n    },\n    {\n        \"title\": \"以下关于管理Excel2010表格正确的表述是()。\",\n        \"answer\": \"可以给工作表插入行;可以给工作表插入列;\"\n    },\n    {\n        \"title\": \"在修改图形的大小时，若想保持其长宽比例不变，应该怎样操作()。\",\n        \"answer\": \"按住shift键，同时用鼠标拖动四角上的控制点;在“布局”对话框中，锁定纵横比;\"\n    },\n    {\n        \"title\": \"在Excel2010中，下面可用来设置和修改图表的操作有：()。\",\n        \"answer\": \"改变分类轴中的文字内容;改变系列图标的类型及颜色;改变背景墙的颜色;改变系列类型;\"\n    },\n    {\n        \"title\": \"下列关于活动窗口的描述中，不正确的是()。\",\n        \"answer\": \"光标的插入点在活动窗口中不会闪烁;活动窗口在任务栏上的按钮处于凸出状态;桌面上可以同时有两个活动窗口;\"\n    },\n    {\n        \"title\": \"当有多个图形时，需要对它们进行对齐，有哪些方式？()\",\n        \"answer\": \"左对齐;右对齐;顶端对齐;两端对齐;\"\n    },\n    {\n        \"title\": \"在Excel2010工作表中，下列正确的公式形式为()。\",\n        \"answer\": \"=B3*Sheet3! A2;=B3*$A2;\"\n    },\n    {\n        \"title\": \"关于windows7中的“命令提示符”方式，正确的说法是()\",\n        \"answer\": \"开机后,可以直接进入“命令提示符”的安全模式;通过“开始”按钮中的“程序/附件”菜单可以进入“命令提示符”方式;用“EXIT”命令,可从命令提示符方式回到windows环境;\"\n    },\n    {\n        \"title\": \"在Word2010的“剪贴板”命令中包括()。\",\n        \"answer\": \"剪切;复制;\"\n    },\n    {\n        \"title\": \"以下能打开资源管理器的操作是()\",\n        \"answer\": \"“开始菜单”→“所有程序”→“附件”→“windows资源管理器”;右击开始按钮选择“打开资源管理器”;按“WIN+E”快捷键;\"\n    },\n    {\n        \"title\": \"以下属于段落格式的有()\",\n        \"answer\": \"首行缩进;段前、段后;行距;\"\n    },\n    {\n        \"title\": \"在Word2010中保存的文件如何在装有 Word2003的机器上打开？()\",\n        \"answer\": \"将其保存为“Word 97-2003”格式;在Word 2003的机器上安装“Office文件格式兼容包”软件;\"\n    },\n    {\n        \"title\": \"在Word2010中，若想知道文档的字符数，可以应用的方法有()\",\n        \"answer\": \"审阅”标签下“校对”功能区的“字数统计”按钮; 快捷键Ctrl+Shift+G;\"\n    },\n    {\n        \"title\": \"在Word2010中，若光标定位在表格外右侧的行尾处，按Enter键，结果是()。\",\n        \"answer\": \"光标下移一列;插入一行，表格行数改变;\"\n    },\n    {\n        \"title\": \"在Excel2010中，“Delete”和“全部清除”命令的区别在于()。\",\n        \"answer\": \"Delete仅能删除单元格的内容;清除命令可删除单元格的内容,格式或批注;\"\n    },\n    {\n        \"title\": \"在Word2010打印设置中，可以进行以下哪些操作()。\",\n        \"answer\": \"打印到文件;手动双面打印;按纸型缩放打印;\"\n    },\n    {\n        \"title\": \"在Excel2010中，工作表“销售额”中的 B2:H308中包含所有的销售数据，在工作表“汇总”中需要计算机销售总额，可采用哪些方法()。\",\n        \"answer\": \"在工作表“汇总”中，输入“=SUM(销售额！B2:H308)”;在工作表“销售额”中，选中B2:H308区域，并在名称框输入“sales ”在工作表“汇总”中，输入“=SUM(sales)”;\"\n    },\n    {\n        \"title\": \"微型计算机的系统总线通常由()组成\",\n        \"answer\": \"数据总线;地址总线;控制总线;\"\n    },\n    {\n        \"title\": \"在Exce12010中，单元格地址引用的方式有（）。\",\n        \"answer\": \"相对引用;绝对引用;混合引用;\"\n    },\n    {\n        \"title\": \"已在某工作表的A1、B1单元格分别输入了，星期一、星期三，并且已将这两个单元格选定了，现将B1单元格右下角的填充柄向右拖动，请问在C1、D1、E1单元格显示的数据会是：星期四、星期五、星期六。\",\n        \"answer\": \"错误\"\n    },\n    {\n        \"title\": \"在单元格中输入i501S2199310220522,默认情况会显示1.50102E+17。\",\n        \"answer\": \"正确\"\n    },\n    {\n        \"title\": \"显示器是一种输出设备。\",\n        \"answer\": \"正确\"\n    },\n    {\n        \"title\": \"在Word编辑状态下，若当前的文本处于竖排状态，当选定若干文字后用鼠标左键单击“更改文字方向”按钮，则文档中的所有文字均变成横排状态。\",\n        \"answer\": \"正确\"\n    },\n    {\n        \"title\": \"窗口最小化是指关闭该窗口。\",\n        \"answer\": \"错误\"\n    },\n    {\n        \"title\": \"在PowerPoint2010的幻灯片放映过程中，要回到上一张幻灯片，可以按Page Up键。\",\n        \"answer\": \"正确\"\n    },\n    {\n        \"title\": \"Excel2010工作簿由多个工作表组成，每个工作表是独立的表对象，所以不能同时对多个工作表进行操作。\",\n        \"answer\": \"错误\"\n    },\n    {\n        \"title\": \"拆分文档窗口是将口拆分为两个，而不是将文档拆分为两个文档，在这两个窗口中对文档进行的编辑处理对文档都会产生影响。\",\n        \"answer\": \"正确\"\n    },\n    {\n        \"title\": \"操作系统的功能之一是提高计算机的运行速度。\",\n        \"answer\": \"错误\"\n    }\n    ]\n    \n    var searchInput = document.getElementById('search-input');\n    var searchButton = this.document.querySelector('#search-button');\n    var searchResults = document.getElementById('search-results');\n    console.log(searchButton);\n    searchButton.addEventListener('click', function () {\n        performSearch();\n        searchInput.value = ''\n    });\n    \n    searchInput.addEventListener('keydown', function (event) {\n        if (event.key === 'Enter') {\n            performSearch();\n            searchInput.value = ''\n        }\n    });\n    \n    function performSearch() {\n        var keyword = searchInput.value.trim();\n    \n        // Clear previous search results\n        searchResults.innerHTML = '';\n    \n        if (keyword.length > 0) {\n            // Create a regular expression with the search keyword\n            var regex = new RegExp(keyword, 'gi');\n    \n            // Iterate through the quiz questions and check for matches\n            quizQuestions.forEach(function (question) {\n                if (question.title.match(regex)) {\n                    // Create result elements and append them to the search results container\n                    var resultContainer = document.createElement('div');\n                    resultContainer.className = 'result';\n    \n                    var titleElement = document.createElement('div');\n                    titleElement.className = 'title';\n                    titleElement.textContent = question.title;\n                    resultContainer.appendChild(titleElement);\n    \n                    var answerElement = document.createElement('div');\n                    answerElement.textContent = 'Answer: ' + question.answer;\n                    resultContainer.appendChild(answerElement);\n    \n                    searchResults.appendChild(resultContainer);\n                    \n                }\n            });\n        }\n    }\n})"},{"url":"/liebiao/xinxi/css/xinxi.css","content":"#xinxi-search-input {\n    width: 300px;\n    padding: 5px;\n}\n#xinxi-search-results {\n    margin-top: 10px;\n}\n.result {\n    margin-bottom: 5px;\n}\n.title {\n    font-weight: bold;\n}"}]